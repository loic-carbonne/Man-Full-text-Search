
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0"><br>
<p class="level0">
<p class="level0">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 4</span> 
<p class="level1">
<p class="level1">
<p class="level1"><a name="NAME"></a><h2 class="nroffsh">NAME</h2>
<p class="level0">aufs - advanced multi layered unification filesystem. version *[AUFS_VERSION] 
<p class="level0"><a name="DESCRIPTION"></a><h2 class="nroffsh">DESCRIPTION</h2>
<p class="level0">Aufs is a stackable unification filesystem such as Unionfs, which unifies several directories and provides a merged single directory. In the early days, aufs was entirely re-designed and re-implemented Unionfs Version 1.x series. After many original ideas, approaches and improvements, it becomes totally different from Unionfs while keeping the basic features. See Unionfs Version 1.x series for the basic features. Recently, Unionfs Version 2.x series begin taking some of same approaches to aufs[aq]s. 
<p class="level0"><a name="MOUNT"></a><h2 class="nroffsh">MOUNT OPTIONS</h2>
<p class="level0">At mount-time, the order of interpreting options is, 
<p class="level1">
<p class="level1">simple flags, except xino/noxino and udba=notify 
<p class="level1">branches 
<p class="level1">xino/noxino 
<p class="level1">udba=notify 
<p class="level0">
<p class="level0">At remount-time, the options are interpreted in the given order, e.g. left to right. 
<p class="level1">
<p class="level1">create or remove whiteout-base(*[AUFS_WH_BASE]) and whplink-dir(*[AUFS_WH_PLINKDIR]) if necessary 
<p class="level0">
<p class="level0">
<p class="level0"><span Class="bold">br:BRANCH[:BRANCH ...] (dirs=BRANCH[:BRANCH ...])</span> Adds new branches. (cf. Branch Syntax). 
<p class="level0">Aufs rejects the branch which is an ancestor or a descendant of another branch. It is called overlapped. When the branch is loopback-mounted directory, aufs also checks the source fs-image file of loopback device. If the source file is a descendant of another branch, it will be rejected too. 
<p class="level0">After mounting aufs or adding a branch, if you move a branch under another branch and make it descendant of another branch, aufs will not work correctly. By default, aufs prohibits such operation internally, but there left a way to do. (cf. Branch Syntax). 
<p class="level0">
<p class="level0"><span Class="bold">[ add | ins ]:index:BRANCH</span> Adds a new branch. The index begins with 0. Aufs creates whiteout-base(*[AUFS_WH_BASE]) and whplink-dir(*[AUFS_WH_PLINKDIR]) if necessary. 
<p class="level0">If there is the same named file on the lower branch (larger index), aufs will hide the lower file. You can only see the highest file. You will be confused if the added branch has whiteouts (including diropq), they may or may not hide the lower entries. (cf. DIAGNOSTICS). 
<p class="level0">Even if a process have once mapped a file by mmap(2) with MAP_SHARED and the same named file exists on the lower branch, the process still refers the file on the lower(hidden) branch after adding the branch. If you want to update the contents of a process address space after adding, you need to restart your process or open/mmap the file again. (cf. Branch Syntax). 
<p class="level0">
<p class="level0"><span Class="bold">del:dir</span> Removes a branch. Aufs does not remove whiteout-base(*[AUFS_WH_BASE]) and whplink-dir(*[AUFS_WH_PLINKDIR]) automatically. For example, when you add a RO branch which was unified as RW, you will see whiteout-base or whplink-dir on the added RO branch. 
<p class="level0">If a process is referencing the file/directory on the deleting branch (by open, mmap, current working directory, etc.), aufs will return an error EBUSY. In this case, a script [oq]aubusy[cq] (in aufs-util.git and aufs2-util.git) is useful to identify which process (and which file) makes the branch busy. 
<p class="level0">
<p class="level0"><span Class="bold">mod:BRANCH</span> Modifies the permission flags of the branch. Aufs creates or removes whiteout-base(*[AUFS_WH_BASE]) and/or whplink-dir(*[AUFS_WH_PLINKDIR]) if necessary. 
<p class="level0">If the branch permission is been changing [oq]rw[cq] to [oq]ro[cq], and a process is mapping a file by mmap(2) on the branch, the process may or may not be able to modify its mapped memory region after modifying branch permission flags. Additioanlly when you enable CONFIG_IMA (in linux-2.6.30 and later), IMA may produce some wrong messages. But this is equivalent when the filesystem is changed [oq]ro[cq] in emergency. (cf. Branch Syntax). 
<p class="level0">
<p class="level0"><span Class="bold">append:BRANCH</span> equivalent to [oq]add:(last index + 1):BRANCH[cq]. (cf. Branch Syntax). 
<p class="level0">
<p class="level0"><span Class="bold">prepend:BRANCH</span> equivalent to [oq]add:0:BRANCH.[cq] (cf. Branch Syntax). 
<p class="level0">
<p class="level0"><span Class="bold">xino=filename</span> Use external inode number bitmap and translation table. When CONFIG_AUFS_EXPORT is enabled, external inode generation table too. It is set to &lt;FirstWritableBranch&gt;/*[AUFS_XINO_FNAME] by default, or *[AUFS_XINO_DEFPATH]. Comma character in filename is not allowed. 
<p class="level0">The files are created per an aufs and per a branch filesystem, and unlinked. So you cannot find this file, but it exists and is read/written frequently by aufs. When the specified file already exists, then mount(8) returns an error. (cf. External Inode Number Bitmap, Translation Table and Generation Table). 
<p class="level0">If you enable CONFIG_SYSFS, the path of xino files are not shown in /proc/mounts (and /etc/mtab), instead it is shown in &lt;sysfs&gt;/fs/aufs/si_&lt;id&gt;/xi_path. Otherwise, it is shown in /proc/mounts unless it is not the default path. 
<p class="level0">
<p class="level0"><span Class="bold">noxino</span> Stop using external inode number bitmap and translation table. 
<p class="level0">If you use this option, Some applications will not work correctly. (cf. External Inode Number Bitmap, Translation Table and Generation Table). 
<p class="level0">
<p class="level0"><span Class="bold">trunc_xib</span> Truncate the external inode number bitmap file. The truncation is done automatically when you delete a branch unless you do not specify [oq]notrunc_xib[cq] option. (cf. External Inode Number Bitmap, Translation Table and Generation Table). 
<p class="level0">
<p class="level0"><span Class="bold">notrunc_xib</span> Stop truncating the external inode number bitmap file when you delete a branch. (cf. External Inode Number Bitmap, Translation Table and Generation Table). 
<p class="level0">
<p class="level0"><span Class="bold">trunc_xino_path=BRANCH | itrunc_xino=INDEX</span> Truncate the external inode number translation table per branch. The branch can be specified by path or index (its origin is 0). Sometimes the size of a xino file for tmpfs branch grows very big. If you don[aq]t like such situation, try "mount -o remount,trunc_xino_path=BRANCH /your/aufs" (or itrunc_xino=INDEX). It will shrink the xino file for BRANCH. These options are one time actions. So the size may grow again. In order to make it work automatically when necessary, try trunc_xino option. These options are already implemented, but its design is not fixed (cf. External Inode Number Bitmap, Translation Table and Generation Table). 
<p class="level0">
<p class="level0"><span Class="bold">trunc_xino | notrunc_xino</span> Enable (or disable) the automatic truncation of xino files. The truncation is done by discarding the internal "hole" (unused blocks). The default is notrunc_xino. These options are already implemented, but its design is not fixed (cf. External Inode Number Bitmap, Translation Table and Generation Table). 
<p class="level0">TODO: costomizable two values for upper limit " . " .TP " .B trunc_xino_v=n:n 
<p class="level0">
<p class="level0"><span Class="bold">create_policy | create=CREATE_POLICY</span> 
<p class="level0"><span Class="bold">copyup_policy | copyup | cpup=COPYUP_POLICY</span> Policies to select one among multiple writable branches. The default values are [oq]create=tdp[cq] and [oq]cpup=tdp[cq]. link(2) and rename(2) systemcalls have an exception. In aufs, they try keeping their operations in the branch where the source exists. (cf. Policies to Select One among Multiple Writable Branches). 
<p class="level0">
<p class="level0"><span Class="bold">dio</span> Enable Direct I/O support (including Linux AIO), and always make open(2) with O_DIRECT success. But if your branch filessystem doesn[aq]t support it, then the succeeding I/O will fail (cf, Direct I/O). 
<p class="level0">
<p class="level0"><span Class="bold">nodio</span> Disable Direct I/O (including Linux AIO), and always make open(2) with O_DIRECT fail. This is default value (cf, Direct I/O). 
<p class="level0">
<p class="level0"><span Class="bold">verbose | v</span> Print some information. Currently, it is only busy file (or inode) at deleting a branch. 
<p class="level0">
<p class="level0"><span Class="bold">noverbose | quiet | q | silent</span> Disable [oq]verbose[cq] option. This is default value. 
<p class="level0">
<p class="level0"><span Class="bold">sum</span> df(1)/statfs(2) returns the total number of blocks and inodes of all branches. When the block size of all branches are not equal, aufs choses the smallest one and calculate the number of blocks (including bavail and bfree). Note that there are cases that systemcalls may return ENOSPC, even if df(1)/statfs(2) shows that aufs has some free space/inode. 
<p class="level0">
<p class="level0"><span Class="bold">nosum</span> Disable [oq]sum[cq] option. This is default value. 
<p class="level0">
<p class="level0"><span Class="bold">dirwh=N</span> Watermark to remove a dir actually at rmdir(2) and rename(2). 
<p class="level0">If the target dir which is being removed or renamed (destination dir) has a huge number of whiteouts, i.e. the dir is empty logically but physically, the cost to remove/rename the single dir may be very high. It is required to unlink all of whiteouts internally before issuing rmdir/rename to the branch. To reduce the cost of single systemcall, aufs renames the target dir to a whiteout-ed temporary name and invokes a pre-created kernel thread to remove whiteout-ed children and the target dir. The rmdir/rename systemcall returns just after kicking the thread. 
<p class="level0">When the number of whiteout-ed children is less than the value of dirwh, aufs remove them in a single systemcall instead of passing another thread. This value is ignored when the branch is NFS. The default value is *[AUFS_DIRWH_DEF]. 
<p class="level0">
<p class="level0"><span Class="bold">rdblk=N</span> Specifies a size of internal VDIR block which is allocated at a time in byte. The VDIR block will be allocated several times when necessary. If your directory has millions of files, you may want to expand this size. The default value is defined as *[AUFS_RDBLK_DEF]. The size has to be lager than NAME_MAX (usually 255) and kmalloc-able (the maximum limit depends on your system. at least 128KB is available for every system). If you set it to zero, then the internal estimation for the directory size becomes ON, and aufs sets the value for the directory individually. Sometimes the estimated value may be inappropriate since the estimation is not so clever. Setting zero is useful when you use RDU (cf. VDIR/readdir(3) in user-space (RDU). Otherwise it may be a pressure for kernel memory space. Anytime you can reset the value to default by specifying rdblk=def. (cf. Virtual or Vertical Directory Block). 
<p class="level0">
<p class="level0"><span Class="bold">rdhash=N</span> Specifies a size of internal VDIR hash table which is used to compare the file names under the same named directory on multiple branches. The VDIR hash table will be allocated in readdir(3)/getdents(2), rmdir(2) and rename(2) for the existing target directory. If your directory has millions of files, you may want to expand this size. The default value is defined as *[AUFS_RDHASH_DEF]. The size has to be lager than zero, and it will be multiplied by 4 or 8 (for 32-bit and 64-bit respectively, currently). The result must be kmalloc-able (the maximum limit depends on your system. at least 128KB is available for every system). If you set it to zero, then the internal estimation for the directory becomes ON, and aufs sets the value for the directory individually. Sometimes the estimated value may be inappropriate since the estimation is not so clever. Setting zero is useful when you use RDU (cf. VDIR/readdir(3) in user-space (RDU). Otherwise it may be a pressure for kernel memory space. Anytime you can reset the value to default by specifying rdhash=def. (cf. Virtual or Vertical Directory Block). 
<p class="level0">
<p class="level0"><span Class="bold">plink</span> 
<p class="level0"><span Class="bold">noplink</span> Specifies to use [oq]pseudo link[cq] feature or not. The default is [oq]plink[cq] which means use this feature. (cf. Pseudo Link) 
<p class="level0">
<p class="level0"><span Class="bold">clean_plink</span> Removes all pseudo-links in memory. In order to make pseudo-link permanent, use [oq]auplink[cq] utility just before one of these operations, unmounting aufs, using [oq]ro[cq] or [oq]noplink[cq] mount option, deleting a branch from aufs, adding a branch into aufs, or changing your writable branch as readonly. If you installed both of /sbin/mount.aufs and /sbin/umount.aufs, and your mount(8) and umount(8) support them, [oq]auplink[cq] utility will be executed automatically and flush pseudo-links. (cf. Pseudo Link) 
<p class="level0">
<p class="level0"><span Class="bold">udba=none | reval | notify</span> Specifies the level of UDBA (User[aq]s Direct Branch Access) test. (cf. User[aq]s Direct Branch Access and Inotify Limitation). 
<p class="level0">
<p class="level0"><span Class="bold">diropq=whiteouted | w | always | a</span> Specifies whether mkdir(2) and rename(2) dir case make the created directory [oq]opaque[cq] or not. In other words, to create [oq]*[AUFS_WH_DIROPQ][cq] under the created or renamed directory, or not to create. When you specify diropq=w or diropq=whiteouted, aufs will not create it if the directory was not whiteouted or opaqued. If the directory was whiteouted or opaqued, the created or renamed directory will be opaque. When you specify diropq=a or diropq==always, aufs will always create it regardless the directory was whiteouted/opaqued or not. The default value is diropq=w, it means not to create when it is unnecessary. 
<p class="level0">
<p class="level0"><span Class="bold">warn_perm</span> 
<p class="level0"><span Class="bold">nowarn_perm</span> Adding a branch, aufs will issue a warning about uid/gid/permission of the adding branch directory, when they differ from the existing branch[aq]s. This difference may or may not impose a security risk. If you are sure that there is no problem and want to stop the warning, use [oq]nowarn_perm[cq] option. The default is [oq]warn_perm[cq] (cf. DIAGNOSTICS). 
<p class="level0">
<p class="level0"><span Class="bold">shwh</span> 
<p class="level0"><span Class="bold">noshwh</span> By default (noshwh), aufs doesn[aq]t show the whiteouts and they just hide the same named entries in the lower branches. The whiteout itself also never be appeared. If you enable CONFIG_AUFS_SHWH and specify [oq]shwh[cq] option, aufs will show you the name of whiteouts with keeping its feature to hide the lowers. Honestly speaking, I am rather confused with this [oq]visible whiteouts.[cq] But a user who originally requested this feature wrote a nice how-to document about this feature. See Tips file in the aufs CVS tree. 
<p class="level0"><a name="Module"></a><h2 class="nroffsh">Module Parameters</h2>
<p class="level0">
<p class="level0"><span Class="bold">brs=1 | 0</span> Specifies to use the branch path data file under sysfs or not. 
<p class="level0">If the number of your branches is large or their path is long and you meet the limitation of mount(8) ro /etc/mtab, you need to enable CONFIG_SYSFS and set aufs module parameter brs=1. 
<p class="level0">When this parameter is set as 1, aufs does not show [oq]br:[cq] (or dirs=) mount option through /proc/mounts (and /etc/mtab). So you can keep yourself from the page limitation of mount(8) or /etc/mtab. Aufs shows branch paths through &lt;sysfs&gt;/fs/aufs/si_XXX/brNNN. Actually the file under sysfs has also a size limitation, but I don[aq]t think it is harmful. 
<p class="level0">There is one more side effect in setting 1 to this parameter. If you rename your branch, the branch path written in /etc/mtab will be obsoleted and the future remount will meet some error due to the unmatched parameters (Remember that mount(8) may take the options from /etc/mtab and pass them to the systemcall). If you set 1, /etc/mtab will not hold the branch path and you will not meet such trouble. On the other hand, the entries for the branch path under sysfs are generated dynamically. So it must not be obsoleted. But I don[aq]t think users want to rename branches so often. 
<p class="level0">If CONFIG_SYSFS is disable, this parameter is always set to 0. 
<p class="level0">
<p class="level0"><span Class="bold">sysrq=key</span> Specifies MagicSysRq key for debugging aufs. You need to enable both of CONFIG_MAGIC_SYSRQ and CONFIG_AUFS_DEBUG. Currently this is for developers only. The default is [oq]a[cq]. 
<p class="level0">
<p class="level0"><span Class="bold">debug= 0 | 1</span> Specifies disable(0) or enable(1) debug print in aufs. This parameter can be changed dynamically. You need to enable CONFIG_AUFS_DEBUG. Currently this is for developers only. The default is [oq]0[cq] (disable). 
<p class="level0"><a name="Entries"></a><h2 class="nroffsh">Entries under Sysfs and Debugfs</h2>
<p class="level0">See linux/Documentation/ABI/*/{sys,debug}fs-aufs. 
<p class="level0"><a name="Branch"></a><h2 class="nroffsh">Branch Syntax</h2>
<p class="level0">
<p class="level0"><span Class="bold">dir_path[ =permission [ + attribute ] ]</span> 
<p class="level0"><span Class="bold">permission := rw | ro | rr</span> 
<p class="level0"><span Class="bold">attribute := wh | nolwh</span> dir_path is a directory path. The keyword after [oq]dir_path=[cq] is a permission flags for that branch. Comma, colon and the permission flags string (including [oq]=[cq])in the path are not allowed. 
<p class="level0">Any filesystem can be a branch, But some are not accepted such like sysfs, procfs and unionfs. If you specify such filesystems as an aufs branch, aufs will return an error saying it is unsupported. 
<p class="level0">Cramfs in linux stable release has strange inodes and it makes aufs confused. For example, <pre class="level0">
$ mkdir -p w/d1 w/d2
$ &gt; w/z1
$ &gt; w/z2
$ mkcramfs w cramfs
$ sudo mount -t cramfs -o ro,loop cramfs /mnt
$ find /mnt -ls
&nbsp;   76    1 drwxr-xr-x   1 jro      232            64 Jan  1  1970 /mnt
&nbsp;    1    1 drwxr-xr-x   1 jro      232             0 Jan  1  1970 /mnt/d1
&nbsp;    1    1 drwxr-xr-x   1 jro      232             0 Jan  1  1970 /mnt/d2
&nbsp;    1    1 -rw-r--r--   1 jro      232             0 Jan  1  1970 /mnt/z1
&nbsp;    1    1 -rw-r--r--   1 jro      232             0 Jan  1  1970 /mnt/z2
</pre>

<p class="level0">
<p class="level0">All these two directories and two files have the same inode with one as their link count. Aufs cannot handle such inode correctly. Currently, aufs involves a tiny workaround for such inodes. But some applications may not work correctly since aufs inode number for such inode will change silently. If you do not have any empty files, empty directories or special files, inodes on cramfs will be all fine. 
<p class="level0">A branch should not be shared as the writable branch between multiple aufs. A readonly branch can be shared. 
<p class="level0">The maximum number of branches is configurable at compile time (127 by default). 
<p class="level0">When an unknown permission or attribute is given, aufs sets ro to that branch silently. 
<p class="level0"><a name="Permission"></a><h2 class="nroffsh">Permission</h2>
<p class="level0">
<p class="level0">
<p class="level0"><span Class="bold">rw</span> Readable and writable branch. Set as default for the first branch. If the branch filesystem is mounted as readonly, you cannot set it [oq]rw.[cq] 
<p class="level0">
<p class="level0"><span Class="bold">ro</span> Readonly branch and it has no whiteouts on it. Set as default for all branches except the first one. Aufs never issue both of write operation and lookup operation for whiteout to this branch. 
<p class="level0">
<p class="level0"><span Class="bold">rr</span> Real readonly branch, special case of [oq]ro[cq], for natively readonly branch. Assuming the branch is natively readonly, aufs can optimize some internal operation. For example, if you specify [oq]udba=notify[cq] option, aufs does not set fsnotify or inotify for the things on rr branch. Set by default for a branch whose fs-type is either [oq]iso9660[cq], [oq]cramfs[cq] or [oq]romfs[cq] (and [oq]squashfs[cq] for linux-2.6.29 and later). 
<p class="level0">When your branch exists on slower device and you have some capacity on your hdd, you may want to try ulobdev tool in ULOOP sample. It can cache the contents of the real devices on another faster device, so you will be able to get the better access performance. The ulobdev tool is for a generic block device, and the ulohttp is for a filesystem image on http server. If you want to spin down your hdd to save the battery life or something, then you may want to use ulobdev to save the access to the hdd, too. See $AufsCVS/sample/uloop in detail. 
<p class="level0"><a name="Attribute"></a><h2 class="nroffsh">Attribute</h2>
<p class="level0">
<p class="level0">
<p class="level0"><span Class="bold">wh</span> Readonly branch and it has/might have whiteouts on it. Aufs never issue write operation to this branch, but lookup for whiteout. Use this as [oq]&lt;branch_dir&gt;=ro+wh[cq]. 
<p class="level0">
<p class="level0"><span Class="bold">nolwh</span> Usually, aufs creates a whiteout as a hardlink on a writable branch. This attributes prohibits aufs to create the hardlinked whiteout, including the source file of all hardlinked whiteout (*[AUFS_WH_BASE].) If you do not like a hardlink, or your writable branch does not support link(2), then use this attribute. But I am afraid a filesystem which does not support link(2) natively will fail in other place such as copy-up. Use this as [oq]&lt;branch_dir&gt;=rw+nolwh[cq]. Also you may want to try [oq]noplink[cq] mount option, while it is not recommended. 
<p class="level0">
<p class="level0"><span Class="bold">unpin</span> By default, aufs sets [oq]pin[cq] to the branch dir, which means that users cannot remove nor rename the branch top dir as if it were a mount-point. In some cases and some users may need to rename the branch top dir. So this attribute is implemented. If you specify [oq]unpin[cq] as a branch attribute, it stops behaving as a mount-point and you can rename the branch top dir. Needless to say, if you remove the branch top dir, then aufs cannot work. 
<p class="level0">
<p class="level0"><a name="External"></a><h2 class="nroffsh">External Inode Number Bitmap, Translation Table and Generation Table (xino)</h2>
<p class="level0">Aufs uses one external bitmap file and one external inode number translation table files per an aufs and per a branch filesystem by default. Additionally when CONFIG_AUFS_EXPORT is enabled, one external inode generation table is added. The bitmap (and the generation table) is for recycling aufs inode number and the others are a table for converting an inode number on a branch to an aufs inode number. The default path is [oq]first writable branch[cq]/*[AUFS_XINO_FNAME]. If there is no writable branch, the default path will be *[AUFS_XINO_DEFPATH]. 
<p class="level0">If you enable CONFIG_SYSFS, the path of xino files are not shown in /proc/mounts (and /etc/mtab), instead it is shown in &lt;sysfs&gt;/fs/aufs/si_&lt;id&gt;/xi_path. Otherwise, it is shown in /proc/mounts unless it is not the default path. 
<p class="level0">Those files are always opened and read/write by aufs frequently. If your writable branch is on flash memory device, it is recommended to put xino files on other than flash memory by specifying [oq]xino=[cq] mount option. 
<p class="level0">The maximum file size of the bitmap is, basically, the amount of the number of all the files on all branches divided by 8 (the number of bits in a byte). For example, on a 4KB page size system, if you have 32,768 (or 2,599,968) files in aufs world, then the maximum file size of the bitmap is 4KB (or 320KB). 
<p class="level0">The maximum file size of the table will be [oq]max inode number on the branch x size of an inode number[cq]. For example in 32bit environment, 
<p class="level0"><pre class="level0">
$ df -i /branch_fs
/dev/hda14           2599968  203127 2396841    8% /branch_fs
</pre>

<p class="level0">
<p class="level0">and /branch_fs is an branch of the aufs. When the inode number is assigned contiguously (without [oq]hole[cq]), the maximum xino file size for /branch_fs will be 2,599,968 x 4 bytes = about 10 MB. But it might not be allocated all of disk blocks. When the inode number is assigned discontinuously, the maximum size of xino file will be the largest inode number on a branch x 4 bytes. Additionally, the file size is limited to LLONG_MAX or the s_maxbytes in filesystem[aq]s superblock (s_maxbytes may be smaller than LLONG_MAX). So the support-able largest inode number on a branch is less than 2305843009213693950 (LLONG_MAX/4-1). This is the current limitation of aufs. On 64bit environment, this limitation becomes more strict and the supported largest inode number is less than LLONG_MAX/8-1. In order to estimate the size of the table for your readonly branch fs, try 
<p class="level0"><pre class="level0">
$ echo $((4 * $(sudo find /branch_fs -xdev -printf "%i\n" |
	sort -n | tail -n 1)))
</pre>

<p class="level0">
<p class="level0">For 64bit environment, replace 4 by 8 in above equation. 
<p class="level0">The xino files are always hidden, i.e. removed. So you cannot do [oq]ls -l xino_file[cq]. If you enable CONFIG_DEBUG_FS, you can check these information through &lt;debugfs&gt;/aufs/&lt;si_id&gt;/{xib,xi[0-9]*,xigen}. xib is for the bitmap file, xi0 ix for the first branch, and xi1 is for the next. xigen is for the generation table. xib and xigen are in the format of, 
<p class="level0"><pre class="level0">
&lt;blocks&gt;x&lt;block size&gt; &lt;file size&gt;
</pre>

<p class="level0">
<p class="level0">Note that a filesystem usually has a feature called pre-allocation, which means a number of blocks are allocated automatically, and then deallocated silently when the filesystem thinks they are unnecessary. You do not have to be surprised the sudden changes of the number of blocks, when your filesystem which xino files are placed supports the pre-allocation feature. 
<p class="level0">The rests are hidden xino file information in the format of, 
<p class="level0"><pre class="level0">
&lt;file count&gt;, &lt;blocks&gt;x&lt;block size&gt; &lt;file size&gt;
</pre>

<p class="level0">
<p class="level0">If the file count is larger than 1, it means some of your branches are on the same filesystem and the xino file is shared by them. Note that the file size may not be equal to the actual consuming blocks since xino file is a sparse file, i.e. a hole in a file which does not consume any disk blocks. 
<p class="level0">Once you unmount aufs, the xino files for that aufs are totally gone. It means that the inode number is not permanent across umount or shutdown. 
<p class="level0">The xino files should be created on the filesystem except NFS. If your first writable branch is NFS, you will need to specify xino file path other than NFS. Also if you are going to remove the branch where xino files exist or change the branch permission to readonly, you need to use xino option before del/mod the branch. 
<p class="level0">The bitmap file and the table can be truncated. For example, if you delete a branch which has huge number of files, many inode numbers will be recycled and the bitmap will be truncated to smaller size. Aufs does this automatically when a branch is deleted. You can truncate it anytime you like if you specify [oq]trunc_xib[cq] mount option. But when the accessed inode number was not deleted, nothing will be truncated. The truncation is essentially equivalent to 
<p class="level0"><pre class="level0">
$ cp --sparse=always &lt;current xino file&gt; &lt;new xino file&gt; &&
	rm &lt;current xino file&gt;
</pre>

<p class="level0">
<p class="level0">It means that you have two xino files during the copy, and you should pay attention to the free space of the filesystem where the xino file is located. If the free space is not large enough to hold two xino files temporary during the copy, then the truncation fails and the xino file will go on growing. For such case, you should move the xino file to another larger partition, and move it back to where it was (if you want). To do this, use [oq]xino=[cq] mount option. During this move, the xino file is truncated automatically. 
<p class="level0">If you do not want to truncate it (it may be slow) when you delete a branch, specify [oq]notrunc_xib[cq] after [oq]del[cq] mount option. For the table, see trunc_xino_path=BRANCH, itrunc_xino=INDEX, trunc_xino and notrunc_xino option. 
<p class="level0">If you do not want to use xino, use noxino mount option. Use this option with care, since the inode number may be changed silently and unexpectedly anytime. For example, rmdir failure, recursive chmod/chown/etc to a large and deep directory or anything else. And some applications will not work correctly. If you want to change the xino default path, use xino mount option. 
<p class="level0">After you add branches, the persistence of inode number may not be guaranteed. At remount time, cached but unused inodes are discarded. And the newly appeared inode may have different inode number at the next access time. The inodes in use have the persistent inode number. 
<p class="level0">When aufs assigned an inode number to a file, and if you create the same named file on the upper branch directly, then the next time you access the file, aufs may assign another inode number to the file even if you use xino option. Some applications may treat the file whose inode number has been changed as totally different file. 
<p class="level0"><a name="Pseudo"></a><h2 class="nroffsh">Pseudo Link (hardlink over branches)</h2>
<p class="level0">Aufs supports [oq]pseudo link[cq] which is a logical hard-link over branches (cf. ln(1) and link(2)). In other words, a copied-up file by link(2) and a copied-up file which was hard-linked on a readonly branch filesystem. 
<p class="level0">When you have files named fileA and fileB which are hardlinked on a readonly branch, if you write something into fileA, aufs copies-up fileA to a writable branch, and write(2) the originally requested thing to the copied-up fileA. On the writable branch, fileA is not hardlinked. But aufs remembers it was hardlinked, and handles fileB as if it existed on the writable branch, by referencing  fileA[aq]s inode on the writable branch as fileB[aq]s inode. 
<p class="level0">Once you unmount aufs, the plink info for that aufs kept in memory are totally gone. It means that the pseudo-link is not permanent. If you want to make plink permanent, try [oq]auplink[cq] utility just before one of these operations, unmounting your aufs, using [oq]ro[cq] or [oq]noplink[cq] mount option, deleting a branch from aufs, adding a branch into aufs, or changing your writable branch to readonly. 
<p class="level0">This utility will reproduces all real hardlinks on a writable branch by linking them, and removes pseudo-link info in memory and temporary link on the writable branch. Since this utility access your branches directly, you cannot hide them by [oq]mount --bind /tmp /branch[cq] or something. 
<p class="level0">If you are willing to rebuild your aufs with the same branches later, you should use auplink utility before you umount your aufs. If you installed both of /sbin/mount.aufs and /sbin/umount.aufs, and your mount(8) and umount(8) support them, [oq]auplink[cq] utility will be executed automatically and flush pseudo-links. 
<p class="level0">During this utility is running, it puts aufs into the pseudo-link maintenance mode. In this mode, only the process which began the maintenance mode (and its child processes) is allowed to operate in aufs. Some other processes which are not related to the pseudo-link will be allowed to run too, but the rest have to return an error or wait until the maintenance mode ends. If a process already acquires an inode mutex (in VFS), it has to return an error. 
<p class="level0">Due to the fact that the pseudo-link maintenance mode is operated via procfs, the pseudo-link feature itself (including the related mount options) depends upon CONFIG_PROC_FS too. 
<p class="level0"><pre class="level0">
&#35; auplink /your/aufs/root flush
&#35; umount /your/aufs/root
or
&#35; auplink /your/aufs/root flush
&#35; mount -o remount,mod:/your/writable/branch=ro /your/aufs/root
or
&#35; auplink /your/aufs/root flush
&#35; mount -o remount,noplink /your/aufs/root
or
&#35; auplink /your/aufs/root flush
&#35; mount -o remount,del:/your/aufs/branch /your/aufs/root
or
&#35; auplink /your/aufs/root flush
&#35; mount -o remount,append:/your/aufs/branch /your/aufs/root
</pre>

<p class="level0">
<p class="level0">The plinks are kept both in memory and on disk. When they consumes too much resources on your system, you can use the [oq]auplink[cq] utility at anytime and throw away the unnecessary pseudo-links in safe. 
<p class="level0">Additionally, the [oq]auplink[cq] utility is very useful for some security reasons. For example, when you have a directory whose permission flags are 0700, and a file who is 0644 under the 0700 directory. Usually, all files under the 0700 directory are private and no one else can see the file. But when the directory is 0711 and someone else knows the 0644 filename, he can read the file. 
<p class="level0">Basically, aufs pseudo-link feature creates a temporary link under the directory whose owner is root and the permission flags are 0700. But when the writable branch is NFS, aufs sets 0711 to the directory. When the 0644 file is pseudo-linked, the temporary link, of course the contents of the file is totally equivalent, will be created under the 0711 directory. The filename will be generated by its inode number. While it is hard to know the generated filename, someone else may try peeping the temporary pseudo-linked file by his software tool which may try the name from one to MAX_INT or something. In this case, the 0644 file will be read unexpectedly. I am afraid that leaving the temporary pseudo-links can be a security hole. It makes sense to execute [oq]auplink /your/aufs/root flush[cq] periodically, when your writable branch is NFS. 
<p class="level0">When your writable branch is not NFS, or all users are careful enough to set 0600 to their private files, you do not have to worry about this issue. 
<p class="level0">If you do not want this feature, use [oq]noplink[cq] mount option. 
<p class="level0"><a name="The"></a><h2 class="nroffsh">The behaviours of plink and noplink</h2>
<p class="level0">This sample shows that the [oq]f_src_linked2[cq] with [oq]noplink[cq] option cannot follow the link. 
<p class="level0"><pre class="level0">
none on /dev/shm/u type aufs (rw,xino=/dev/shm/rw/.aufs.xino,br:/dev/shm/rw=rw:/dev/shm/ro=ro)
$ ls -li ../r?/f_src_linked* ./f_src_linked* ./copied
ls: ./copied: No such file or directory
15 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked
15 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked2
22 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ./f_src_linked
22 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ./f_src_linked2
$ echo abc &gt;&gt; f_src_linked
$ cp f_src_linked copied
$ ls -li ../r?/f_src_linked* ./f_src_linked* ./copied
15 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked
15 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked2
36 -rw-r--r--  2 jro jro 6 Dec 22 11:03 ../rw/f_src_linked
53 -rw-r--r--  1 jro jro 6 Dec 22 11:03 ./copied
22 -rw-r--r--  2 jro jro 6 Dec 22 11:03 ./f_src_linked
22 -rw-r--r--  2 jro jro 6 Dec 22 11:03 ./f_src_linked2
$ cmp copied f_src_linked2
$
&nbsp;
none on /dev/shm/u type aufs (rw,xino=/dev/shm/rw/.aufs.xino,noplink,br:/dev/shm/rw=rw:/dev/shm/ro=ro)
$ ls -li ../r?/f_src_linked* ./f_src_linked* ./copied
ls: ./copied: No such file or directory
17 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked
17 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked2
23 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ./f_src_linked
23 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ./f_src_linked2
$ echo abc &gt;&gt; f_src_linked
$ cp f_src_linked copied
$ ls -li ../r?/f_src_linked* ./f_src_linked* ./copied
17 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked
17 -rw-r--r--  2 jro jro 2 Dec 22 11:03 ../ro/f_src_linked2
36 -rw-r--r--  1 jro jro 6 Dec 22 11:03 ../rw/f_src_linked
53 -rw-r--r--  1 jro jro 6 Dec 22 11:03 ./copied
23 -rw-r--r--  2 jro jro 6 Dec 22 11:03 ./f_src_linked
23 -rw-r--r--  2 jro jro 6 Dec 22 11:03 ./f_src_linked2
$ cmp copied f_src_linked2
cmp: EOF on f_src_linked2
$
</pre>

<p class="level0">
<p class="level0">
<p class="level0">If you add a branch which has fileA or fileB, aufs does not follow the pseudo link. The file on the added branch has no relation to the same named file(s) on the lower branch(es). If you use noxino mount option, pseudo link will not work after the kernel shrinks the inode cache. 
<p class="level0">This feature will not work for squashfs before version 3.2 since its inode is tricky. When the inode is hardlinked, squashfs inodes has the same inode number and correct link count, but the inode memory object is different. Squashfs inodes (before v3.2) are generated for each, even they are hardlinked. 
<p class="level0"><a name="Useraqs"></a><h2 class="nroffsh">User\[aq]s Direct Branch Access (UDBA)</h2>
<p class="level0">UDBA means a modification to a branch filesystem manually or directly, e.g. bypassing aufs. While aufs is designed and implemented to be safe after UDBA, it can make yourself and your aufs confused. And some information like aufs inode will be incorrect. For example, if you rename a file on a branch directly, the file on aufs may or may not be accessible through both of old and new name. Because aufs caches various information about the files on branches. And the cache still remains after UDBA. 
<p class="level0">Aufs has a mount option named [oq]udba[cq] which specifies the test level at access time whether UDBA was happened or not. 
<p class="level0">
<p class="level0"><span Class="bold">udba=none</span> Aufs trusts the dentry and the inode cache on the system, and never test about UDBA. With this option, aufs runs fastest, but it may show you incorrect data. Additionally, if you often modify a branch directly, aufs will not be able to trace the changes of inodes on the branch. It can be a cause of wrong behaviour, deadlock or anything else. 
<p class="level0">It is recommended to use this option only when you are sure that nobody access a file on a branch. It might be difficult for you to achieve real [oq]no UDBA[cq] world when you cannot stop your users doing [oq]find / -ls[cq] or something. If you really want to forbid all of your users to UDBA, here is a trick for it. With this trick, users cannot see the branches directly and aufs runs with no problem, except [oq]auplink[cq] utility. But if you are not familiar with aufs, this trick may make yourself confused. 
<p class="level0"><pre class="level0">
&#35; d=/tmp/.aufs.hide
&#35; mkdir $d
&#35; for i in $branches_you_want_to_hide
&gt; do
&gt;	mount -n --bind $d $i
&gt; done
</pre>

<p class="level0">
<p class="level0">When you unmount the aufs, delete/modify the branch by remount, or you want to show the hidden branches again, unmount the bound /tmp/.aufs.hide. 
<p class="level0"><pre class="level0">
&#35; umount -n $branches_you_want_to_unbound
</pre>

<p class="level0">
<p class="level0">If you use FUSE filesystem as an aufs branch which supports hardlink, you should not set this option, since FUSE makes inode objects for each hardlinks (at least in linux-2.6.23). When your FUSE filesystem maintains them at link/unlinking, it is equivalent to [oq]direct branch access[cq] for aufs. 
<p class="level0">
<p class="level0">
<p class="level0"><span Class="bold">udba=reval</span> Aufs tests only the existence of the file which existed. If the existed file was removed on the branch directly, aufs discard the cache about the file and re-lookup it. So the data will be updated. This test is at minimum level to keep the performance and ensure the existence of a file. This is default and aufs runs still fast. 
<p class="level0">This rule leads to some unexpected situation, but I hope it is harmless. Those are totally depends upon cache. Here are just a few examples. 
<p class="level0">
<p class="level1">
<p class="level1">If the file is cached as negative or not-existed, aufs does not test it. And the file is still handled as negative after a user created the file on a branch directly. If the file is not cached, aufs will lookup normally and find the file. 
<p class="level1">
<p class="level1">When the file is cached as positive or existed, and a user created the same named file directly on the upper branch. Aufs detects the cached inode of the file is still existing and will show you the old (cached) file which is on the lower branch. 
<p class="level1">
<p class="level1">When the file is cached as positive or existed, and a user renamed the file by rename(2) directly. Aufs detects the inode of the file is still existing. You may or may not see both of the old and new files. Todo: If aufs also tests the name, we can detect this case. 
<p class="level0">
<p class="level0">If your outer modification (UDBA) is rare and you can ignore the temporary and minor differences between virtual aufs world and real branch filesystem, then try this mount option. 
<p class="level0">
<p class="level0"><span Class="bold">udba=notify</span> Aufs sets either [oq]fsnotify[cq] or [oq]inotify[cq] to all the accessed directories on its branches and receives the event about the dir and its children. It consumes resources, cpu and memory. And I am afraid that the performance will be hurt, but it is most strict test level. There are some limitations of linux inotify, see also Inotify Limitation. So it is recommended to leave udba default option usually, and set it to notify by remount when you need it. 
<p class="level0">When a user accesses the file which was notified UDBA before, the cached data about the file will be discarded and aufs re-lookup it. So the data will be updated. When an error condition occurs between UDBA and aufs operation, aufs will return an error, including EIO. To use this option, you need to enable CONFIG_INOTIFY and CONFIG_AUFS_HINOTIFY. In linux-2.6.31, CONFIG_FSNOTIFY was introduced and CONFIG_INOTIFY was listed in Documentation/feature-removal-schedule.txt. In aufs2-31 and later (until CONFIG_INOTIFY is removed actually), you can choose either [oq]fsnotify[cq] or [oq]inotify[cq] in configuration. Whichever you choose, specify [oq]udba=notify[cq], and aufs interprets it as an abstract name. 
<p class="level0">To rename/rmdir a directory on a branch directory may reveal the same named directory on the lower branch. Aufs tries re-lookuping the renamed directory and the revealed directory and assigning different inode number to them. But the inode number including their children can be a problem. The inode numbers will be changed silently, and aufs may produce a warning. If you rename a directory repeatedly and reveal/hide the lower directory, then aufs may confuse their inode numbers too. It depends upon the system cache. 
<p class="level0">When you make a directory in aufs and mount other filesystem on it, the directory in aufs cannot be removed expectedly because it is a mount point. But the same named directory on the writable branch can be removed, if someone wants. It is just an empty directory, instead of a mount point. Aufs cannot stop such direct rmdir, but produces a warning about it. 
<p class="level0">If the pseudo-linked file is hardlinked or unlinked on the branch directly, its inode link count in aufs may be incorrect. It is recommended to flush the pseudo-links by auplink script. 
<p class="level0"><a name="Linux"></a><h2 class="nroffsh">Linux Inotify Limitation</h2>
<p class="level0">Unfortunately, current inotify (linux-2.6.18) has some limitations, and aufs must derive it. 
<p class="level0">" .SS IN_ATTRIB, updating atime " When a file/dir on a branch is accessed directly, the inode atime (access " time, cf. stat(2)) may or may not be updated. In some cases, inotify " does not fire this event. So the aufs inode atime may remain old. 
<p class="level0">" .SS IN_ATTRIB, updating nlink " When the link count of a file on a branch is incremented by link(2) " directly, " inotify fires IN_CREATE to the parent " directory, but IN_ATTRIB to the file. So the aufs inode nlink may " remain old. 
<p class="level0"><a name="INDELETE"></a><h2 class="nroffsh">IN_DELETE, removing file on NFS</h2>
<p class="level0">When a file on a NFS branch is deleted directly, inotify may or may not fire IN_DELETE event. It depends upon the status of dentry (DCACHE_NFSFS_RENAMED flag). In this case, the file on aufs seems still exists. Aufs and any user can see the file. 
<p class="level0"><a name="INIGNORED"></a><h2 class="nroffsh">IN_IGNORED, deleted rename target</h2>
<p class="level0">When a file/dir on a branch is unlinked by rename(2) directly, inotify fires IN_IGNORED which means the inode is deleted. Actually, in some cases, the inode survives. For example, the rename target is linked or opened. In this case, inotify watch set by aufs is removed by VFS and inotify. And aufs cannot receive the events anymore. So aufs may show you incorrect data about the file/dir. 
<p class="level0"><a name="Virtual"></a><h2 class="nroffsh">Virtual or Vertical Directory Block (VDIR)</h2>
<p class="level0">In order to provide the merged view of file listing, aufs builds internal directory block on memory. For readdir, aufs performs readdir() internally for each dir on branches, merges their entries with eliminating the whiteout-ed ones, and sets it to the opened file (dir) object. So the file object has its entry list until it is closed. The entry list will be updated when the file position is zero (by rewinddir(3)) and becomes obsoleted. 
<p class="level0">The merged result is cached in the corresponding inode object and maintained by a customizable life-time option. Note: the mount option [oq]rdcache=&lt;sec&gt;[cq] is still under considering and its description is hidden from this manual. 
<p class="level0">Some people may call it can be a security hole or invite DoS attack since the opened and once readdir-ed dir (file object) holds its entry list and becomes a pressure for system memory. But I would say it is similar to files under /proc or /sys. The virtual files in them also holds a memory page (generally) while they are opened. When an idea to reduce memory for them is introduced, it will be applied to aufs too. 
<p class="level0">The dynamically allocated memory block for the name of entries has a unit of *[AUFS_RDBLK_DEF] bytes by default. During building dir blocks, aufs creates hash list (hashed and divided by *[AUFS_RDHASH_DEF] by default) and judging whether the entry is whiteouted by its upper branch or already listed. 
<p class="level0">These values are suitable for normal environments. But you may have millions of files or very long filenames under a single directory. For such cases, you may need to customize these values by specifying rdblk= and rdhash= aufs mount options. 
<p class="level0">For instance, there are 97 files under my /bin, and the total name length is 597 bytes. 
<p class="level0"><pre class="level0">
$ \ls -1 /bin | wc
&nbsp;    97      97     597
</pre>

<p class="level0">
<p class="level0">Strictly speaking, 97 end-of-line codes are included. But it is OK since aufs VDIR also stores the name length in 1 byte. In this case, you do not need to customize the default values. 597 bytes filenames will be stored in 2 VDIR memory blocks (597 &lt; *[AUFS_RDBLK_DEF] x 2). And 97 filenames are distributed among *[AUFS_RDHASH_DEF] lists, so one list will point 4 names in average. To judge the names is whiteouted or not, the number of comparison will be 4. 2 memory allocations and 4 comparison costs low (even if the directory is opened for a long time). So you do not need to customize. 
<p class="level0">If your directory has millions of files, the you will need to specify rdblk= and rdhash=. 
<p class="level0"><pre class="level0">
$ ls -U /mnt/rotating-rust | wc -l
1382438
</pre>

<p class="level0">
<p class="level0">In this case, assuming the average length of filenames is 6, in order to get better time performance I would recommend to set $((128*1024)) or $((64*1024)) for rdblk, and $((8*1024)) or $((4*1024)) for rdhash. You can change these values of the active aufs mount by "mount -o remount". 
<p class="level0">This customization is not for reducing the memory space, but for reducing time for the number of memory allocation and the name comparison. The larger value is faster, in general. Of course, you will need system memory. This is a generic "time-vs-space" problem. 
<p class="level0"><a name="Using"></a><h2 class="nroffsh">Using libau.so</h2>
<p class="level0">There is a dynamic shared object library called libau.so in aufs-util or aufs2-util GIT tree. This library provides several useful functions which wrap the standard library functions such as, 
<p class="level1">
<p class="level1">readdir, readdir_r, closedir 
<p class="level1">pathconf, fpathconf 
<p class="level0">
<p class="level0">To use libau.so, 
<p class="level1">
<p class="level1">install by "make install_ulib" under aufs-util (or aufs2-util) GIT tree 
<p class="level1">set the environment variable "LD_PRELOAD=libau.so", or configure /etc/ld.so.preload 
<p class="level1">set the environment variable "*[LibAuEnv]=all" 
<p class="level1">and run your application. 
<p class="level0">
<p class="level0">If you use pathconf(3)/fpathconf(3) with _PC_LINK_MAX for aufs, you need to use libau.so. 
<p class="level0"><a name="VDIRreaddir3"></a><h2 class="nroffsh">VDIR/readdir(3) in user-space (RDU)</h2>
<p class="level0">If you have a directory which has millions of files, aufs VDIR consumes much memory. You may meet "out of memory" message due to the memory fragmentation or real starvation. In this case, RDU (readdir(3) in user-space) may help you. Because the kernel memory space cannot be swappable and consuming much can be pure memory pressure, while it is not true in user-space. 
<p class="level0">If you enable CONFIG_AUFS_RDU at compiling aufs, install libau.so, and set some environment variables, then you can use RDU. Just simply run your application. The dynamic link library libau.so implements another readdir routine, and all readdir(3) calls in your application will be handled by libau.so. 
<p class="level0">When you call readdir(3), the dynamic linker calls readdir in libau.so. If it finds the passed dir is NOT aufs, it calls the usual readdir(3). It the dir is aufs, then libau.so gets all filenames under the dir by aufs specific ioctl(2)s, instead of regular readdir(3), and merges them by itself. In other words, libau.so moves the memory consumption in kernel-space to user-space. 
<p class="level0">While it is good to stop consuming much memory in kernel-space, sometimes the speed performance may be damaged a little as a side effect. It is just a little, I hope. At the same time, I won[aq]t be surprised if readdir(3) runs faster. 
<p class="level0">It is recommended to specify rdblk=0 when you use this library. 
<p class="level0">If your directory is not so huge and you don[aq]t meet the out of memory situation, probably you don[aq]t need this library. The original VDIR in kernel-space is still alive, and you can live without libau.so. 
<p class="level0"><a name="pathconfPCLINKMAX"></a><h2 class="nroffsh">pathconf(_PC_LINK_MAX)</h2>
<p class="level0">Since some implementation of pathconf(3) (and fpathconf(3)) for _PC_LINK_MAX decides the target filesystem type and returns the pre-defined constant value, when aufs is unknown to the library, it will return the default value (127). Actually the maximum number of the link count in aufs inherits the topmost writable branch filesystem[aq]s. But the standard pathconf(3) will not return the correct value. 
<p class="level0">To support such case, libau.so provides a wrapper for pathconf(3) (and fpathconf(3)). When the parameter is _PC_LINK_MAX, the wrapper checks whether the given parameter refers aufs or not. If it is aufs, then it will get the maximum link count from the topmost writable branch internally. Otherwise, it behaves as normal pathconf(3) transparently. 
<p class="level0"><a name="Note"></a><h2 class="nroffsh">Note</h2>
<p class="level0">Since this is a dynamically linked library, it is unavailable if your application is statically linked. And ld.so(8) ignores LD_PRELOAD when the application is setuid/setgid-ed unless the library is not setuid/setgid-ed. It is a generic rule of dynamically linked library. Additionally the functions in libau.so are unavailable in these cases too. 
<p class="level1">
<p class="level1">the application or library issues getdents(2) instead of readdir(3). 
<p class="level1">the library which calls readdir(3) internally. e.g. scandir(3). 
<p class="level1">the library which calls pathconf(3) internally. 
<p class="level0">
<p class="level0">
<p class="level0"><a name="Copy"></a><h2 class="nroffsh">Copy On Write, or aufs internal copyup and copydown</h2>
<p class="level0">Every stackable filesystem which implements copy-on-write supports the copyup feature. The feature is to copy a file/dir from the lower branch to the upper internally. When you have one readonly branch and one upper writable branch, and you append a string to a file which exists on the readonly branch, then aufs will copy the file from the readonly branch to the writable branch with its directory hierarchy. It means one write(2) involves several logical/internal mkdir(2), creat(2), read(2), write(2) and close(2) systemcalls before the actual expected write(2) is performed. Sometimes it may take a long time, particularly when the file is very large. If CONFIG_AUFS_DEBUG is enabled, aufs produces a message saying `copying a large file.[aq] 
<p class="level0">You may see the message when you change the xino file path or truncate the xino/xib files. Sometimes those files can be large and may take a long time to handle them. 
<p class="level0">" .SS a regular file in HFSPLUS " HFSPLUS acquires an inode mutex lock at closing a file. This behaviour " is not a problem, but aufs doesn[aq]t expect such behaviour and it had " caused a deadlock. So aufs added a special handling to copy-up a " regular file in HFSPLUS, eg. opens the file internally twice. It means " there exists an additional overhead in copying a regular file in HFSPLUS. 
<p class="level0">
<p class="level0"><a name="Policies"></a><h2 class="nroffsh">Policies to Select One among Multiple Writable Branches</h2>
<p class="level0">Aufs has some policies to select one among multiple writable branches when you are going to write/modify something. There are two kinds of policies, one is for newly create something and the other is for internal copy-up. You can select them by specifying mount option [oq]create=CREATE_POLICY[cq] or [oq]cpup=COPYUP_POLICY.[cq] These policies have no meaning when you have only one writable branch. If there is some meaning, it must hurt the performance. 
<p class="level0"><a name="Exceptions"></a><h2 class="nroffsh">Exceptions for Policies</h2>
<p class="level0">In every cases below, even if the policy says that the branch where a new file should be created is /rw2, the file will be created on /rw1. 
<p class="level0">
<p class="level0">If there is a readonly branch with [oq]wh[cq] attribute above the policy-selected branch and the parent dir is marked as opaque, or the target (creating) file is whiteouted on the ro+wh branch, then the policy will be ignored and the target file will be created on the nearest upper writable branch than the ro+wh branch. 
<p class="level1"><pre class="level1">
/aufs = /rw1 + /ro+wh/diropq + /rw2
/aufs = /rw1 + /ro+wh/wh.tgt + /rw2
</pre>

<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">If there is a writable branch above the policy-selected branch and the parent dir is marked as opaque or the target file is whiteouted on the branch, then the policy will be ignored and the target file will be created on the highest one among the upper writable branches who has diropq or whiteout. In case of whiteout, aufs removes it as usual. 
<p class="level1"><pre class="level1">
/aufs = /rw1/diropq + /rw2
/aufs = /rw1/wh.tgt + /rw2
</pre>

<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">link(2) and rename(2) systemcalls are exceptions in every policy. They try selecting the branch where the source exists as possible since copyup a large file will take long time. If it can[aq]t be, ie. the branch where the source exists is readonly, then they will follow the copyup policy. 
<p class="level0">
<p class="level0">There is an exception for rename(2) when the target exists. If the rename target exists, aufs compares the index of the branches where the source and the target are existing and selects the higher one. If the selected branch is readonly, then aufs follows the copyup policy. 
<p class="level0"><a name="Policies"></a><h2 class="nroffsh">Policies for Creating</h2>
<p class="level0">
<p class="level0">
<p class="level0"><span Class="bold">create=tdp | top-down-parent</span> Selects the highest writable branch where the parent dir exists. If the parent dir does not exist on a writable branch, then the internal copyup will happen. The policy for this copyup is always [oq]bottom-up.[cq] This is the default policy. 
<p class="level0">
<p class="level0"><span Class="bold">create=rr | round-robin</span> Selects a writable branch in round robin. When you have two writable branches and creates 10 new files, 5 files will be created for each branch. mkdir(2) systemcall is an exception. When you create 10 new directories, all are created on the same branch. 
<p class="level0">
<p class="level0"><span Class="bold">create=mfs[:second] | most-free-space[:second]</span> Selects a writable branch which has most free space. In order to keep the performance, you can specify the duration ([oq]second[cq]) which makes aufs hold the index of last selected writable branch until the specified seconds expires. The seconds is upto *[AUFS_MFS_MAX_SEC] seconds. The first time you create something in aufs after the specified seconds expired, aufs checks the amount of free space of all writable branches by internal statfs call and the held branch index will be updated. The default value is *[AUFS_MFS_DEF_SEC] seconds. 
<p class="level0">
<p class="level0"><span Class="bold">create=mfsrr:low[:second]</span> Selects a writable branch in most-free-space mode first, and then round-robin mode. If the selected branch has less free space than the specified value [oq]low[cq] in bytes, then aufs re-tries in round-robin mode. Try an arithmetic expansion of shell which is defined by POSIX. For example, $((10 * 1024 * 1024)) for 10M. You can also specify the duration ([oq]second[cq]) which is equivalent to the [oq]mfs[cq] mode. 
<p class="level0">
<p class="level0"><span Class="bold">create=pmfs[:second]</span> Selects a writable branch where the parent dir exists, such as tdp mode. When the parent dir exists on multiple writable branches, aufs selects the one which has most free space, such as mfs mode. 
<p class="level0"><a name="Policies"></a><h2 class="nroffsh">Policies for Copy-Up</h2>
<p class="level0">
<p class="level0">
<p class="level0"><span Class="bold">cpup=tdp | top-down-parent</span> Equivalent to the same named policy for create. This is the default policy. 
<p class="level0">
<p class="level0"><span Class="bold">cpup=bup | bottom-up-parent</span> Selects the writable branch where the parent dir exists and the branch is nearest upper one from the copyup-source. 
<p class="level0">
<p class="level0"><span Class="bold">cpup=bu | bottom-up</span> Selects the nearest upper writable branch from the copyup-source, regardless the existence of the parent dir. 
<p class="level0"><a name="Exporting"></a><h2 class="nroffsh">Exporting Aufs via NFS</h2>
<p class="level0">Aufs is supporting NFS-exporting. Since aufs has no actual block device, you need to add NFS [oq]fsid[cq] option at exporting. Refer to the manual of NFS about the detail of this option. 
<p class="level0">There are some limitations or requirements. 
<p class="level1">
<p class="level1">The branch filesystem must support NFS-exporting. 
<p class="level1">NFSv2 is not supported. When you mount the exported aufs from your NFS client, you will need to some NFS options like v3 or nfsvers=3, especially if it is nfsroot. 
<p class="level1">If the size of the NFS file handle on your branch filesystem is large, aufs will not be able to handle it. The maximum size of NFSv3 file handle for a filesystem is 64 bytes. Aufs uses 24 bytes for 32bit system, plus 12 bytes for 64bit system. The rest is a room for a file handle of a branch filesystem. 
<p class="level1">The External Inode Number Bitmap, Translation Table and Generation Table (xino) is required since NFS file handle is based upon inode number. The mount option [oq]xino[cq] is enabled by default. The external inode generation table and its debugfs entry (&lt;debugfs&gt;/aufs/si_*/xigen) is created when CONFIG_AUFS_EXPORT is enabled even if you don[aq]t export aufs actually. The size of the external inode generation table grows only, never be truncated. You might need to pay attention to the free space of the filesystem where xino files are placed. By default, it is the first writable branch. 
<p class="level1">The branch filesystems must be accessible, which means [oq]not hidden.[cq] It means you need to [oq]mount --move[cq] when you use initramfs and switch_root(8), or chroot(8). 
<p class="level1">Since aufs has several filename prefixes reserved, the maxmum filename length is shorter than ordinary 255. Actually *[AUFS_MAX_NAMELEN] (defined as ${AUFS_MAX_NAMELEN}). This value should be specified as [oq]namlen=[cq] when you mount NFS. The name of the branch top directory has another limit. When you set the module parameter [oq]brs[cq] to 1 (default), then you can see the branch pathname via /sys/fs/aufs/si_XXX/brNNN. Here it is printed with its branch attributes such as [oq]=rw[cq] or [oq]=ro+wh[cq]. Since all the sysfs entries have the size limit of 4096 bytes, the length of the branch path becomes shorter than 4096. Actually you can specify any branch with much longer names, but you will meet some troubles when you remount later because remounting runs the aufs mount helper internally and it tries reading /sys/fs/aufs/si_XXX/brNNN. 
<p class="level0">
<p class="level0">
<p class="level0"><a name="Direct"></a><h2 class="nroffsh">Direct I/O</h2>
<p class="level0">The Direct I/O (including Linux AIO) is a filesystem (and its backend block device) specific feature. And there is a minor problem around the aufs internal copyup. If you have two branches, lower RO ext2 and upper RW tmpfs. As you know ext2 supports Direct I/O, but tmpfs doesn[aq]t. When a [oq]fileA[cq] exists in the lower ext2, and you write something into after opening it with O_DIRECT, then aufs behaves like this if the mount option [oq]dio[cq] is specified. 
<p class="level1">
<p class="level1">The application issues open(O_DIRECT); 
<p class="level1">Aufs opens the file in the lower ext2 and succeeds. 
<p class="level1">The application issues write("something"); 
<p class="level1">Aufs copies-up the file from the lower ext2 to the upper tmpfs, and re-opens the file in tmpfs with O_DIRECT. It fails and returns an error. 
<p class="level0">
<p class="level0">This behaviour may be a problem since application expects the error should be returned from the first open(2) instead of the later write(2), when the filesystem doesn[aq]t support Direct I/O. (But, in real world, I don[aq]t think there is an application which doesn[aq]t check the error from write(2). So it won[aq]t be a big problem actually). 
<p class="level0">If the file exists in the upper tmpfs, the first open(2) will fail expectedly. So there is no problem in this case. But the problem may happen when the internal copyup happens and the behaviour of the branch differs from each other. As long as the feature depends upon the filesystem, this problem will not be solved. So aufs sets `nodio` by default, which means all Direct I/O are disabled, and oepn(2) with O_DIRECT always fails. If you want to use Direct I/O AND all your writeble branches support it, then specify [oq]dio[cq] option to make it in effect. 
<p class="level0">
<p class="level0"><a name="Possible"></a><h2 class="nroffsh">Possible problem of the inode number in TMPFS</h2>
<p class="level0">Although it is rare to happen, TMPFS has a problem about its inode number management. Actually TMPFS does not maintain the inode number at all. Linux kernel has a global 32bit number for general use  of inode number, and TMPFS uses it while most of (real) filesystem maintains its inode number by itself. The global number can wrap around regardless the inode number is still in use. This MAY cause a problem. 
<p class="level0">For instance, when /your/tmpfs/fileA has 10 as its inode number, the same value (10) may be assigned to a newly created file /your/tmpfs/fileB. Some applications do not care the duplicated inode numbers, but others, including AUFS, will be really confused by this situation. 
<p class="level0">If your writable branch FS is TMPFS and the inode number wraps around, aufs will not work correctly. It is recommended to use one of FS on HDD, ramdisk+ext2 or tmpfs+FSimage+loopback mount, as your writable branch FS. 
<p class="level0">
<p class="level0"><a name="Dentry"></a><h2 class="nroffsh">Dentry and Inode Caches</h2>
<p class="level0">If you want to clear caches on your system, there are several tricks for that. If your system ram is low, try [oq]find /large/dir -ls &gt; /dev/null[cq]. It will read many inodes and dentries and cache them. Then old caches will be discarded. But when you have large ram or you do not have such large directory, it is not effective. 
<p class="level0">If you want to discard cache within a certain filesystem, try [oq]mount -o remount /your/mntpnt[cq]. Some filesystem may return an error of EINVAL or something, but VFS discards the unused dentry/inode caches on the specified filesystem. 
<p class="level0"><a name="CompatibleIncompatible"></a><h2 class="nroffsh">Compatible/Incompatible with Unionfs Version 1.x Series</h2>
<p class="level0">
<p class="level0">Ignoring [oq]delete[cq] option, and to keep filesystem consistency, aufs tries writing something to only one branch in a single systemcall. It means aufs may copyup even if the copyup-src branch is specified as writable. For example, you have two writable branches and a large regular file on the lower writable branch. When you issue rename(2) to the file on aufs, aufs may copyup it to the upper writable branch. If this behaviour is not what you want, then you should rename(2) it on the lower branch directly. 
<p class="level0">And there is a simple shell script [oq]unionctl[cq] under sample subdirectory, which is compatible with unionctl(8) in Unionfs Version 1.x series, except --query action. This script executes mount(8) with [oq]remount[cq] option and uses add/del/mod aufs mount options. If you are familiar with Unionfs Version 1.x series and want to use unionctl(8), you can try this script instead of using mount -o remount,... directly. Aufs does not support ioctl(2) interface. This script is highly depending upon mount(8) in util-linux-2.12p package, and you need to mount /proc to use this script. If your mount(8) version differs, you can try modifying this script. It is very easy. The unionctl script is just for a sample usage of aufs remount interface. 
<p class="level0">Aufs uses the external inode number bitmap and translation table by default. 
<p class="level0">The default branch permission for the first branch is [oq]rw[cq], and the rest is [oq]ro.[cq] 
<p class="level0">The whiteout is for hiding files on lower branches. Also it is applied to stop readdir going lower branches. The latter case is called [oq]opaque directory.[cq] Any whiteout is an empty file, it means whiteout is just an mark. In the case of hiding lower files, the name of whiteout is [oq]*[AUFS_WH_PFX]&lt;filename&gt;.[cq] And in the case of stopping readdir, the name is [oq]*[AUFS_WH_PFX]*[AUFS_WH_PFX].opq[cq]. All whiteouts are hardlinked, including [oq]&lt;writable branch top dir&gt;/*[AUFS_WH_BASE].[cq] 
<p class="level0">The hardlink on an ordinary (disk based) filesystem does not consume inode resource newly. But in linux tmpfs, the number of free inodes will be decremented by link(2). It is recommended to specify nr_inodes option to your tmpfs if you meet ENOSPC. Use this option after checking by [oq]df -i.[cq] 
<p class="level0">When you rmdir or rename-to the dir who has a number of whiteouts, aufs rename the dir to the temporary whiteouted-name like [oq]*[AUFS_WH_PFX]*[AUFS_WH_PFX]&lt;dir&gt;.&lt;*[AUFS_WH_TMP_LEN]-digits hex&gt;.[cq] Then remove it after actual operation. cf. mount option [oq]dirwh.[cq] 
<p class="level0"><a name="Incompatible"></a><h2 class="nroffsh">Incompatible with an Ordinary Filesystem</h2>
<p class="level0">stat(2) returns the inode info from the first existence inode among the branches, except the directory link count. Aufs computes the directory link count larger than the exact value usually, in order to keep UNIX filesystem semantics, or in order to shut find(1) mouth up. The size of a directory may be wrong too, but it has to do no harm. The timestamp of a directory will not be updated when a file is created or removed under it, and it was done on a lower branch. 
<p class="level0">The test for permission bits has two cases. One is for a directory, and the other is for a non-directory. In the case of a directory, aufs checks the permission bits of all existing directories. It means you need the correct privilege for the directories including the lower branches. The test for a non-directory is more simple. It checks only the topmost inode. 
<p class="level0">statfs(2) returns the information of the first branch info except namelen when [oq]nosum[cq] is specified (the default). The namelen is decreased by the whiteout prefix length. Although the whiteout prefix is essentially [oq]*[AUFS_WH_PFX][cq], to support rmdir(2) and rename(2) (when the target directory already existed), the namelen is decreased more since the name will be renamed to [oq]*[AUFS_WH_PFX]*[AUFS_WH_PFX]&lt;dir&gt;.&lt;*[AUFS_WH_TMP_LEN]-digits hex&gt;[cq] as previously described. And the block size may differ from st_blksize which is obtained by stat(2). 
<p class="level0">The whiteout prefix (*[AUFS_WH_PFX]) is reserved on all branches. Users should not handle the filename begins with this prefix. In order to future whiteout, the maximum filename length is limited by the longest value - *[AUFS_WH_PFX_LEN] * 2 - 1 - *[AUFS_WH_TMP_LEN] = *[AUFS_MAX_NAMELEN]. It means you cannot handle such long name in aufs, even if it surely exists on the underlying branch fs. The readdir(3)/getdents(2) call show you such name, but the d_type is set to DT_UNKNOWN. It may be a violation of POSIX. 
<p class="level0">Remember, seekdir(3) and telldir(3) are not defined in POSIX. They may not work as you expect. Try rewinddir(3) or re-open the dir. 
<p class="level0">If you dislike the difference between the aufs entries in /etc/mtab and /proc/mounts, and if you are using mount(8) in util-linux package, then try ./mount.aufs utility. Copy the script to /sbin/mount.aufs. This simple utility tries updating /etc/mtab. If you do not care about /etc/mtab, you can ignore this utility. Remember this utility is highly depending upon mount(8) in util-linux-2.12p package, and you need to mount /proc. 
<p class="level0">Since aufs uses its own inode and dentry, your system may cache huge number of inodes and dentries. It can be as twice as all of the files in your union. It means that unmounting or remounting readonly at shutdown time may take a long time, since mount(2) in VFS tries freeing all of the cache on the target filesystem. 
<p class="level0">When you open a directory, aufs will open several directories internally. It means you may reach the limit of the number of file descriptor. And when the lower directory cannot be opened, aufs will close all the opened upper directories and return an error. 
<p class="level0">The sub-mount under the branch of local filesystem is ignored. For example, if you have mount another filesystem on /branch/another/mntpnt, the files under [oq]mntpnt[cq] will be ignored by aufs. It is recommended to mount the sub-mount under the mounted aufs. For example, 
<p class="level0"><pre class="level0">
&#35; sudo mount /dev/sdaXX /ro_branch
&#35; d=another/mntpnt
&#35; sudo mount /dev/sdbXX /ro_branch/$d
&#35; mkdir -p /rw_branch/$d
&#35; sudo mount -t aufs -o br:/rw_branch:/ro_branch none /aufs
&#35; sudo mount -t aufs -o br:/rw_branch/${d}:/ro_branch/${d} none /aufs/another/$d
</pre>

<p class="level0">
<p class="level0">There are several characters which are not allowed to use in a branch directory path and xino filename. See detail in Branch Syntax and Mount Option. 
<p class="level0">The file-lock which means fcntl(2) with F_SETLK, F_SETLKW or F_GETLK, flock(2) and lockf(3), is applied to virtual aufs file only, not to the file on a branch. It means you can break the lock by accessing a branch directly. TODO: check [oq]security[cq] to hook locks, as inotify does. 
<p class="level0">The I/O to the named pipe or local socket are not handled by aufs, even if it exists in aufs. After the reader and the writer established their connection if the pipe/socket are copied-up, they keep using the old one instead of the copied-up one. 
<p class="level0">The fsync(2) and fdatasync(2) systemcalls return 0 which means success, even if the given file descriptor is not opened for writing. I am afraid this behaviour may violate some standards. Checking the behaviour of fsync(2) on ext2, aufs decided to return success. 
<p class="level0">If you want to use disk-quota, you should set it up to your writable branch since aufs does not have its own block device. 
<p class="level0">When your aufs is the root directory of your system, and your system tells you some of the filesystem were not unmounted cleanly, try these procedure when you shutdown your system. <pre class="level0">
&#35; mount -no remount,ro /
&#35; for i in $writable_branches
&#35; do mount -no remount,ro $i
&#35; done
</pre>

<p class="level0">If your xino file is on a hard drive, you also need to specify [oq]noxino[cq] option or [oq]xino=/your/tmpfs/xino[cq] at remounting root directory. 
<p class="level0">To rename(2) directory may return EXDEV even if both of src and tgt are on the same aufs. When the rename-src dir exists on multiple branches and the lower dir has child(ren), aufs has to copyup all his children. It can be recursive copyup. Current aufs does not support such huge copyup operation at one time in kernel space, instead produces a warning and returns EXDEV. Generally, mv(1) detects this error and tries mkdir(2) and rename(2) or copy/unlink recursively. So the result is harmless. If your application which issues rename(2) for a directory does not support EXDEV, it will not work on aufs. Also this specification is applied to the case when the src directory exists on the lower readonly branch and it has child(ren). 
<p class="level0">If a sudden accident such like a power failure happens during aufs is performing, and regular fsck for branch filesystems is completed after the disaster, you need to extra fsck for aufs writable branches. It is necessary to check whether the whiteout remains incorrectly or not, eg. the real filename and the whiteout for it under the same parent directory. If such whiteout remains, aufs cannot handle the file correctly. To check the consistency from the aufs[aq] point of view, you can use a simple shell script called /sbin/auchk. Its purpose is a fsck tool for aufs, and it checks the illegal whiteout, the remained pseudo-links and the remained aufs-temp files. If they are found, the utility reports you and asks whether to delete or not. It is recommended to execute /sbin/auchk for every writable branch filesystem before mounting aufs if the system experienced crash. 
<p class="level0">
<p class="level0"><a name="EXAMPLES"></a><h2 class="nroffsh">EXAMPLES</h2>
<p class="level0">The mount options are interpreted from left to right at remount-time. These examples shows how the options are handled. (assuming /sbin/mount.aufs was installed) 
<p class="level0"><pre class="level0">
&#35; mount -v -t aufs -o br:/day0:/base none /u
none on /u type aufs (rw,xino=/day0/.aufs.xino,br:/day0=rw:/base=ro)
&#35; mount -v -o remount,\
	prepend:/day1,\
	xino=/day1/xino,\
	mod:/day0=ro,\
	del:/day0 \
	/u
none on /u type aufs (rw,xino=/day1/xino,br:/day1=rw:/base=ro)
</pre>

<p class="level0">
<p class="level0"><pre class="level0">
&#35; mount -t aufs -o br:/rw none /u
&#35; mount -o remount,append:/ro /u
different uid/gid/permission, /ro
&#35; mount -o remount,del:/ro /u
&#35; mount -o remount,nowarn_perm,append:/ro /u
&#35;
(there is no warning)
</pre>

<p class="level0">
<p class="level0">
<p class="level0">When you use aufs as root filesystem, it is recommended to consider to exclude some directories. For example, /tmp and /var/log are not need to stack in many cases. They do not usually need to copyup or to whiteout. Also the swapfile on aufs (a regular file, not a block device) is not supported. In order to exclude the specific dir from aufs, try bind mounting. 
<p class="level0">And there is a good sample which is for network booted diskless machines. See sample/ in detail. 
<p class="level0"><a name="DIAGNOSTICS"></a><h2 class="nroffsh">DIAGNOSTICS</h2>
<p class="level0">When you add a branch to your union, aufs may warn you about the privilege or security of the branch, which is the permission bits, owner and group of the top directory of the branch. For example, when your upper writable branch has a world writable top directory, a malicious user can create any files on the writable branch directly, like copyup and modify manually. I am afraid it can be a security issue. 
<p class="level0">When you mount or remount your union without -o ro common mount option and without writable branch, aufs will warn you that the first branch should be writable. 
<p class="level0">
<p class="level0">When you set udba other than notify and change something on your branch filesystem directly, later aufs may detect some mismatches to its cache. If it is a critical mismatch, aufs returns EIO. 
<p class="level0">When an error occurs in aufs, aufs prints the kernel message with [oq]errno.[cq] The priority of the message (log level) is ERR or WARNING which depends upon the message itself. You can convert the [oq]errno[cq] into the error message by perror(3), strerror(3) or something. For example, the [oq]errno[cq] in the message [oq]I/O Error, write failed (-28)[cq] is 28 which means ENOSPC or [oq]No space left on device.[cq] 
<p class="level0">When CONFIG_AUFS_BR_RAMFS is enabled, you can specify ramfs as an aufs branch. Since ramfs is simple, it does not set the maximum link count originally. In aufs, it is very dangerous, particularly for whiteouts. Finally aufs sets the maximum link count for ramfs. The value is 32000 which is borrowed from ext2. 
<p class="level0">After you prepend a branch which already has some entires, aufs may report an I/O Error with "brabra should be negative" or something. For instance, you are going to open(2) a regular file in aufs and write(2) something to it. If you prepend a branch between open(2) and write(2), and the added branch already has a same named entry other than a regular file, then you get a conflict. 
<p class="level1">
<p class="level1">a regular file FOO exists in aufs. 
<p class="level1">open the file FOO. 
<p class="level1">add a branch which has FOO but it is a directory, and change the permssion of the old branch to RO. 
<p class="level1">write to the file FOO. 
<p class="level1">aufs tries copying-up FOO to the upper writable branch which was recently added. 
<p class="level1">aufs finds a directory FOO on the upper branch, and returns an error. 
<p class="level0">In this situation, aufs keeps returning an error during FOO is cached in memory because it remembers that FOO is a regular file instead of a directory. When the system discards the cache about FOO, then you will see the directory FOO. In other words, you will not be able to see the directory FOO on the newly added branch during the file FOO on the lower branch is in use. This situation may invite more complicated issue. If you unlink(2) the opened file FOO, then aufs will create a whiteout on the upper writable branch. And you get another conflict which is coexisting a whiteout and a real entry on the same branch. In this case, aufs also keeps returning an error when you try using FOO. 
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0"><a name="COPYRIGHT"></a><h2 class="nroffsh">COPYRIGHT</h2>
<p class="level0">Copyright &copy; 2005-2011 Junjiro R. Okajima 
<p class="level0"><a name="AUTHOR"></a><h2 class="nroffsh">AUTHOR</h2>
<p class="level0">Junjiro R. Okajima 
<p class="level0">