
<p class="level0">
<p class="level0"><a name="NAME"></a><h2 class="nroffsh">NAME</h2>
<p class="level0">dpkg-maintscript-helper - works around known dpkg limitations in maintainer scripts 
<p class="level0"><a name="SYNOPSIS"></a><h2 class="nroffsh">SYNOPSIS</h2>
<p class="level0"><span Class="bold">dpkg-maintscript-helper</span> <span Class="emphasis">command  [ parameter ...] \fB--\fP  maint-script-parameter ...</span> 
<p class="level0"><a name="COMMANDS"></a><h2 class="nroffsh">COMMANDS AND PARAMETERS</h2>
<p class="level0">
<p class="level0"><span Class="bold">supports</span> <span Class="emphasis">command</span> 
<p class="level0"><span Class="bold">rm_conffile</span> <span Class="emphasis">conffile</span> [<span Class="emphasis">prior-version</span> [<span Class="emphasis">package</span>]] 
<p class="level0"><span Class="bold">mv_conffile</span> <span Class="emphasis">old-conffile</span> <span Class="emphasis">new-conffile</span> [<span Class="emphasis">prior-version</span> [<span Class="emphasis">package</span>]] 
<p class="level0"><span Class="bold">symlink_to_dir</span> <span Class="emphasis">pathname</span> <span Class="emphasis">old-target</span> [<span Class="emphasis">prior-version</span> [<span Class="emphasis">package</span>]] 
<p class="level0"><span Class="bold">dir_to_symlink</span> <span Class="emphasis">pathname</span> <span Class="emphasis">new-target</span> [<span Class="emphasis">prior-version</span> [<span Class="emphasis">package</span>]] 
<p class="level0"><a name="DESCRIPTION"></a><h2 class="nroffsh">DESCRIPTION</h2>
<p class="level0">
<p class="level0">This program is designed to be run within maintainer scripts to achieve some tasks that <span Class="bold">dpkg</span> can't (yet) handle natively either because of design decisions or due to current limitations. 
<p class="level0">Many of those tasks require coordinated actions from several maintainer scripts (<span Class="bold">preinst</span>, <span Class="bold">postinst</span>, <span Class="bold">prerm</span>, <span Class="bold">postrm</span>). To avoid mistakes the same call simply needs to be put in all scripts and the program will automatically adapt its behaviour based on the environment variable <span Class="bold">DPKG_MAINTSCRIPT_NAME</span> and on the maintainer scripts arguments that you have to forward after a double hyphen. 
<p class="level0"><a name="COMMON"></a><h2 class="nroffsh">COMMON PARAMETERS</h2>
<p class="level0">
<p class="level0"><span Class="emphasis">prior-version</span> Defines the latest version of the package whose upgrade should trigger the operation. It is important to calculate <span Class="emphasis">prior-version</span> correctly so that the operations are correctly performed even if the user rebuilt the package with a local version. If <span Class="emphasis">prior-version</span> is empty or omitted, then the operation is tried on every upgrade (note: it's safer to give the version and have the operation tried only once). 
<p class="level0">If the conffile has not been shipped for several versions, and you are now modifying the maintainer scripts to clean up the obsolete file, <span Class="emphasis">prior-version</span> should be based on the version of the package that you are now preparing, not the first version of the package that lacked the conffile. This applies to all other actions in the same way. 
<p class="level0">For example, for a conffile removed in version <span Class="bold">2.0-1</span> of a package, <span Class="emphasis">prior-version</span> should be set to <span Class="bold">2.0-1~</span>. This will cause the conffile to be removed even if the user rebuilt the previous version <span Class="bold">1.0-1</span> as <span Class="bold">1.0-1local1</span>. Or a package switching a path from a symlink (shipped in version <span Class="bold">1.0-1</span>) to a directory (shipped in version <span Class="bold">2.0-1</span>), but only performing the actual switch in the maintainer scripts in version <span Class="bold">3.0-1</span>, should set <span Class="emphasis">prior-version</span> to <span Class="bold">3.0-1~</span>. 
<p class="level0"><span Class="emphasis">package</span> The package name. When the package is "Multi-Arch: same", this parameter must include the architecture qualifier. If empty or omitted, the <span Class="bold">DPKG_MAINTSCRIPT_PACKAGE</span> environment variable (as set by <span Class="bold">dpkg</span>) will be used. 
<p class="level0"><span Class="bold">--</span> All the parameters of the maintainer scripts have to be forwarded to the program after <span Class="bold">--</span>. <a name="CONFFILE"></a><h2 class="nroffsh">CONFFILE RELATED TASKS</h2>
<p class="level0">
<p class="level0">When upgrading a package, <span Class="bold">dpkg</span> will not automatically remove a conffile (a configuration file for which <span Class="bold">dpkg</span> should preserve user changes) if it is not present in the newer version. There are two principal reasons for this; the first is that the conffile could've been dropped by accident and the next version could restore it, users wouldn't want their changes thrown away. The second is to allow packages to transition files from a dpkg-maintained conffile to a file maintained by the package's maintainer scripts, usually with a tool like debconf or ucf. 
<p class="level0">This means that if a package is intended to rename or remove a conffile, it must explicitly do so and <span Class="bold">dpkg-maintscript-helper</span> can be used to implement graceful deletion and moving of conffiles within maintainer scripts. 
<p class="level0"><a name="Removing"></a><h2 class="nroffsh">Removing a conffile</h2>
<p class="level0">
<p class="level0">If a conffile is completely removed, it should be removed from disk, unless the user has modified it. If there are local modifications, they should be preserved. If the package upgrades aborts, the newly obsolete conffile should not disappear. 
<p class="level0">All of this is implemented by putting the following shell snippet in the <span Class="bold">preinst</span>, <span Class="bold">postinst</span> and <span Class="bold">postrm</span> maintainer scripts: 
<p class="level0">&nbsp;   dpkg-maintscript-helper rm_conffile \ &nbsp;       <span Class="emphasis">conffile</span> <span Class="emphasis">prior-version</span> <span Class="emphasis">package</span> -- "$@" 
<p class="level0"><span Class="emphasis">conffile</span> is the filename of the conffile to remove. 
<p class="level0">Current implementation: in the <span Class="bold">preinst</span>, it checks if the conffile was modified and renames it either to <span Class="emphasis">conffile</span><span Class="bold">.dpkg-remove</span> (if not modified) or to <span Class="emphasis">conffile</span><span Class="bold">.dpkg-backup</span> (if modified). In the <span Class="bold">postinst</span>, the latter file is renamed to <span Class="emphasis">conffile</span><span Class="bold">.dpkg-bak</span> and kept for reference as it contains user modifications but the former will be removed. If the package upgrade aborts, the <span Class="bold">postrm</span> reinstalls the original conffile. During purge, the <span Class="bold">postrm</span> will also delete the <span Class="bold">.dpkg-bak</span> file kept up to now. 
<p class="level0"><a name="Renaming"></a><h2 class="nroffsh">Renaming a conffile</h2>
<p class="level0">
<p class="level0">If a conffile is moved from one location to another, you need to make sure you move across any changes the user has made. This may seem a simple change to the <span Class="bold">preinst</span> script at first, however that will result in the user being prompted by <span Class="bold">dpkg</span> to approve the conffile edits even though they are not responsible of them. 
<p class="level0">Graceful renaming can be implemented by putting the following shell snippet in the <span Class="bold">preinst</span>, <span Class="bold">postinst</span> and <span Class="bold">postrm</span> maintainer scripts: 
<p class="level0">&nbsp;   dpkg-maintscript-helper mv_conffile \ &nbsp;       <span Class="emphasis">old-conffile</span> <span Class="emphasis">new-conffile</span> <span Class="emphasis">prior-version</span> <span Class="emphasis">package</span> -- "$@" 
<p class="level0"><span Class="emphasis">old-conffile</span> and <span Class="emphasis">new-conffile</span> are the old and new name of the conffile to rename. 
<p class="level0">Current implementation: the <span Class="bold">preinst</span> checks if the conffile has been modified, if yes it's left on place otherwise it's renamed to <span Class="emphasis">old-conffile</span><span Class="bold">.dpkg-remove</span>. On configuration, the <span Class="bold">postinst</span> removes <span Class="emphasis">old-conffile</span><span Class="bold">.dpkg-remove</span> and renames <span Class="emphasis">old-conffile</span> to <span Class="emphasis">new-conffile</span> if <span Class="emphasis">old-conffile</span> is still available. On abort-upgrade/abort-install, the <span Class="bold">postrm</span> renames <span Class="emphasis">old-conffile</span><span Class="bold">.dpkg-remove</span> back to <span Class="emphasis">old-conffile</span> if required. 
<p class="level0"><a name="SYMLINK"></a><h2 class="nroffsh">SYMLINK AND DIRECTORY SWITCHES</h2>
<p class="level0">
<p class="level0">When upgrading a package, <span Class="bold">dpkg</span> will not automatically switch a symlink to a directory or vice-versa. Downgrades are not supported and the path will be left as is. 
<p class="level0"><a name="Switching"></a><h2 class="nroffsh">Switching a symlink to directory</h2>
<p class="level0">
<p class="level0">If a symlink is switched to a real directory, you need to make sure before unpacking that the symlink is removed. This may seem a simple change to the <span Class="bold">preinst</span> script at first, however that will result in some problems in case of admin local customization of the symlink or when downgrading the package. 
<p class="level0">Graceful renaming can be implemented by putting the following shell snippet in the <span Class="bold">preinst</span>, <span Class="bold">postinst</span> and <span Class="bold">postrm</span> maintainer scripts: 
<p class="level0">&nbsp;   dpkg-maintscript-helper symlink_to_dir \ &nbsp;       <span Class="emphasis">pathname</span> <span Class="emphasis">old-target</span> <span Class="emphasis">prior-version</span> <span Class="emphasis">package</span> -- "$@" 
<p class="level0"><span Class="emphasis">pathname</span> is the absolute name of the old symlink (the path will be a directory at the end of the installation) and <span Class="emphasis">old-target</span> is the target name of the former symlink at <span Class="emphasis">pathname</span>. It can either be absolute or relative to the directory containing <span Class="emphasis">pathname</span>. 
<p class="level0">Current implementation: the <span Class="bold">preinst</span> checks if the symlink exists and points to <span Class="emphasis">old-target</span>, if not then it's left in place, otherwise it's renamed to <span Class="emphasis">pathname</span><span Class="bold">.dpkg-backup</span>. On configuration, the <span Class="bold">postinst</span> removes <span Class="emphasis">pathname</span><span Class="bold">.dpkg-backup</span> if <span Class="emphasis">pathname</span><span Class="bold">.dpkg-backup</span> is still a symlink. On abort-upgrade/abort-install, the <span Class="bold">postrm</span> renames <span Class="emphasis">pathname</span><span Class="bold">.dpkg-backup</span> back to <span Class="emphasis">pathname</span> if required. 
<p class="level0"><a name="Switching"></a><h2 class="nroffsh">Switching a directory to symlink</h2>
<p class="level0">
<p class="level0">If a real directory is switched to a symlink, you need to make sure before unpacking that the directory is removed. This may seem a simple change to the <span Class="bold">preinst</span> script at first, however that will result in some problems in case the directory contains conffiles, pathnames owned by other packages, locally created pathnames, or when downgrading the package. 
<p class="level0">Graceful switching can be implemented by putting the following shell snippet in the <span Class="bold">preinst</span>, <span Class="bold">postinst</span> and <span Class="bold">postrm</span> maintainer scripts: 
<p class="level0">&nbsp;   dpkg-maintscript-helper dir_to_symlink \ &nbsp;       <span Class="emphasis">pathname</span> <span Class="emphasis">new-target</span> <span Class="emphasis">prior-version</span> <span Class="emphasis">package</span> -- "$@" 
<p class="level0"><span Class="emphasis">pathname</span> is the absolute name of the old directory (the path will be a symlink at the end of the installation) and <span Class="emphasis">new-target</span> is the target of the new symlink at <span Class="emphasis">pathname</span>. It can either be absolute or relative to the directory containing <span Class="emphasis">pathname</span>. 
<p class="level0">Current implementation: the <span Class="bold">preinst</span> checks if the directory exists, does not contain conffiles, pathnames owned by other packages, or locally created pathnames, if not then it's left in place, otherwise it's renamed to <span Class="emphasis">pathname</span><span Class="bold">.dpkg-backup</span>, and an empty staging directory named <span Class="emphasis">pathname</span> is created, marked with a file so that dpkg can track it. On configuration, the <span Class="bold">postinst</span> finishes the switch if <span Class="emphasis">pathname</span><span Class="bold">.dpkg-backup</span> is still a directory and <span Class="emphasis">pathname</span> is the staging directory; it removes the staging directory mark file, moves the newly created files inside the staging directory to the symlink target <span Class="emphasis">new-target</span>/, replaces the now empty staging directory <span Class="emphasis">pathname</span> with a symlink to <span Class="emphasis">new-target</span>, and removes <span Class="emphasis">pathname</span><span Class="bold">.dpkg-backup</span>. On abort-upgrade/abort-install, the <span Class="bold">postrm</span> renames <span Class="emphasis">pathname</span><span Class="bold">.dpkg-backup</span> back to <span Class="emphasis">pathname</span> if required. 
<p class="level0"><a name="INTEGRATION"></a><h2 class="nroffsh">INTEGRATION IN PACKAGES</h2>
<p class="level0">
<p class="level0">When using a packaging helper, please check if it has native <span Class="bold">dpkg-maintscript-helper</span> integration, which might make your life easier. See for example <span Class="bold">dh_installdeb</span>(1). 
<p class="level0">Given that <span Class="bold">dpkg-maintscript-helper</span> is used in the <span Class="bold">preinst</span>, using it unconditionally requires a pre-dependency to ensure that the required version of <span Class="bold">dpkg</span> has been unpacked before. The required version depends on the command used, for <span Class="bold">rm_conffile</span> and <span Class="bold">mv_conffile</span> it is 1.15.7.2, for <span Class="bold">symlink_to_dir</span> and <span Class="bold">dir_to_symlink</span> it is 1.17.14: 
<p class="level0">&nbsp;   <span Class="bold">Pre-Depends:</span> dpkg (&gt;= 1.17.14) 
<p class="level0">But in many cases the operation done by the program is not critical for the package, and instead of using a pre-dependency we can call the program only if we know that the required command is supported by the currently installed <span Class="bold">dpkg</span>: 
<p class="level0">&nbsp;   if dpkg-maintscript-helper supports <span Class="emphasis">command</span>; then &nbsp;       dpkg-maintscript-helper <span Class="emphasis">command</span> ... &nbsp;   fi 
<p class="level0">The command <span Class="bold">supports</span> will return 0 on success, 1 otherwise. The <span Class="bold">supports</span> command will check if the environment variables as set by dpkg and required by the script are present, and will consider it a failure in case the environment is not sufficient. <a name="SEE"></a><h2 class="nroffsh">SEE ALSO</h2>
<p class="level0">
<p class="level0">
<p class="level0"><span Class="manpage">dh_installdeb (1).</span>