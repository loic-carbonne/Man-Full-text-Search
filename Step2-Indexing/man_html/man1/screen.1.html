
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0"><a name="NAME"></a><h2 class="nroffsh">NAME</h2>
<p class="level0">screen - screen manager with VT100/ANSI terminal emulation 
<p class="level0">
<p class="level0"><a name="SYNOPSIS"></a><h2 class="nroffsh">SYNOPSIS</h2>
<p class="level0"><span Class="bold">screen</span> [ <span Class="bold">-options</span> ] [ <span Class="bold">cmd</span> [ <span Class="bold">args</span> ] ] <br><span Class="bold">screen -r</span> [[<span Class="emphasis">pid</span><a class="bold" href="#">.</a>]<span Class="emphasis">tty</span>[<a class="bold" href="#">.</a><span Class="emphasis">host</span>]] <br><span Class="bold">screen -r</span> <span Class="emphasis">sessionowner</span><a class="bold" href="#">/</a>[[<span Class="emphasis">pid</span><a class="bold" href="#">.</a>]<span Class="emphasis">tty</span>[<a class="bold" href="#">.</a><span Class="emphasis">host</span>]] 
<p class="level0">
<p class="level0">
<p class="level0"><a name="DESCRIPTION"></a><h2 class="nroffsh">DESCRIPTION</h2>
<p class="level0"><span Class="emphasis">Screen</span> is a full-screen window manager that multiplexes a physical terminal between several processes (typically interactive shells). Each virtual terminal provides the functions of a DEC VT100 terminal and, in addition, several control functions from the ISO 6429 (ECMA 48, ANSI X3.64) and ISO 2022 standards (e.|g. insert/delete line and support for multiple character sets). There is a scrollback history buffer for each virtual terminal and a copy-and-paste mechanism that allows moving text regions between windows. 
<p class="level0">When <span Class="emphasis">screen</span> is called, it creates a single window with a shell in it (or the specified command) and then gets out of your way so that you can use the program as you normally would. Then, at any time, you can create new (full-screen) windows with other programs in them (including more shells), kill existing windows, view a list of windows, turn output logging on and off, copy-and-paste text between windows, view the scrollback history, switch between windows in whatever manner you wish, etc. All windows run their programs completely independent of each other. Programs continue to run when their window is currently not visible and even when the whole  <span Class="emphasis">screen </span> session is detached from the user's terminal.  When a program terminates, <span Class="emphasis">screen</span> (per default) kills the window that contained it. If this window was in the foreground, the display switches to the previous window; if none are left, <span Class="emphasis">screen</span> exits. Shells usually distinguish between running as login-shell or sub-shell. Screen runs them as sub-shells, unless told otherwise (See *Qshell*U .screenrc command). 
<p class="level0">Everything you type is sent to the program running in the current window. The only exception to this is the one keystroke that is used to initiate a command to the window manager. By default, each command begins with a control-a (abbreviated C-a from now on), and is followed by one other keystroke. The command character and all the key bindings can be fully customized to be anything you like, though they are always two characters in length. 
<p class="level0"><span Class="emphasis">Screen</span> does not understand the prefix *QC-*U to mean control, although this notation is  used in this manual for readability.  Please use the caret notation (*Q^A*U instead of *QC-a*U) as arguments to e.g. the  <span Class="emphasis">escape</span> command or the <span Class="emphasis">-e</span> option. <span Class="emphasis">Screen</span> will also print out control characters in caret notation. 
<p class="level0">The standard way to create a new window is to type *QC-a c*U. This creates a new window running a shell and switches to that window immediately, regardless of the state of the process running in the current window. Similarly, you can create a new window with a custom command in it by first binding the command to a keystroke (in your .screenrc file or at the *QC-a :*U command line) and then using it just like the *QC-a c*U command. In addition, new windows can be created by running a command like: 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">screen emacs prog.c 
<p class="level1">from a shell prompt within a previously created window. This will not run another copy of <span Class="emphasis">screen ,</span> but will instead supply the command name and its arguments to the window manager (specified in the $STY environment variable) who will use it to create the new window. The above example would start the emacs editor (editing prog.c) and switch to its window. - Note that you cannot transport environment variables from the invoking shell to the application (emacs in this case), because it is forked from the parent screen process, not from the invoking shell. 
<p class="level1">If *Q/var/run/utmp*U is writable by <span Class="emphasis">screen ,</span> an appropriate record will be written to this file for each window, and removed when the window is terminated. This is useful for working with *Qtalk*U, *Qscript*U, *Qshutdown*U, *Qrsend*U, *Qsccs*U and other similar programs that use the utmp file to determine who you are. As long as <span Class="emphasis">screen</span> is active on your terminal, the terminal's own record is removed from the utmp file. See also *QC-a L*U. 
<p class="level1">
<p class="level1"><a name="GETTING"></a><h2 class="nroffsh">GETTING STARTED</h2>
<p class="level0">Before you begin to use <span Class="emphasis">screen</span> you'll need to make sure you have correctly selected your terminal type, just as you would for any other termcap/terminfo program. (You can do this by using <span Class="emphasis">tset</span> for example.) 
<p class="level0">If you're impatient and want to get started without doing a lot more reading, you should remember this one command:  *QC-a ?*U. Typing these two characters will display a list of the available <span Class="emphasis">screen</span> commands and their bindings. Each keystroke is discussed in the section *QDEFAULT KEY BINDINGS*U. The manual section *QCUSTOMIZATION*U deals with the contents of your .screenrc. 
<p class="level0">If your terminal is a *Qtrue*U auto-margin terminal (it doesn't allow the last position on the screen to be updated without scrolling the screen) consider using a version of your terminal's termcap that has automatic margins turned <span Class="emphasis">off</span>. This will ensure an accurate and optimal update of the screen in all circumstances. Most terminals nowadays have *Qmagic*U margins (automatic margins plus usable last column). This is the VT100 style type and perfectly suited for <span Class="emphasis">screen .</span> If all you've got is a *Qtrue*U auto-margin terminal  <span Class="emphasis">screen</span> will be content to use it, but updating a character put into the last position on the screen may not be possible until the screen scrolls or the character is moved into a safe position in some other way. This delay can be shortened by using a terminal with insert-character capability. 
<p class="level0">
<p class="level0"><a name="COMMAND-LINE"></a><h2 class="nroffsh">COMMAND-LINE OPTIONS</h2>
<p class="level0">Screen has the following command-line options: 
<p class="level0"><span Class="bold">-a</span> include <span Class="emphasis">all</span> capabilities (with some minor exceptions) in each window's termcap, even if <span Class="emphasis">screen</span> must redraw parts of the display in order to implement a function. 
<p class="level0"><span Class="bold">-A</span> Adapt the sizes of all windows to the size of the current terminal. By default, <span Class="emphasis">screen</span> tries to restore its old window sizes when attaching to resizable terminals (those with *QWS*U in its description, e.g. suncmd or some xterm). 
<p class="level0"><span Class="bold">-c  file</span> override the default configuration file from *Q$HOME/.screenrc*U to <span Class="emphasis">file</span>. 
<p class="level0"><span Class="manpage">-d | -D  [ \fIpid.tty.host ]</span>does not start <span Class="emphasis">screen ,</span> but detaches the elsewhere running <span Class="emphasis">screen</span> session. It has the same effect as typing *QC-a d*U from <span Class="emphasis">screen 's</span> controlling terminal. <span Class="bold">-D</span> is the equivalent to the power detach key. If no session can be detached, this option is ignored. In combination with the <span Class="bold">-r</span>/<span Class="bold">-R</span> option more powerful effects can be achieved: 
<p class="level0"><span Class="bold">-d -r</span> Reattach a session and if necessary detach it first. 
<p class="level0"><span Class="bold">-d -R</span> Reattach a session and if necessary detach or even create it first. 
<p class="level0"><span Class="bold">-d -RR</span> Reattach a session and if necessary detach or create it. Use the first session if more than one session is available. 
<p class="level0"><span Class="bold">-D -r</span> Reattach a session. If necessary detach and logout remotely first. 
<p class="level0"><span Class="bold">-D -R</span> Attach here and now. In detail this means: If a session is running, then reattach. If necessary detach and logout remotely first. If it was not running create it and notify the user. This is the author's favorite. 
<p class="level0"><span Class="bold">-D -RR</span> Attach here and now. Whatever that means, just do it. 
<p class="level0"><a name=""></a><span class="nroffip"> 5</span> 
<p class="level1">Note: It is always a good idea to check the status of your sessions by means of *Qscreen -list*U. 
<p class="level1"><span Class="bold">-e  xy</span> specifies the command character to be <span Class="emphasis">x</span> and the character generating a literal command character to <a class="emphasis" href="#y">y</a> (when typed after the command character). The default is *QC-a*U and `a', which can be specified as *Q-e^Aa*U. When creating a <span Class="emphasis">screen</span> session, this option sets the default command character. In a multiuser session all users added will start off with this command character. But when attaching to an already running session, this option changes only the command character of the attaching user. This option is equivalent to either the commands *Qdefescape*U or *Qescape*U respectively. 
<p class="level1"><span Class="manpage">-f\fP</span>, <span Class="manpage">-fn</span>, <span Class="manpage">and  -fa</span>turns flow-control on, off, or *Qautomatic switching mode*U. This can also be defined through the *Qdefflow*U .screenrc command. 
<p class="level1"><span Class="bold">-h  num</span> Specifies the history scrollback buffer to be <span Class="emphasis">num</span> lines high. 
<p class="level1"><span Class="bold">-i</span> will cause the interrupt key (usually C-c) to interrupt the display immediately when flow-control is on. See the *Qdefflow*U .screenrc command for details. The use of this option is discouraged. 
<p class="level1"><span Class="manpage">-l  and  -ln</span>turns login mode on or off (for /var/run/utmp updating). This can also be defined through the *Qdeflogin*U .screenrc command. 
<p class="level1"><span Class="manpage">-ls  [ \fImatch ]</span>
<p class="level1">
<p class="level1"><span Class="manpage">-list  [ \fImatch ]</span>
<p class="level1">does not start <span Class="emphasis">screen ,</span> but prints a list of <span Class="emphasis">pid.tty.host</span> strings and creation timestamps identifying your <span Class="emphasis">screen</span> sessions. Sessions marked `detached' can be resumed with *Qscreen -r*U. Those marked `attached' are running and have a controlling terminal. If the session runs in  multiuser mode, it is marked `multi'. Sessions marked as `unreachable' either live on a different host or are `dead'. An unreachable session is considered dead, when its name matches either the name of the local host, or the specified parameter, if any. See the <span Class="bold">-r</span> flag for a description how to construct matches. Sessions marked as `dead' should be thoroughly checked and removed.  Ask your system administrator if you are not sure. Remove sessions with the  <span Class="bold">-wipe</span> option.  
<p class="level1"><span Class="bold">-L</span> tells <span Class="emphasis">screen</span> to turn on automatic output logging for the windows. 
<p class="level1"><span Class="bold">-m</span> causes <span Class="emphasis">screen</span> to ignore the $STY environment variable. With *Qscreen -m*U creation of a new session is enforced, regardless whether <span Class="emphasis">screen</span> is called from within another <span Class="emphasis">screen</span> session or not. This flag has a special meaning in connection with the `-d' option: 
<p class="level1"><span Class="bold">-d -m</span> Start <span Class="emphasis">screen</span> in *Qdetached*U mode. This creates a new session but doesn't attach to it. This is useful for system startup scripts. 
<p class="level1"><span Class="bold">-D -m</span> This also starts screen in *Qdetached*U mode, but doesn't fork a new process. The command exits if the session terminates. 
<p class="level1"><span Class="bold">-O</span> selects a more optimal output mode for your terminal rather than true VT100 emulation (only affects auto-margin terminals without `LP'). This can also be set in your .screenrc by specifying `OP' in a *Qtermcap*U command. 
<p class="level1"><span Class="bold">-p  number_or_name|-|=|+</span> Preselect a window. This is useful when you want to reattach to a specific window or you want to send a command via the *Q-X*U option to a specific window. As with screen's select command, *Q-*U selects the blank window. As a special case for reattach, *Q=*U brings up the windowlist on the blank window, while a *Q+*U will create a new window. The command will not be executed if the specified window could not be found. 
<p class="level1"><span Class="bold">-q</span> Suppress printing of error messages. In combination with *Q-ls*U the exit  value is as follows: 9 indicates a directory without sessions. 10  indicates a directory with running but not attachable sessions. 11 (or more)  indicates 1 (or more) usable sessions. In combination with *Q-r*U the exit value is as follows: 10 indicates that  there is no session to resume. 12 (or more) indicates that there are 2 (or  more) sessions to resume and you should specify which one to choose.  In all other cases *Q-q*U has no effect. 
<p class="level1"><span Class="bold">-Q</span> Some commands now can be queried from a remote session using this flag, e.g. *Qscreen -Q windows*U. The commands will send the response to the stdout of the querying process. If there was an error in the command, then the querying process will exit with a non-zero status. 
<p class="level1">The commands that can be queried now are: &nbsp;<span Class="bold">echo</span> &nbsp;<span Class="bold">info</span> &nbsp;<span Class="bold">lastmsg</span> &nbsp;<span Class="bold">number</span> &nbsp;<span Class="bold">select</span> &nbsp;<span Class="bold">time</span> &nbsp;<span Class="bold">title</span> &nbsp;<span Class="bold">windows</span> 
<p class="level1"><span Class="manpage">-r  [ \fIpid.tty.host ]</span>
<p class="level1">
<p class="level1"><span Class="manpage">-r  \fIsessionowner/[ \fIpid.tty.host ]</span>
<p class="level1">resumes a detached <span Class="emphasis">screen</span> session.  No other options (except combinations with <span Class="bold">-d</span>/<span Class="bold">-D</span>) may be specified, though an optional prefix of [<span Class="emphasis">pid.</span>]<span Class="emphasis">tty.host</span> may be needed to distinguish between multiple detached <span Class="emphasis">screen</span> sessions.  The second form is used to connect to another user's screen session which runs in multiuser mode. This indicates that screen should look for sessions in another user's directory. This requires setuid-root. 
<p class="level1"><span Class="bold">-R</span> attempts to resume the youngest (in terms of creation time) detached <span Class="emphasis">screen</span> session it finds.  If successful, all other command-line options are ignored. If no detached session exists, starts a new session using the specified options, just as if <span Class="bold">-R</span> had not been specified. The option is set by default if <span Class="emphasis">screen</span> is run as a login-shell (actually screen uses *Q-xRR*U in that case). For combinations with the <span Class="bold">-d</span>/<span Class="bold">-D</span> option see there. <span Class="bold">Note:</span> Time-based session selection is a Debian addition. 
<p class="level1"><span Class="bold">-s  program </span> sets the default shell to the program specified, instead of the value in the environment variable $SHELL (or *Q/bin/sh*U if not defined). This can also be defined through the *Qshell*U .screenrc command. See also there. 
<p class="level1"><span Class="bold">-S  sessionname</span> When creating a new session, this option can be used to specify a meaningful name for the session. This name identifies the session for *Qscreen -list*U and *Qscreen -r*U actions. It substitutes the default [<span Class="emphasis">tty.host</span>] suffix. 
<p class="level1"><span Class="bold">-t  name</span> sets the title (a.|k.|a.) for the default shell or specified program. See also the *Qshelltitle*U .screenrc command. 
<p class="level1"><span Class="bold">-T  term</span> Set the $TERM environment varible using the spcified term as opposed to the defualt setting of <span Class="bold">screen</span>. 
<p class="level1"><span Class="bold">-U</span> Run screen in UTF-8 mode. This option tells screen that your terminal sends and understands UTF-8 encoded characters. It also sets the default encoding for new windows to `utf8'. 
<p class="level1"><span Class="bold">-v</span> Print version number. 
<p class="level1"><span Class="manpage">-wipe  [ \fImatch ]</span>does the same as *Qscreen -ls*U, but removes destroyed sessions instead of marking them as `dead'. An unreachable session is considered dead, when its name matches either  the name of the local host, or the explicitly given parameter, if any. See the <span Class="bold">-r</span> flag for a description how to construct matches. 
<p class="level1"><span Class="bold">-x</span> Attach to a not detached <span Class="emphasis">screen</span> session. (Multi display mode). <span Class="emphasis">Screen</span> refuses to attach from within itself.  But when cascading multiple screens, loops are not detected; take care. 
<p class="level1"><span Class="bold">-X</span> Send the specified command to a running screen session. You may use the <span Class="bold">-S</span> option to specify the screen session if you have several screen sessions running. You can use the <span Class="bold">-d</span> or <span Class="bold">-r</span> option to tell screen to look only for attached or detached screen sessions. Note that this command doesn't work if the session is password protected. 
<p class="level1"><span Class="bold">-4</span> Resolve hostnames only to IPv4 addresses. 
<p class="level1"><span Class="bold">-6</span> Resolve hostnames only to IPv6 addresses. 
<p class="level1"><a name="DEFAULT"></a><h2 class="nroffsh">DEFAULT KEY BINDINGS</h2>
<p class="level0">
<p class="level0">As mentioned, each <span Class="emphasis">screen</span> command consists of a *QC-a*U followed by one other character. For your convenience, all commands that are bound to lower-case letters are also bound to their control character counterparts (with the exception of *QC-a a*U; see below), thus, *QC-a c*U as well as *QC-a C-c*U can be used to create a window. See section *QCUSTOMIZATION*U for a description of the command. 
<p class="level0">
<p class="level0">The following table shows the default key bindings: 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a '\fP	(select)</span> 
<p class="level1">Prompt for a window name or number to switch to. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a \fP	(windowlist -b)</span> 
<p class="level1">Present a list of all windows for selection. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a 0\fP	(select 0)</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fB"></a><span class="nroffip">\fB … \fP	   …</span> 
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a 9\fP	(select 9)</span> 
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a -\fP	(select -)</span> 
<p class="level1">
<p class="level1">Switch to window number 0 - 9, or to the blank window. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a tab\fP	(focus)</span> 
<p class="level1">
<p class="level1">Switch the input focus to the next region. See also <span Class="emphasis">split, remove, only</span>. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-a\fP	(other)</span> 
<p class="level1">Toggle to the window displayed previously. Note that this binding defaults to the command character typed twice, unless overridden.  For instance, if you use the option *Q<span Class="bold">-e]x</span>*U, this command becomes *Q]]*U. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a a\fP	(meta)</span> 
<p class="level1">Send the command character (C-a) to window. See <span Class="emphasis">escape</span> command. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a A\fP	(title)</span> 
<p class="level1">Allow the user to enter a name for the current window. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a b\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-b\fP	(break)</span> 
<p class="level1">
<p class="level1">Send a break to window. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a B\fP	(pow_break)</span> 
<p class="level1">Reopen the terminal line and send a break. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a c\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-c\fP	(screen)</span> 
<p class="level1">
<p class="level1">Create a new window with a shell and switch to that window. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C\fP	(clear)</span> 
<p class="level1">Clear the screen. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a d\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-d\fP	(detach)</span> 
<p class="level1">
<p class="level1">Detach <span Class="emphasis">screen</span> from this terminal. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a D D\fP	(pow_detach)</span> 
<p class="level1">Detach and logout. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a f\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-f\fP	(flow)</span> 
<p class="level1">
<p class="level1">Toggle flow <span Class="emphasis">on</span>, <span Class="emphasis">off</span> or <span Class="emphasis">auto</span>. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a F\fP	(fit)</span> 
<p class="level1">Resize the window to the current region size. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-g\fP	(vbell)</span> 
<p class="level1">Toggles <span Class="emphasis">screen's</span> visual bell mode. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a h\fP	(hardcopy)</span> 
<p class="level1">
<p class="level1">Write a hardcopy of the current window to the file *Qhardcopy.<a class="emphasis" href="#n">n</a>*U. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a H\fP	(log)</span> 
<p class="level1">Begins/ends logging of the current window to the file *Qscreenlog.<a class="emphasis" href="#n">n</a>*U. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a i\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-i\fP	(info)</span> 
<p class="level1">
<p class="level1">Show info about this window. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a k\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-k\fP	(kill)</span> 
<p class="level1">
<p class="level1">Destroy current window. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a l\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-l\fP	(redisplay)</span> 
<p class="level1">
<p class="level1">Fully refresh current window. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a L\fP	(login)</span> 
<p class="level1">Toggle this windows login slot. Available only if <span Class="emphasis">screen</span> is configured to update the utmp database. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a m\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-m\fP	(lastmsg)</span> 
<p class="level1">
<p class="level1">Repeat the last message displayed in the message line. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a M\fP	(monitor)</span> 
<p class="level1">Toggles monitoring of the current window. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a space\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a n\fP</span> 
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-n\fP	(next)</span> 
<p class="level1">
<p class="level1">Switch to the next window. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a N\fP	(number)</span> 
<p class="level1">Show the number (and title) of the current window. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a backspace\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-h\fP</span> 
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a p\fP</span> 
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-p\fP	(prev)</span> 
<p class="level1">
<p class="level1">Switch to the previous window (opposite of <span Class="bold">C-a n</span>). 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a q\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-q\fP	(xon)</span> 
<p class="level1">
<p class="level1">Send a control-q to the current window. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a Q\fP	(only)</span> 
<p class="level1">Delete all regions but the current one. See also <span Class="emphasis">split, remove, focus</span>. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a r\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-r\fP	(wrap)</span> 
<p class="level1">
<p class="level1">Toggle the current window's line-wrap setting (turn the current window's automatic margins on and off). 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a s\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-s\fP	(xoff)</span> 
<p class="level1">
<p class="level1">Send a control-s to the current window. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a S\fP	(split)</span> 
<p class="level1">Split the current region horizontally into two new ones. See also <span Class="emphasis">only, remove, focus</span>. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a t\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-t\fP	(time)</span> 
<p class="level1">
<p class="level1">Show system information. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a v\fP	(version)</span> 
<p class="level1">
<p class="level1">Display the version and compilation date. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-v\fP	(digraph)</span> 
<p class="level1">
<p class="level1">Enter digraph. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a w\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-w\fP	(windows)</span> 
<p class="level1">
<p class="level1">Show a list of window. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a W\fP	(width)</span> 
<p class="level1">Toggle 80/132 columns. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a x\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-x\fP	(lockscreen)</span> 
<p class="level1">
<p class="level1">Lock this terminal. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a X\fP 	(remove)</span> 
<p class="level1">Kill the current region. See also <span Class="emphasis">split, only, focus</span>. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a z\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-z\fP	(suspend)</span> 
<p class="level1">
<p class="level1">Suspend <span Class="emphasis">screen .</span> Your system must support BSD-style job-control. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a Z\fP	(reset)</span> 
<p class="level1">Reset the virtual terminal to its *Qpower-on*U values. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a .\fP	(dumptermcap)</span> 
<p class="level1">Write out a *Q.termcap*U file. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a ?\fP	(help)</span> 
<p class="level1">Show key bindings. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a \e\fP	(quit)</span> 
<p class="level1">Kill all windows and terminate <span Class="emphasis">screen .</span> 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a :\fP	(colon)</span> 
<p class="level1">Enter command line mode. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a [\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-[\fP</span> 
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a esc\fP	(copy)</span> 
<p class="level1">
<p class="level1">Enter copy/scrollback mode. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a C-]\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a ]\fP	(paste .)</span> 
<p class="level1">
<p class="level1">Write the contents of the paste buffer to the stdin queue of the current window.  
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a {\fP</span> 
<p class="level1">
<p class="level1">
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a }\fP	(history)</span> 
<p class="level1">
<p class="level1">Copy and paste a previous (command) line. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a &gt;\fP	(writebuf)</span> 
<p class="level1">Write paste buffer to a file. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a &lt;\fP	(readbuf)</span> 
<p class="level1">Reads the screen-exchange file into the paste buffer. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a =\fP	(removebuf)</span> 
<p class="level1">Removes the file used by <span Class="bold">C-a &lt;</span> and </span>C-a &gt;</span>. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a ,\fP	(license)</span> 
<p class="level1">Shows where <span Class="emphasis">screen</span> comes from, where it went to and why you can use it. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a _\fP	(silence)</span> 
<p class="level1">Start/stop monitoring the current window for inactivity. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a |\fP	(split -v)</span> 
<p class="level1">Split the current region vertically into two new ones. 
<p class="level0"><a name="fBC-a"></a><span class="nroffip">\fBC-a *\fP	(displays)</span> 
<p class="level1">Show a listing of all currently attached displays. 
<p class="level1">
<p class="level1"><a name="CUSTOMIZATION"></a><h2 class="nroffsh">CUSTOMIZATION</h2>
<p class="level0">The *Qsocket directory*U defaults either to $HOME/.screen or simply to /tmp/screens or preferably to /var/run/screen chosen at compile-time. If <span Class="emphasis">screen</span> is installed setuid-root, then the administrator should compile <span Class="emphasis">screen</span> with an adequate (not NFS mounted) socket directory. If <span Class="emphasis">screen</span> is not running setuid-root, the user can specify any mode 700 directory in the environment variable $SCREENDIR. 
<p class="level0">When <span Class="emphasis">screen</span> is invoked, it executes initialization commands from the files *Q/etc/screenrc*U and *Q.screenrc*U in the user's home directory. These are the *Qprogrammer's defaults*U that can be overridden in the following ways: for the global screenrc file  <span Class="emphasis">screen</span> searches for the environment variable $SYSSCREENRC (this override feature may be disabled at compile-time). The user specific screenrc file is searched in $SCREENRC, then $HOME/.screenrc. The command line option <span Class="bold">-c</span> takes precedence over the above user screenrc files. 
<p class="level0">Commands in these files are used to set options, bind functions to keys, and to automatically establish one or more windows at the beginning of your <span Class="emphasis">screen</span> session. Commands are listed one per line, with empty lines being ignored. A command's arguments are separated by tabs or spaces, and may be surrounded by single or double quotes. A `&#35;' turns the rest of the line into a comment, except in quotes. Unintelligible lines are warned about and ignored. Commands may contain references to environment variables. The  syntax is the shell-like "$VAR " or "${VAR}". Note that this causes  incompatibility with previous  <span Class="emphasis">screen</span> versions, as now the '$'-character has to be protected with 'e' if no variable substitution shall be performed. A string in single-quotes is also protected from variable substitution. 
<p class="level0">Two configuration files are shipped as examples with your screen distribution: *Qetc/screenrc*U and *Qetc/etcscreenrc*U. They contain a number of useful examples for various commands. 
<p class="level0">Customization can also be done 'on-line'. To enter the command mode type `C-a :'. Note that commands starting with *Qdef*U change default values, while others change current settings. 
<p class="level0">The following commands are available: 
<p class="level0">
<p class="level0"><span Class="bold">acladd  usernames</span> 
<p class="level0"><br><span Class="bold">addacl  usernames</span> 
<p class="level0">Enable users to fully access this screen session. <span Class="emphasis">Usernames</span> can be one user or a comma separated list of users. This command enables to attach to the <span Class="emphasis">screen</span> session and performs the equivalent of `aclchg <span Class="emphasis">usernames</span> +rwx "&#35;?"'. executed. To add a user with restricted access, use the `aclchg' command below. If an optional second parameter is supplied, it should be a crypted password for the named user(s). `Addacl' is a synonym to `acladd'. Multi user mode only. 
<p class="level0">
<p class="level0"><span Class="bold">aclchg  usernames permbits list</span> <br><span Class="bold">chacl  usernames permbits list</span> 
<p class="level0">Change permissions for a comma separated list of users. Permission bits are represented as `r', `w' and `x'. Prefixing `+' grants the permission, `-' removes it. The third parameter is a comma separated list of commands and/or windows (specified either by number or title). The special list `&#35;' refers to  all windows, `?' to all commands. if <span Class="emphasis">usernames</span> consists of a single `*', all known users are affected. A command can be executed when the user has the `x' bit for it. The user can type input to a window when he has its `w' bit set and no other user obtains a writelock for this window.  Other bits are currently ignored.   To withdraw the writelock from another user in window 2: `aclchg <span Class="emphasis">username</span> -w+w 2'. To allow read-only access to the session: `aclchg <span Class="emphasis">username</span> -w "&#35;"'. As soon as a user's name is known to <span Class="emphasis">screen </span> he can attach to the session and (per default) has full permissions for all  command and windows. Execution permission for the acl commands, `at' and others should also be removed or the user may be able to regain write permission. Rights of the special username <span Class="bold">nobody</span> cannot be changed (see the *Qsu*U command). `Chacl' is a synonym to `aclchg'. Multi user mode only. 
<p class="level0">
<p class="level0"><span Class="bold">acldel  username</span> 
<p class="level0">Remove a user from <span Class="emphasis">screen 's</span> access control list. If currently attached, all the user's displays are detached from the session. He cannot attach again. Multi user mode only. 
<p class="level0">
<p class="level0"><span Class="bold">aclgrp  username</span> 
<p class="level0">
<p class="level0">Creates groups of users that share common access rights. The name of the  group is the username of the group leader. Each member of the group inherits the permissions that are granted to the group leader. That means, if a user fails an access check, another check is made for the group leader. A user is removed from all groups the special value *Qnone*U is used for <span Class="emphasis">groupname .</span> If the second parameter is omitted all groups the user is in are listed. 
<p class="level0">
<p class="level0"><span Class="bold">aclumask</span> 
<p class="level0">
<p class="level0"><br><span Class="bold">umask</span> 
<p class="level0">
<p class="level0">
<p class="level0">This specifies the access other users have to windows that will be created by the caller of the command. <span Class="emphasis">Users</span> may be no, one or a comma separated list of known usernames. If no users are specified, a list of all currently known users is assumed.  <span Class="emphasis">Bits</span> is any combination of access control bits allowed defined with the  *Qaclchg*U command. The special username *Q?*U predefines the access that not yet known users will be granted to any window initially. The special username *Q??*U predefines the access that not yet known  users are granted to any command.  Rights of the special username <span Class="bold">nobody</span> cannot be changed (see the *Qsu*U command). `Umask' is a synonym to `aclumask'. 
<p class="level0">
<p class="level0"><span Class="bold">activity  message</span> 
<p class="level0">When any activity occurs in a background window that is being monitored, <span Class="emphasis">screen</span> displays a notification in the message line. The notification message can be re-defined by means of the *Qactivity*U command. Each occurrence of `%' in <span Class="emphasis">message</span> is replaced by the number of the window in which activity has occurred, and each occurrence of `^G' is replaced by the definition for bell in your termcap (usually an audible bell). The default message is 
<p class="level0">	'Activity in window %n' 
<p class="level0">Note that monitoring is off for all windows by default, but can be altered by use of the *Qmonitor*U command (C-a M). 
<p class="level0">
<p class="level0"><span Class="manpage">allpartial on | off</span>
<p class="level0">If set to on, only the current cursor line is refreshed on window change. This affects all windows and is useful for slow terminal lines. The  previous setting of full/partial refresh for each window is restored with *Qallpartial off*U.  This is a global flag that immediately takes effect on all windows overriding the *Qpartial*U settings. It does not change the default redraw behavior of newly created windows. 
<p class="level0">
<p class="level0"><span Class="manpage">altscreen on | off</span>
<p class="level0">If set to on, "alternate screen" support is enabled in virtual terminals, just like in xterm.  Initial setting is `off'. 
<p class="level0">
<p class="level0"><span Class="manpage">at  [\fIidentifier\fP][ #\fP|\fP*\fP|\fP%\fP]</span><span Class="emphasis">command  [ args  … ]</span> 
<p class="level0">Execute a command at other displays or windows as if it had been entered there. *QAt*U changes the context (the `current window' or `current display' setting) of the command. If the first parameter describes a  non-unique context, the command will be executed multiple times. If the first  parameter is of the form `<span Class="emphasis">identifier</span>*' then identifier is matched against user names.  The command is executed once for each display of the selected  user(s). If the first parameter is of the form `<span Class="emphasis">identifier</span>%' identifier  is matched against displays. Displays are named after the ttys they  attach. The prefix `/dev/' or `/dev/tty' may be omitted from the identifier. If <span Class="emphasis">identifier</span> has a `&#35;' or nothing appended it is matched against  window numbers and titles. Omitting an identifier in front of the `&#35;', `*' or  `%'-character selects all users, displays or windows because a prefix-match is performed. Note that on the affected display(s) a short message will describe what happened. Permission is checked for initiator of the *Qat*U command, not for the owners of the affected display(s). Note that the '&#35;' character works as a comment introducer when it is preceded by whitespace. This can be escaped by prefixing a 'e'.  Permission is checked for the initiator of the *Qat*U command, not for the owners of the affected display(s). <br>Caveat:  When matching against windows, the command is executed at least  once per window. Commands that change the internal arrangement of windows (like *Qother*U) may be called again. In shared windows the command will be repeated for each attached display. Beware, when issuing toggle commands like *Qlogin*U! Some commands (e.g. *Qprocess*U) require that  a display is associated with the target windows.  These commands may not work correctly under *Qat*U looping over windows. 
<p class="level0">
<p class="level0"><span Class="bold">attrcolor  attrib</span> 
<p class="level0">
<p class="level0">This command can be used to highlight attributes by changing the color of the text. If the attribute <span Class="emphasis">attrib</span> is in use, the specified attribute/color modifier is also applied. If no modifier is given, the current one is deleted. See the *QSTRING ESCAPES*U chapter for the syntax of the modifier. Screen understands two pseudo-attributes, *Qi*U stands for high-intensity foreground color and *QI*U for high-intensity background color. 
<p class="level0">Examples: 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">attrcolor b "R" 
<p class="level1">Change the color to bright red if bold text is to be printed. 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">attrcolor u "-u b" 
<p class="level1">Use blue text instead of underline. 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">attrcolor b ".I" 
<p class="level1">Use bright colors for bold text. Most terminal emulators do this already. 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">attrcolor i "+b" 
<p class="level1">Make bright colored text also bold. 
<p class="level1">
<p class="level1"><span Class="manpage">autodetach on | off</span>
<p class="level1">Sets whether  <span Class="emphasis">screen</span> will automatically detach upon hangup, which saves all your running programs until they are resumed with a <span Class="bold">screen -r</span> command. When turned off, a hangup signal will terminate  <span Class="emphasis">screen</span> and all the processes it contains. Autodetach is on by default. 
<p class="level1">
<p class="level1"><span Class="manpage">autonuke on | off</span>
<p class="level1">Sets whether a clear screen sequence should nuke all the output that has not been written to the terminal. See also *Qobuflimit*U. 
<p class="level1">
<p class="level1"><span Class="bold">backtick  id</span> <span Class="emphasis">lifespan</span> <span Class="emphasis">autorefresh</span> <span Class="emphasis">cmd</span> <span Class="emphasis">args…</span> <br><span Class="bold">backtick  id</span> 
<p class="level1">Program the backtick command with the numerical id <span Class="emphasis">id</span>. The output of such a command is used for substitution of the *Q%`*U string escape. The specified <span Class="emphasis">lifespan</span> is the number of seconds the output is considered valid. After this time, the command is run again if a corresponding string escape is encountered. The <span Class="emphasis">autorefresh</span> parameter triggers an automatic refresh for caption and hardstatus strings after the specified number of seconds. Only the last line of output is used for substitution. <br>If both the <span Class="emphasis">lifespan</span> and the <span Class="emphasis">autorefresh</span> parameters are zero, the backtick program is expected to stay in the background and generate output once in a while. In this case, the command is executed right away and screen stores the last line of output. If a new line gets printed screen will automatically refresh the hardstatus or the captions. <br>The second form of the command deletes the backtick command with the numerical id <span Class="emphasis">id</span>. 
<p class="level1">
<p class="level1"><span Class="manpage">bce  [ on | off ]</span>
<p class="level1">Change background-color-erase setting. If *Qbce*U is set to on, all characters cleared by an erase/insert/scroll/clear operation will be displayed in the current background color. Otherwise the default background color is used. 
<p class="level1">
<p class="level1"><span Class="bold">bell_msg</span> 
<p class="level1">
<p class="level1">When a bell character is sent to a background window, <span Class="emphasis">screen</span> displays a notification in the message line. The notification message can be re-defined by this command. Each occurrence of `%' in <span Class="emphasis">message</span> is replaced by the number of the window to which a bell has been sent, and each occurrence of `^G' is replaced by the definition for bell in your termcap (usually an audible bell). The default message is 
<p class="level1">	'Bell in window %n' 
<p class="level1">An empty message can be supplied to the *Qbell_msg*U command to suppress output of a message line (bell_msg ""). Without parameter, the current message is shown. 
<p class="level1">
<p class="level1"><span Class="bold">bind </span> 
<p class="level1"><span Class="emphasis">class ]</span> <span Class="emphasis">key </span> 
<p class="level1">
<p class="level1">Bind a command to a key. By default, most of the commands provided by <span Class="emphasis">screen</span> are bound to one or more keys as indicated in the *QDEFAULT KEY BINDINGS*U section, e.|g. the command to create a new window is bound to *QC-c*U and *Qc*U. The *Qbind*U command can be used to redefine the key bindings and to define new bindings. The <span Class="emphasis">key</span> argument is either a single character, a two-character sequence of the form *Q^x*U (meaning *QC-x*U), a backslash followed by an octal number (specifying the ASCII code of the character), or a backslash followed by a second character, such as *Qe^*U or *Qee*U. The argument can also be quoted, if you like. If no further argument is given, any previously established binding for this key is removed. The <span Class="emphasis">command</span> argument can be any command listed in this section. 
<p class="level1">If a command class is specified via the *Q-c*U option, the key is bound for the specified class. Use the *Qcommand*U command to activate a class. Command classes can be used to create multiple command keys or multi-character bindings. 
<p class="level1">Some examples: 
<p class="level1"><pre class="level1">
	bind ' ' windows
	bind ^k
	bind k
	bind K kill
	bind ^f screen telnet foobar
	bind e033 screen -ln -t root -h 1000 9 su
</pre>

<p class="level1">
<p class="level1">would bind the space key to the command that displays a list of windows (so that the command usually invoked by *QC-a C-w*U would also be available as *QC-a space*U). The next three lines remove the default kill binding from *QC-a C-k*U and *QC-a k*U.  *QC-a K*U is then bound to the kill command. Then it binds *QC-f*U to the command *Qcreate a window with a TELNET connection to foobar*U, and bind *Qescape*U to the command that creates an non-login window with a.|k.|a. *Qroot*U in slot &#35;9, with a superuser shell and a scrollback buffer of 1000 lines. 
<p class="level1"><pre class="level1">
	bind -c demo1 0 select 10
	bind -c demo1 1 select 11
	bind -c demo1 2 select 12
	bindkey "^B" command -c demo1
</pre>

<p class="level1">
<p class="level1">makes *QC-b 0*U select window 10, *QC-b 1*U window 11, etc. 
<p class="level1"><pre class="level1">
	bind -c demo2 0 select 10
	bind -c demo2 1 select 11
	bind -c demo2 2 select 12
	bind - command -c demo2
</pre>

<p class="level1">
<p class="level1">makes *QC-a - 0*U select window 10, *QC-a - 1*U window 11, etc. 
<p class="level1">
<p class="level1"><span Class="bold">bindkey</span> 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level1"><span Class="emphasis">string</span> 
<p class="level1">
<p class="level1">This command manages screen's input translation tables. Every entry in one of the tables tells screen how to react if a certain sequence of characters is encountered. There are three tables: one that should contain actions programmed by the user, one for the default actions used for terminal emulation and one for screen's copy mode to do cursor movement. See section *QINPUT TRANSLATION*U for a list of default key bindings. <br>If the <span Class="bold">-d</span> option is given, bindkey modifies the default table, <span Class="bold">-m</span> changes the copy mode table and with neither option the user table is selected. The argument <span Class="emphasis">string</span> is the sequence of characters to which an action is bound. This can either be a fixed string or a termcap keyboard capability name (selectable with the <span Class="bold">-k</span> option). <br>Some keys on a VT100 terminal can send a different string if application mode is turned on (e.g the cursor keys). Such keys have two entries in the translation table. You can select the application mode entry by specifying the <span Class="bold">-a</span> option. <br>The <span Class="bold">-t</span> option tells screen not to do inter-character timing. One cannot turn off the timing if a termcap capability is used. <br><span Class="emphasis">Cmd</span> can be any of screen's commands with an arbitrary number of <span Class="emphasis">args .</span> If <span Class="emphasis">cmd</span> is omitted the key-binding is removed from the table. <br>Here are some examples of keyboard bindings: 
<p class="level1"><pre class="level1">
&nbsp;       bindkey -d
</pre>

<p class="level1">Show all of the default key bindings. The application mode entries are marked with [A]. 
<p class="level1"><pre class="level1">
&nbsp;       bindkey -k k1 select 1
</pre>

<p class="level1">Make the "F1" key switch to window one. 
<p class="level1"><pre class="level1">
&nbsp;       bindkey -t foo stuff barfoo
</pre>

<p class="level1">Make "foo" an abbreviation of the word "barfoo". Timeout is disabled so that users can type slowly. 
<p class="level1"><pre class="level1">
&nbsp;       bindkey "e024" mapdefault
</pre>

<p class="level1">This key-binding makes *Q^T*U an escape character for key-bindings. If you did the above *Qstuff barfoo*U binding, you can enter the word *Qfoo*U by typing *Q^Tfoo*U. If you want to insert a *Q^T*U you have to press the key twice (i.e., escape the escape binding). 
<p class="level1"><pre class="level1">
&nbsp;       bindkey -k F1 command
</pre>

<p class="level1">Make the F11 (not F1!) key an alternative screen escape (besides ^A). 
<p class="level1">
<p class="level1"><span Class="bold">break</span> 
<p class="level1">
<p class="level1">Send a break signal for <span Class="emphasis">duration</span>*0.25 seconds to this window. For non-Posix systems the time interval may be rounded up to full seconds. Most useful if a character device is attached to the window rather than  a shell process (See also chapter *QWINDOW TYPES*U). The maximum duration of a break signal is limited to 15 seconds. 
<p class="level1">
<p class="level1"><span Class="bold">blanker</span> 
<p class="level1">Activate the screen blanker. First the screen is cleared. If no blanker program is defined, the cursor is turned off, otherwise, the  program is started and it's output is written to the screen. The screen blanker is killed with the first keypress, the read key is discarded. <br>This command is normally used together with the *Qidle*U command. 
<p class="level1">
<p class="level1"><span Class="bold">blankerprg</span> 
<p class="level1">
<p class="level1">Defines a blanker program. Disables the blanker program if an empty argument is given. Shows the currently set blanker program if no arguments are given. 
<p class="level1">
<p class="level1"><span Class="bold">breaktype</span> 
<p class="level1">
<p class="level1">
<p class="level1">Choose one of the available methods of generating a break signal for terminal devices. This command should affect the current window only. But it still behaves identical to *Qdefbreaktype*U. This will be changed in the future. Calling *Qbreaktype*U with no parameter displays the break method for the current window. 
<p class="level1">
<p class="level1"><span Class="bold">bufferfile</span> 
<p class="level1">
<p class="level1">Change the filename used for reading and writing with the paste buffer. If the optional argument to the *Qbufferfile*U command is omitted,  the default setting (*Q/tmp/screen-exchange*U) is reactivated. The following example will paste the system's password file into  the <span Class="emphasis">screen</span> window (using the paste buffer, where a copy remains): 
<p class="level1"><pre class="level1">
	C-a : bufferfile /etc/passwd
	C-a &lt; C-a ]
	C-a : bufferfile
</pre>

<p class="level1">
<p class="level1">
<p class="level1"><span Class="manpage">c1  [ on | off ]</span>
<p class="level1">Change c1 code processing. *QC1 on*U tells screen to treat the input characters between 128 and 159 as control functions. Such an 8-bit code is normally the same as ESC followed by the corresponding 7-bit code. The default setting is to process c1 codes and can be changed with the *Qdefc1*U command.  Users with fonts that have usable characters in the c1 positions may want to turn this off. 
<p class="level1">
<p class="level1"><span Class="manpage">caption always | splitonly</span>
<p class="level1"><br><span Class="bold">caption string</span> 
<p class="level1">
<p class="level1">This command controls the display of the window captions. Normally a caption is only used if more than one window is shown on the display (split screen mode). But if the type is set to <span Class="bold">always</span> screen shows a caption even if only one window is displayed. The default is <span Class="manpage">splitonly .</span>
<p class="level1">The second form changes the text used for the caption. You can use all escapes from the *QSTRING ESCAPES*U chapter. Screen uses a default of `%3n %t'. 
<p class="level1">You can mix both forms by providing a string as an additional argument. 
<p class="level1">
<p class="level1"><span Class="bold">charset  set</span> 
<p class="level1">Change the current character set slot designation and charset mapping.  The first four character of <span Class="emphasis">set</span> are treated as charset designators while the fifth and sixth character must be in range '0' to '3' and set the GL/GR charset mapping. On every position a '.' may be used to indicate that the corresponding charset/mapping should not be changed (<span Class="emphasis">set</span> is padded to six characters internally by appending '.' chars). New windows have "BBBB02" as default charset, unless a *Qencoding*U command is active. <br>The current setting can be viewed with the *Qinfo*U command. 
<p class="level1">
<p class="level1"><span Class="bold">chdir</span> 
<p class="level1">
<p class="level1">Change the <span Class="emphasis">current directory</span> of <span Class="emphasis">screen</span> to the specified directory or, if called without an argument, to your home directory (the value of the environment variable $HOME). All windows that are created by means of the *Qscreen*U command from within *Q.screenrc*U or by means of *QC-a : screen …*U or *QC-a c*U use this as their default directory. Without a chdir command, this would be the directory from which <span Class="emphasis">screen</span> was invoked. Hardcopy and log files are always written to the <span Class="emphasis">window's</span> default directory, <span Class="emphasis">not</span> the current directory of the process running in the window. You can use this command multiple times in your .screenrc to start various windows in different default directories, but the last chdir value will affect all the windows you create interactively. 
<p class="level1">
<p class="level1"><span Class="bold">cjkwidth [ on | off ]</span> 
<p class="level1">Treat ambiguous width characters as full/half width. 
<p class="level1">
<p class="level1"><span Class="bold">clear</span> 
<p class="level1">Clears the current window and saves its image to the scrollback buffer. 
<p class="level1">
<p class="level1"><span Class="bold">colon</span> 
<p class="level1">
<p class="level1">Allows you to enter *Q.screenrc*U command lines. Useful  for on-the-fly modification of key bindings,  specific window creation and changing settings. Note that the *Qset*U keyword no longer exists! Usually commands affect the current window rather  than default settings for future windows. Change defaults with commands starting with 'def…'. 
<p class="level1">If you consider this as the `Ex command mode' of  <span Class="emphasis">screen ,</span> you may regard *QC-a esc*U (copy mode) as its `Vi command mode'. 
<p class="level1">
<p class="level1"><span Class="bold">command</span> 
<p class="level1"><span Class="emphasis">class ]</span> 
<p class="level1">This command has the same effect as typing the screen escape character (^A). It is probably only useful for key bindings. If the *Q-c*U option is given, select the specified command class.  See also *Qbind*U and *Qbindkey*U. 
<p class="level1">
<p class="level1"><span Class="manpage">compacthist  [ on | off ]</span>
<p class="level1">This tells screen whether to suppress trailing blank lines when scrolling up text into the history buffer. 
<p class="level1">
<p class="level1"><span Class="manpage">console  [ on | off ]</span>
<p class="level1">Grabs or un-grabs the machines console output to a window. <span Class="emphasis">Note :</span> Only the owner of /dev/console can grab the console output. This command is only available if the machine supports the ioctl TIOCCONS. 
<p class="level1">
<p class="level1"><span Class="bold">copy</span> 
<p class="level1">Enter copy/scrollback mode. This allows you to copy text from the current window and its history into the paste buffer. In this mode a vi-like `full screen editor' is active: <br><span Class="emphasis">Movement keys :</span> <br>
<p class="level1">
<p class="level1"><a class="bold" href="#h">h</a>, <span Class="bold">C-h</span>, or <span Class="bold">left arrow</span> move the cursor left. <br>
<p class="level1"><span Class="bold">j</span>, <span Class="bold">C-n</span>, or <span Class="bold">down arrow</span> move the cursor down. <br>
<p class="level1"><a class="bold" href="#k">k</a>, <span Class="bold">C-p</span>, or <span Class="bold">up arrow</span> move the cursor up. <br>
<p class="level1"><a class="bold" href="#l">l</a> ('el') or <span Class="bold">right arrow</span> move the cursor right. <br>
<p class="level1"><span Class="bold">0</span> (zero) or <span Class="bold">C-a</span> move to the leftmost column. <br>
<p class="level1"><a class="bold" href="#">+</a> and <a class="bold" href="#-">-</a> positions one line up and down. <br>
<p class="level1"><a class="bold" href="#H">H</a>, <a class="bold" href="#M">M</a> and <span Class="bold">L</span> move the cursor to the leftmost column of the top, center or bottom line of the window.  <br>
<p class="level1"><a class="bold" href="#">|</a> moves to the specified absolute column. <br>
<p class="level1"><a class="bold" href="#g">g</a> or <span Class="bold">home</span> moves to the beginning of the buffer. <br>
<p class="level1"><span Class="bold">G</span> or <span Class="bold">end</span> moves to the specified absolute line (default: end of buffer). <br>
<p class="level1"><a class="bold" href="#">%</a> jumps to the specified percentage of the buffer. <br>
<p class="level1"><a class="bold" href="#">^</a> or <a class="bold" href="#">$</a> move to the leftmost column, to the first or last non-whitespace character on the line. <br>
<p class="level1"><a class="bold" href="#w">w</a>, <a class="bold" href="#b">b</a>, and <a class="bold" href="#e">e</a> move the cursor word by word. <br>
<p class="level1"><a class="bold" href="#B">B</a>, <a class="bold" href="#E">E</a> move the cursor WORD by WORD (as in vi). <br>
<p class="level1">
<p class="level1"><span Class="bold">f/F</span>, <span Class="bold">t/T</span> move the cursor forward/backward to the next occurence of the target. (eg, '3fy' will  move the cursor to the 3rd 'y' to the right.) <br>
<p class="level1"><a class="bold" href="#">;</a> and <a class="bold" href="#">,</a> Repeat the last f/F/t/T command in the same/opposite direction. <br>
<p class="level1"><span Class="bold">C-e</span> and <span Class="bold">C-y</span> scroll the display up/down by one line while preserving the cursor position. <br>
<p class="level1"><span Class="bold">C-u</span> and <span Class="bold">C-d</span> scroll the display up/down by the specified amount of  lines while preserving the cursor position. (Default: half screen-full).  <br>
<p class="level1"><span Class="bold">C-b</span> and <span Class="bold">C-f</span> scroll the display up/down a full screen. <br>
<p class="level1">
<p class="level1"><span Class="emphasis">Note :</span> <br>Emacs style movement keys can be customized by a .screenrc command. (E.|g. markkeys "h=^B:l=^F:$=^E") There is no simple method for a full  emacs-style keymap, as this involves multi-character codes. 
<p class="level1"><br>
<p class="level1"><span Class="emphasis">Marking :</span> <br>The copy range is specified by setting two marks. The text between these marks  will be highlighted. Press: <br>
<p class="level1"><span Class="bold">space</span> or <span Class="bold">enter</span> to set the first or second mark respectively. If <span Class="bold">mousetrack</span> is set to `on', marks can also be set using </span>left mouse click</span>. <br>
<p class="level1"><a class="bold" href="#Y">Y</a> and <a class="bold" href="#y">y</a> used to mark one whole line or to mark from  start of line. <br>
<p class="level1"><a class="bold" href="#W">W</a> marks exactly one word.  <br>
<p class="level1"><span Class="emphasis">Repeat count :</span> <br>Any of these commands can be prefixed with a repeat count number by pressing  digits  <br>
<p class="level1"><span Class="bold">0</span>..<span Class="bold">9</span> which is taken as a repeat count.  <br>Example: *QC-a C-[ H 10 j 5 Y*U will copy lines 11 to 15 into the paste buffer. <br>
<p class="level1"><span Class="emphasis">Searching :</span> 
<p class="level1"><a class="bold" href="#">/</a> <span Class="emphasis">Vi</span>-like search forward. 
<p class="level1"><a class="bold" href="#">?</a> <span Class="emphasis">Vi</span>-like search backward. 
<p class="level1"><span Class="bold">C-a s</span> <span Class="emphasis">Emacs</span> style incremental search forward. 
<p class="level1"><span Class="bold">C-r</span> <span Class="emphasis">Emacs</span> style reverse i-search. 
<p class="level1"><a class="bold" href="#n">n</a> Find next search pattern. 
<p class="level1"><span Class="bold">N</span> Find previous search pattern. 
<p class="level1"><span Class="emphasis">Specials :</span> <br>There are however some keys that act differently than in <span Class="emphasis">vi .</span> <span Class="emphasis">Vi</span> does not allow one to yank rectangular blocks of text, but <span Class="emphasis">screen</span> does. Press:  <br>
<p class="level1"><a class="bold" href="#c">c</a> or <a class="bold" href="#C">C</a> to set the left or right margin respectively. If no repeat count is given, both default to the current cursor position.  <br>Example: Try this on a rather full text screen:  *QC-a [ M 20 l SPACE c 10 l 5 j C SPACE*U. 
<p class="level1">This moves one to the middle line of the screen, moves in 20 columns left, marks the beginning of the paste buffer, sets the left column, moves 5 columns down, sets the right column, and then marks the end of the paste buffer. Now try: <br>*QC-a [ M 20 l SPACE 10 l 5 j SPACE*U 
<p class="level1">and notice the difference in the amount of text copied. <br>
<p class="level1"><span Class="bold">J</span> joins lines. It toggles between 4 modes: lines separated by a newline character (012), lines glued seamless, lines separated by a single whitespace and comma separated lines. Note that you can prepend the newline character with a carriage return character, by issuing a *Qcrlf on*U. <br>
<p class="level1"><span Class="bold">v</span> or <span Class="bold">V</span> is for all the <span Class="emphasis">vi </span> users with *Q:set numbers*U - it toggles the left margin between column 9 and 1. Press  <br>
<p class="level1"><a class="bold" href="#a">a</a> before the final space key to toggle in append mode. Thus the contents of the paste buffer will not be overwritten, but is appended to. <br>
<p class="level1"><a class="bold" href="#A">A</a> toggles in append mode and sets a (second) mark. <br>
<p class="level1"><span Class="bold">&gt;</span> sets the (second) mark and writes the contents of the paste buffer to the screen-exchange file (/tmp/screen-exchange per default) once copy-mode is finished.  <br>This example demonstrates how to dump the whole scrollback buffer  to that file: *QC-A [ g SPACE G $ &gt;*U. <br>
<p class="level1"><span Class="bold">C-g</span> gives information about the current line and column. <br>
<p class="level1"><span Class="bold">x</span> or <span Class="bold">o</span> exchanges the first mark and the current cursor position. You can use this to adjust an already placed mark. <br>
<p class="level1"><span Class="bold">C-l</span> ('el') will redraw the screen. <br>
<p class="level1"><a class="bold" href="#">@</a> does nothing. Does not even exit copy mode. <br>
<p class="level1">All keys not described here exit copy mode. 
<p class="level1">
<p class="level1">
<p class="level1"><span Class="bold">copy_reg</span> 
<p class="level1">
<p class="level1">No longer exists, use *Qreadreg*U instead. 
<p class="level1">
<p class="level1"><span Class="manpage">crlf  [ on | off ]</span>
<p class="level1">This affects the copying of text regions with the `C-a [' command. If it is set to `on', lines will be separated by the two character sequence `CR' - `LF'.  Otherwise (default) only `LF' is used. When no parameter is given, the state is toggled. 
<p class="level1">
<p class="level1"><span Class="manpage">debug on | off</span>
<p class="level1">Turns runtime debugging on or off. If  <span Class="emphasis">screen</span> has been compiled with option -DDEBUG debugging available and is turned on per default. Note that this command only affects debugging output from the main  *QSCREEN*U process correctly. Debug output from attacher processes can only be turned off once and forever. 
<p class="level1">
<p class="level1"><span Class="manpage">defc1 on | off</span>
<p class="level1">Same as the <span Class="bold">c1</span> command except that the default setting for new windows is changed. Initial setting is `on'. 
<p class="level1">
<p class="level1"><span Class="manpage">defautonuke on | off</span>
<p class="level1">Same as the <span Class="bold">autonuke</span> command except that the default setting for new displays is changed. Initial setting is `off'. Note that you can use the special `AN' terminal capability if you want to have a dependency on the terminal type. 
<p class="level1">
<p class="level1"><span Class="manpage">defbce on | off</span>
<p class="level1">Same as the <span Class="bold">bce</span> command except that the default setting for new windows is changed. Initial setting is `off'. 
<p class="level1">
<p class="level1"><span Class="bold">defbreaktype</span> 
<p class="level1">
<p class="level1">
<p class="level1">Choose one of the available methods of generating a break signal for terminal devices. The preferred methods are  <span Class="emphasis">tcsendbreak  and  TIOCSBRK .</span> The third,  <span Class="emphasis">TCSBRK , </span> blocks the complete  <span Class="emphasis">screen</span> session for the duration of the break, but it may be the only way to generate long breaks.  <span Class="emphasis">Tcsendbreak  and  TIOCSBRK</span> may or may not produce long breaks with spikes (e.g. 4 per second). This is not only system-dependent, this also differs between serial board drivers. Calling *Qdefbreaktype*U with no parameter displays the current setting. 
<p class="level1">
<p class="level1"><span Class="manpage">defcharset  [ \fIset ]</span>
<p class="level1">Like the <span Class="bold">charset</span> command except that the default setting for new windows is changed. Shows current default if called without argument. 
<p class="level1">
<p class="level1"><span Class="bold">defescape  xy</span> 
<p class="level1">Set the default command characters. This is equivalent to the  *Qescape*U except that it is useful multiuser sessions only. In a multiuser session *Qescape*U changes the command character of the calling user, where *Qdefescape*U changes the default command characters for users that will be added later. 
<p class="level1">
<p class="level1"><span Class="manpage">defflow on | off | auto</span>
<p class="level1">
<p class="level1">Same as the <span Class="bold">flow</span> command except that the default setting for new windows  is changed. Initial setting is `auto'. Specifying *Qdefflow auto interrupt*U is the same as the command-line options <span Class="bold">-fa</span> and <span Class="manpage">-i .</span>
<p class="level1">
<p class="level1"><span Class="manpage">defgr on | off</span>
<p class="level1">Same as the <span Class="bold">gr</span> command except that the default setting for new windows is changed. Initial setting is `off'. 
<p class="level1">
<p class="level1"><span Class="manpage">defhstatus  [ \fIstatus ]</span>
<p class="level1">The hardstatus line that all new windows will get is set to <span Class="emphasis">status\fR.</span> This command is useful to make the hardstatus of every window display the window number or title or the like. <span Class="emphasis">Status</span> may contain the same directives as in the window messages, but the directive escape character is '^E' (octal 005) instead of '%'. This was done to make a misinterpretation of program generated hardstatus lines impossible. If the parameter <span Class="emphasis">status</span> is omitted, the current default string is displayed. Per default the hardstatus line of new windows is empty. 
<p class="level1">
<p class="level1"><span Class="bold">defencoding  enc</span> 
<p class="level1">Same as the <span Class="bold">encoding</span> command except that the default setting for new windows is changed. Initial setting is the encoding taken from the terminal. 
<p class="level1">
<p class="level1"><span Class="manpage">deflog on | off</span>
<p class="level1">Same as the <span Class="bold">log</span> command except that the default setting for new windows  is changed. Initial setting is `off'. 
<p class="level1">
<p class="level1"><span Class="manpage">deflogin on | off</span>
<p class="level1">Same as the <span Class="bold">login</span> command except that the default setting for new windows  is changed. This is initialized with `on' as distributed (see config.h.in). 
<p class="level1">
<p class="level1"><span Class="bold">defmode  mode</span> 
<p class="level1">The mode of each newly allocated pseudo-tty is set to <span Class="emphasis">mode</span>. <span Class="emphasis">Mode</span> is an octal number. When no *Qdefmode*U command is given, mode 0622 is used. 
<p class="level1">
<p class="level1"><span Class="manpage">defmonitor on | off</span>
<p class="level1">Same as the <span Class="bold">monitor</span> command except that the default setting for new  windows is changed. Initial setting is `off'. 
<p class="level1">
<p class="level1"><span Class="manpage">defmousetrack on | off</span>
<p class="level1">Same as the <span Class="bold">mousetrack</span> command except that the default setting for new windows is changed. Initial setting is `off'. 
<p class="level1">
<p class="level1"><span Class="bold">defnonblock </span> , <span Class="manpage">on | off | \fInumsecs</span>
<p class="level1">Same as the <span Class="bold">nonblock</span> command except that the default setting for displays is changed. Initial setting is `off'. 
<p class="level1">
<p class="level1"><span Class="bold">defobuflimit  limit</span> 
<p class="level1">Same as the <span Class="bold">obuflimit</span> command except that the default setting for new displays is changed. Initial setting is 256 bytes. Note that you can use the special 'OL' terminal capability if you want to have a dependency on the terminal type. 
<p class="level1">
<p class="level1"><span Class="bold">defscrollback  num</span> 
<p class="level1">Same as the <span Class="bold">scrollback</span> command except that the default setting for new  windows is changed. Initial setting is 100. 
<p class="level1">
<p class="level1"><span Class="bold">defshell  command</span> 
<p class="level1">Synonym to the <span Class="bold">shell</span> .screenrc command. See there. 
<p class="level1">
<p class="level1"><span Class="manpage">defsilence on | off</span>
<p class="level1">Same as the <span Class="bold">silence</span> command except that the default setting for new windows is changed. Initial setting is `off'. 
<p class="level1">
<p class="level1"><span Class="bold">defslowpaste  msec</span> 
<p class="level1">Same as the <span Class="bold">slowpaste</span> command except that the default setting for new windows is changed. Initial setting is 0 milliseconds, meaning `off'. 
<p class="level1">
<p class="level1"><span Class="manpage">defutf8 on | off</span>
<p class="level1">Same as the <span Class="bold">utf8</span> command except that the default setting for new windows is changed. Initial setting is `on' if screen was started with *Q-U*U, otherwise `off'. 
<p class="level1">
<p class="level1"><span Class="manpage">defwrap on | off</span>
<p class="level1">Same as the <span Class="bold">wrap</span> command except that the default setting for new  windows is changed. Initially line-wrap is on and can be toggled with the  *Qwrap*U command (*QC-a r*U) or by means of "C-a : wrap on|off". 
<p class="level1">
<p class="level1"><span Class="manpage">defwritelock on | off | auto</span>
<p class="level1">Same as the <span Class="bold">writelock</span> command except that the default setting for new  windows is changed. Initially writelocks will off. 
<p class="level1">
<p class="level1"><span Class="manpage">defzombie  [\fIkeys\fP]</span>
<p class="level1">Synonym to the <span Class="bold">zombie</span> command. Both currently change the default. See there. 
<p class="level1">
<p class="level1"><span Class="bold">detach</span> 
<p class="level1">
<p class="level1">Detach the  <span Class="emphasis">screen</span> session (disconnect it from the terminal and put it into the background). This returns you to the shell where you invoked <span Class="emphasis">screen .</span> A detached <span Class="emphasis">screen</span> can be resumed by invoking <span Class="emphasis">screen</span> with the <span Class="bold">-r</span> option (see also section *QCOMMAND-LINE OPTIONS*U). The <span Class="bold">-h</span> option tells screen to immediately close the connection to the terminal (*Qhangup*U). 
<p class="level1">
<p class="level1"><span Class="bold">dinfo</span> 
<p class="level1">Show what screen thinks about your terminal. Useful if you want to know why features like color or the alternate charset don't work. 
<p class="level1">
<p class="level1"><span Class="bold">displays</span> 
<p class="level1">Shows a tabular listing of all currently connected user front-ends (displays). This is most useful for multiuser sessions. The following keys can be used in displays list: <br>
<p class="level1">
<p class="level1"><a class="bold" href="#k">k</a>, <span Class="bold">C-p</span>, or <span Class="bold">up</span> Move up one line. <br>
<p class="level1"><span Class="bold">j</span>, <span Class="bold">C-n</span>, or <span Class="bold">down</span> Move down one line. <br>
<p class="level1"><span Class="bold">C-a</span> or <span Class="bold">home</span> Move to the first line. <br>
<p class="level1"><span Class="bold">C-e</span> or <span Class="bold">end</span> Move to the last line. <br>
<p class="level1"><span Class="bold">C-u</span> or <span Class="bold">C-d</span> Move one half page up or down. <br>
<p class="level1"><span Class="bold">C-b</span> or <span Class="bold">C-f</span> Move one full page up or down. <br>
<p class="level1"><span Class="bold">mouseclick</span> Move to the selected line. Available when *Qmousetrack*U is set to on. <br>
<p class="level1"><span Class="bold">space</span> Refresh the list <br>
<p class="level1"><a class="bold" href="#d">d</a> Detach that display <br>
<p class="level1"><a class="bold" href="#D">D</a> Power detach that display <br>
<p class="level1"><span Class="bold">C-g</span>, <span Class="bold">enter</span>, or <span Class="bold">escape</span> Exit the list <br>
<p class="level1">
<p class="level1">The following is an example of what *Qdisplays*U could look like: 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">xterm 80x42 jnweiger@/dev/ttyp4     0(m11)   &rWx <br>facit 80x24 mlschroe@/dev/ttyhf nb 11(tcsh)   rwx <br>xterm 80x42 jnhollma@/dev/ttyp5     0(m11)   &R.x <br>&nbsp;(A)   (B)     (C)     (D)     (E) (F)(G)   (H)(I) 
<p class="level1">The legend is as follows: <br>(A) The terminal type known by screen for this display. <br>(B) Displays geometry as width x height. <br>(C) Username who is logged in at the display. <br>(D) Device name of the display or the attached device <br>(E) Display is in blocking or nonblocking mode. The available modes are "nb", "NB", "Z&lt;", "Z&gt;", and "BL". <br>(F) Number of the window <br>(G) Name/title of window <br>(H) Whether the window is shared <br>(I) Window permissions. Made up of three characters: &nbsp;     (1st character) &nbsp;        ‘-’ : no read &nbsp;        ‘r’ : read &nbsp;        ‘R’ : read only due to foreign wlock &nbsp;     (2nd character) &nbsp;        ‘-’ : no write &nbsp;        ‘.’ : write suppressed by foreign wlock &nbsp;        ‘w’ : write &nbsp;        ‘W’ : own wlock &nbsp;     (3rd character) &nbsp;        ‘-’ : no execute &nbsp;        ‘x’ : execute 
<p class="level1">*QDisplays*U needs a region size of at least 10 characters wide and 5 characters high in order to display. 
<p class="level1">
<p class="level1"><span Class="manpage">digraph  [ \fIpreset [ \fI unicode-value ] ]</span>
<p class="level1">This command prompts the user for a digraph sequence. The next two characters typed are looked up in a builtin table and the resulting character is inserted in the input stream. For example, if the user enters 'a"', an a-umlaut will be inserted. If the first character entered is a 0 (zero), <span Class="emphasis">screen</span> will treat the following characters (up to three) as an octal number instead.  The optional argument <span Class="emphasis">preset</span> is treated as user input, thus one can create an *Qumlaut*U key. For example the command "bindkey ^K digraph '"'" enables the user to generate an a-umlaut by typing CTRL-K a. When a non-zero <span Class="emphasis">unicode-value</span> is specified, a new digraph is created with the specified preset. The digraph is unset if a zero value is provided for the <span Class="emphasis">unicode-value.</span> 
<p class="level1">
<p class="level1"><span Class="bold">dumptermcap</span> 
<p class="level1">Write the termcap entry for the virtual terminal optimized for the currently active window to the file *Q.termcap*U in the user's  *Q$HOME/.screen*U directory (or wherever  <span Class="emphasis">screen</span> stores its sockets. See the *QFILES*U section below). This termcap entry is identical to the value of the environment variable $TERMCAP that is set up by <span Class="emphasis">screen</span> for each window. For terminfo based systems you will need to run a converter like  <span Class="emphasis">captoinfo</span> and then compile the entry with  <span Class="emphasis">tic .</span> 
<p class="level1">
<p class="level1"><span Class="manpage">echo  [ -n ]</span><span Class="emphasis">message</span> 
<p class="level1">The echo command may be used to annoy  <span Class="emphasis">screen</span> users with a 'message of the day'. Typically installed in a global /etc/screenrc.  The option *Q-n*U may be used to suppress the line feed. See also *Qsleep*U. Echo is also useful for online checking of environment variables. 
<p class="level1">
<p class="level1"><span Class="bold">encoding  enc</span> 
<p class="level1">
<p class="level1">Tell  <span Class="emphasis">screen </span> how to interpret the input/output. The first argument sets the encoding of the current window. Each window can emulate a different encoding. The optional second parameter overwrites the encoding of the connected terminal. It should never be needed as screen uses the locale setting to detect the encoding. There is also a way to select a terminal encoding depending on the terminal type by using the *QKJ*U termcap entry. 
<p class="level1">Supported encodings are eucJP, SJIS, eucKR, eucCN, Big5, GBK, KOI8-R, CP1251, UTF-8, ISO8859-2, ISO8859-3, ISO8859-4, ISO8859-5, ISO8859-6, ISO8859-7, ISO8859-8, ISO8859-9, ISO8859-10, ISO8859-15, jis. 
<p class="level1">See also *Qdefencoding*U, which changes the default setting of a new window. 
<p class="level1">
<p class="level1"><span Class="bold">escape  xy</span> 
<p class="level1">Set the command character to <span Class="emphasis">x</span> and the character generating a literal command character (by triggering the *Qmeta*U command) to <a class="emphasis" href="#y">y</a> (similar to the -e option). Each argument is either a single character, a two-character sequence of the form *Q^x*U (meaning *QC-x*U), a backslash followed by an octal number (specifying the ASCII code of the character), or a backslash followed by a second character, such as *Qe^*U or *Qee*U. The default is *Q^Aa*U. 
<p class="level1">
<p class="level1"><span Class="bold">eval</span> <span Class="emphasis">command1</span> 
<p class="level1"><a class="emphasis" href="#">… ]</a> 
<p class="level1">Parses and executes each argument as separate command. 
<p class="level1">
<p class="level1"><span Class="bold">exec</span> 
<p class="level1"><span Class="emphasis">newcommand  [ args … ]]</span> 
<p class="level1">Run a unix subprocess (specified by an executable path <span Class="emphasis">newcommand</span> and its  optional arguments) in the current window. The flow of data between  newcommands stdin/stdout/stderr, the process originally started in the window  (let us call it "application-process") and screen itself (window) is  controlled by the file descriptor pattern fdpat. This pattern is basically a three character sequence representing stdin, stdout and stderr of newcommand. A dot (.) connects the file descriptor to <span Class="emphasis">screen .</span> An exclamation mark (!) causes the file descriptor to be connected to the application-process. A colon (:) combines both. User input will go to newcommand unless newcommand receives the  application-process'  output (fdpats first character is `!' or `:') or a pipe symbol (|) is added  (as a fourth character) to the end of fdpat. <br>Invoking `exec' without arguments shows name and arguments of the currently running subprocess in this window. Only one subprocess a time can be running in each window. <br>When a subprocess is running the `kill' command will affect it instead of the windows process. <br>Refer to the postscript file `doc/fdpat.ps' for a confusing illustration of all 21 possible combinations. Each drawing shows the digits 2,1,0 representing the three file descriptors of newcommand. The box marked `W' is the usual pty that has the application-process on its slave side. The box marked `P' is the secondary pty that now has <span Class="emphasis">screen</span> at its master side. 
<p class="level1">Abbreviations:  <br>Whitespace between the word `exec' and fdpat and the command  can be omitted. Trailing dots and a fdpat consisting only of dots can be  omitted. A simple `|' is synonymous for the pattern `!..|'; the word exec can be omitted here and can always be replaced by `!'. 
<p class="level1">Examples: 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">exec … /bin/sh <br>exec /bin/sh <br>!/bin/sh 
<p class="level1">Creates another shell in the same window, while the original shell is still  running. Output of both shells is displayed and user input is sent to the new /bin/sh. 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">exec !.. stty 19200 <br>exec ! stty 19200 <br>!!stty 19200 
<p class="level1">Set the speed of the window's tty. If your stty command operates on stdout,  then add another `!'. 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">exec !..| less <br>|less 
<p class="level1">This adds a pager to the window output. The special character `|' is needed to give the user control over the pager although it gets its input from the  window's process. This works, because <span Class="emphasis">less</span> listens on stderr (a behavior that <span Class="emphasis">screen</span> would not expect without the `|')  when its stdin is not a tty.  <span Class="emphasis">Less </span> versions newer than 177 fail miserably here; good old <span Class="emphasis">pg</span> still works. 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">!:sed -n s/.*Error.*/e007/p 
<p class="level1">Sends window output to both, the user and the sed command. The sed inserts an additional bell character (oct. 007) to the window output seen by <span Class="emphasis">screen .</span> This will cause "Bell in window x" messages, whenever the string "Error" appears in the window. 
<p class="level1">
<p class="level1"><span Class="bold">fit</span> 
<p class="level1">Change the window size to the size of the current region. This command is needed because screen doesn't adapt the window size automatically if the window is displayed more than once. 
<p class="level1">
<p class="level1"><span Class="bold">flow</span> 
<p class="level1">
<p class="level1">Sets the flow-control mode for this window. Without parameters it cycles the current window's flow-control setting from  "automatic" to "on" to "off". See the discussion on *QFLOW-CONTROL*U later on in this document for full  details and note, that this is subject to change in future releases. Default is set by `defflow'. 
<p class="level1">
<p class="level1"><span Class="manpage">focus  [ up | down | top | bottom ]</span>
<p class="level1">Move the input focus to the next region. This is done in a cyclic way so that the top region is selected after the bottom one. If no subcommand is given it defaults to `down'. `up' cycles in the opposite order, `top' and `bottom' go to the top and bottom region respectively. Useful bindings are (j and k as in vi) <pre class="level1">
&nbsp;   bind j focus down
&nbsp;   bind k focus up
&nbsp;   bind t focus top
&nbsp;   bind b focus bottom
</pre>

<p class="level1">Note that <a class="bold" href="#k">k</a> is traditionally bound to the <span Class="emphasis">kill</span> command. 
<p class="level1">
<p class="level1"><span Class="bold">focusminsize [ (  width |max|_ ) (  height |max|_ ) ]</span> 
<p class="level1">This forces any currently selected region to be automatically resized at least a certain <span Class="emphasis">width</span> and <span Class="emphasis">height</span>. All other surrounding regions will be resized in order to accommodate. This constraint follows everytime the *Qfocus*U command is used. The *Qresize*U command can be used to increase either dimension of a region, but never below what is set with *Qfocusminsize*U. The underscore `_' is a synonym for <span Class="bold">max</span>. Setting a <span Class="emphasis">width</span> and <span Class="emphasis">height</span> of `0 0' (zero zero) will undo any constraints and allow for manual resizing. Without any parameters, the minimum width and height is shown. 
<p class="level1">
<p class="level1"><span Class="manpage">gr  [ on | off ]</span>
<p class="level1">Turn GR charset switching on/off. Whenever screen sees an input character with the 8th bit set, it will use the charset stored in the GR slot and print the character with the 8th bit stripped. The default (see also *Qdefgr*U) is not to process GR switching because otherwise the ISO88591 charset would not work. 
<p class="level1">
<p class="level1"><span Class="bold">group</span> 
<p class="level1">
<p class="level1">Change or show the group the current window belongs to. Windows can be moved around between different groups by specifying the name of the destination group. Without specifying a group, the title of the current group is displayed. 
<p class="level1">
<p class="level1"><span Class="bold">hardcopy</span> 
<p class="level1">
<p class="level1">
<p class="level1">Writes out the currently displayed image to the file <span Class="emphasis">file</span>, or, if no filename is specified, to <span Class="emphasis">hardcopy.n</span> in the default directory, where <a class="emphasis" href="#n">n</a> is the number of the current window.  This either appends or overwrites the file if it exists. See below. If the option <span Class="bold">-h</span> is specified, dump also the contents of the scrollback buffer. 
<p class="level1">
<p class="level1"><span Class="manpage">hardcopy_append on | off</span>
<p class="level1">If set to "on",  <span Class="emphasis">screen</span> will append to the "hardcopy.n" files created by the command *QC-a h*U,  otherwise these files are overwritten each time. Default is `off'. 
<p class="level1">
<p class="level1"><span Class="bold">hardcopydir directory</span> 
<p class="level1">Defines a directory where hardcopy files will be placed. If unset, hardcopys are dumped in <span Class="emphasis">screen 's</span> current working directory. 
<p class="level1">
<p class="level1"><span Class="manpage">hardstatus  [ on | off ]</span><br><span Class="manpage">hardstatus \fR[\fBalways\fR]\fBlastline | message | ignore</span>
<p class="level1"><br><span Class="bold">hardstatus string</span> 
<p class="level1">
<p class="level1">This command configures the use and emulation of the terminal's hardstatus line. The first form toggles whether <span Class="emphasis">screen</span> will use the hardware status line to display messages. If the flag is set to `off', these messages are overlaid in reverse video mode at the display line. The default setting is `on'. 
<p class="level1">The second form tells  <span Class="emphasis">screen </span> what to do if the terminal doesn't have a hardstatus line (i.e. the termcap/terminfo capabilities "hs", "ts", "fs" and "ds" are not set). If the type *Qlastline*U is used,  <span Class="emphasis">screen </span> will reserve the last line of the display for the hardstatus. *Qmessage*U uses  <span Class="emphasis">screen's</span> message mechanism and *Qignore*U tells  <span Class="emphasis">screen </span> never to display the hardstatus. If you prepend the word *Qalways*U to the type (e.g., *Qalwayslastline*U),  <span Class="emphasis">screen </span> will use the type even if the terminal supports a hardstatus. 
<p class="level1">The third form specifies the contents of the hardstatus line.  '%h' is used as default string, i.e., the stored hardstatus of the current window (settable via *QESC]0;&lt;string&gt;^G*U or *QESC_&lt;string&gt;ESCe*U) is displayed.  You can customize this to any string you like including the escapes from the *QSTRING ESCAPES*U chapter. If you leave out the argument <span Class="emphasis">string ,</span> the current string is displayed. 
<p class="level1">You can mix the second and third form by providing the string as additional argument. 
<p class="level1">
<p class="level1"><span Class="bold">height</span> 
<p class="level1">
<p class="level1">
<p class="level1">Set the display height to a specified number of lines. When no argument is given it toggles between 24 and 42 lines display. You can also specify a width if you want to change both values. The <span Class="bold">-w</span> option tells screen to leave the display size unchanged and just set the window size, <span Class="bold">-d</span> vice versa. 
<p class="level1">
<p class="level1"><span Class="bold">help</span> 
<p class="level1"><span Class="emphasis">class ]</span> 
<p class="level1">Not really a online help, but  displays a help  <span Class="emphasis">screen </span> showing you all the key bindings. The first pages list all the internal commands followed by their current bindings. Subsequent pages will display the custom commands, one command per key. Press space when you're done reading each page, or return to exit early. All other characters are ignored. If the *Q-c*U option is given, display all bound commands for the specified command class. See also *QDEFAULT KEY BINDINGS*U section. 
<p class="level1">
<p class="level1"><span Class="bold">history</span> 
<p class="level1">Usually users work with a shell that allows easy access to previous commands. For example csh has the command *Q!!*U to repeat the last command executed.  <span Class="emphasis">Screen</span> allows you to have a primitive way of re-calling *Qthe command that started …*U: You just type the first letter of that command, then hit `C-a {' and <span Class="emphasis">screen</span> tries to find a previous line that matches with the `prompt character'  to the left of the cursor. This line is pasted into this window's input queue. Thus you have a crude command history (made up by the visible window and its scrollback buffer).  
<p class="level1">
<p class="level1"><span Class="bold">hstatus  status</span> 
<p class="level1">Change the window's hardstatus line to the string <span Class="emphasis">status</span>. 
<p class="level1">
<p class="level1"><span Class="bold">idle</span> 
<p class="level1">
<p class="level1">
<p class="level1">Sets a command that is run after the specified number of seconds inactivity is reached. This command will normally be the *Qblanker*U command to create a screen blanker, but it can be any screen command. If no command is specified, only the timeout is set. A timeout of zero (or the special timeout <span Class="bold">off</span>) disables the timer. If no arguments are given, the current settings are displayed. 
<p class="level1">
<p class="level1"><span Class="manpage">ignorecase  [ on | off ]</span>
<p class="level1">Tell screen to ignore the case of characters in searches. Default is `off'. Without any options, the state of ignorecase is toggled. 
<p class="level1">
<p class="level1"><span Class="bold">info</span> 
<p class="level1">Uses the message line to display some information about the current window: the cursor position in the form *Q(column,row)*U starting with *Q(1,1)*U, the terminal width and height plus the size of the scrollback buffer in lines,  like in *Q(80,24)+50*U, the current state of window XON/XOFF flow control is shown like this (See also section FLOW CONTROL): 
<p class="level1"><pre class="level1">
&nbsp; +flow     automatic flow control, currently on.
&nbsp; -flow     automatic flow control, currently off.
&nbsp; +(+)flow  flow control enabled. Agrees with automatic control.
&nbsp; -(+)flow  flow control disabled. Disagrees with automatic control.
&nbsp; +(-)flow  flow control enabled. Disagrees with automatic control.
&nbsp; -(-)flow  flow control disabled. Agrees with automatic control.
</pre>

<p class="level1">
<p class="level1">The current line wrap setting (`+wrap' indicates enabled, `-wrap' not) is also shown. The flags `ins', `org', `app', `log', `mon' or `nored' are  displayed when the window is in insert mode, origin mode,  application-keypad mode, has output logging, activity monitoring or partial redraw enabled. 
<p class="level1">The currently active character set (<span Class="emphasis">G0</span>, <span Class="emphasis">G1</span>, <span Class="emphasis">G2</span>, or <span Class="emphasis">G3</span>) and in square brackets the terminal character sets that are currently designated as <span Class="emphasis">G0</span> through <span Class="emphasis">G3</span> is shown. If the window is in UTF-8 mode, the string *QUTF-8*U is shown instead. 
<p class="level1">Additional modes depending on the type of the window are displayed at the end of the status line (See also chapter *QWINDOW TYPES*U). <br>If the state machine of the terminal emulator is in a non-default state, the info line is started with a string identifying the current state. <br>For system information use the *Qtime*U command. 
<p class="level1">
<p class="level1"><span Class="manpage">ins_reg  [ \fIkey ]</span>
<p class="level1">No longer exists, use *Qpaste*U instead. 
<p class="level1">
<p class="level1"><span Class="bold">kill</span> 
<p class="level1">Kill current window. <br>If there is an `exec' command running then it is killed. Otherwise the process (shell) running in the window receives a HANGUP condition,  the window structure is removed and  <span Class="emphasis">screen </span> (your display) switches to another window.  When the last window is destroyed,  <span Class="emphasis">screen</span> exits. After a kill  <span Class="emphasis">screen </span> switches to the previously displayed window. <br>Note: <span Class="emphasis">Emacs</span> users should keep this command in mind, when killing a line. It is recommended not to use *QC-a*U as the <span Class="emphasis">screen</span> escape key or to rebind kill to *QC-a K*U. 
<p class="level1">
<p class="level1"><span Class="bold">lastmsg</span> 
<p class="level1">Redisplay the last contents of the message/status line. Useful if you're typing when a message appears, because  the message goes  away when you press a key (unless your terminal has a hardware status line). Refer to the commands *Qmsgwait*U and *Qmsgminwait*U for fine tuning. 
<p class="level1">
<p class="level1"><span Class="manpage">layout new  [\fItitle\fP]</span>
<p class="level1">Create a new layout. The screen will change to one whole region and be switched to the blank window. From here, you build the regions and the windows they show as you desire. The new layout will be numbered with the smallest available integer, starting with zero. You can optionally give a title to your new layout. Otherwise, it will have a default title of *Qlayout*U. You can always change the title later by using the command <span Class="bold">layout title</span>. 
<p class="level1">
<p class="level1"><span Class="manpage">layout remove  [\fIn|title\fP]</span>
<p class="level1">Remove, or in other words, delete the specified layout. Either the number or the title can be specified. Without either specification, <span Class="emphasis">screen</span> will remove the current layout. 
<p class="level1">Removing a layout does not affect your set windows or regions. 
<p class="level1">
<p class="level1"><span Class="bold">layout next</span> 
<p class="level1">Switch to the next layout available 
<p class="level1">
<p class="level1"><span Class="bold">layout prev</span> 
<p class="level1">Switch to the previous layout available 
<p class="level1">
<p class="level1"><span Class="manpage">layout select  [\fIn|title\fP]</span>
<p class="level1">Select the desired layout. Either the number or the title can be specified. Without either specification, <span Class="emphasis">screen</span> will prompt and ask which screen is desired. To see which layouts are available, use the <span Class="bold">layout show</span> command. 
<p class="level1">
<p class="level1"><span Class="bold">layout show</span> 
<p class="level1">List on the message line the number(s) and title(s) of the available layout(s). The current layout is flagged. 
<p class="level1">
<p class="level1"><span Class="manpage">layout title  [\fItitle\fP]</span>
<p class="level1">Change or display the title of the current layout. A string given will be used to name the layout. Without any options, the current title and number is displayed on the message line. 
<p class="level1">
<p class="level1"><span Class="manpage">layout number  [\fIn\fP]</span>
<p class="level1">Change or display the number of the current layout. An integer given will be used to number the layout. Without any options, the current number and title is displayed on the message line. 
<p class="level1">
<p class="level1"><span Class="manpage">layout attach  [\fItitle\fP|\fB:last\fP]</span>
<p class="level1">Change or display which layout to reattach back to. The default is <span Class="bold">:last</span>, which tells <span Class="emphasis">screen</span> to reattach back to the last used layout just before detachment. By supplying a title, You can instruct <span Class="emphasis">screen</span> to reattach to a particular layout regardless which one was used at the time of detachment. Without any options, the layout to reattach to will be shown in the message line. 
<p class="level1">
<p class="level1"><span Class="manpage">layout save  [\fIn|title\fP]</span>
<p class="level1">Remember the current arrangement of regions. When used, <span Class="emphasis">screen</span> will remember the arrangement of vertically and horizontally split regions. This arrangement is restored when a <span Class="emphasis">screen</span> session is reattached or switched back from a different layout. If the session ends or the <span Class="emphasis">screen</span> process dies, the layout arrangements are lost. The <span Class="bold">layout dump</span> command should help in this siutation. If a number or title is supplied, <span Class="emphasis">screen</span> will remember the arrangement of that particular layout. Without any options, <span Class="emphasis">screen</span> will remember the current layout. 
<p class="level1">Saving your regions can be done automatically by using the <span Class="bold">layout autosave</span> command. 
<p class="level1">
<p class="level1"><span Class="manpage">layout autosave  [\fBon|off\fP]</span>
<p class="level1">Change or display the status of automatcally saving layouts. The default is <span Class="bold">on</span>, meaning when <span Class="emphasis">screen</span> is detached or changed to a different layout, the arrangement of regions and windows will be remembered at the time of change and restored upon return. If autosave is set to <span Class="bold">off</span>, that arrangement will only be restored to either to the last manual save, using <span Class="bold">layout save</span>, or to when the layout was first created, to a single region with a single window. Without either an <span Class="bold">on</span> or <span Class="bold">off</span>, the current status is displayed on the message line. 
<p class="level1">
<p class="level1"><span Class="manpage">layout dump  [\fIfilename\fP]</span>
<p class="level1">Write to a file the order of splits made in the current layout. This  is useful to recreate the order of your regions used in your current layout. Only the current layout is recorded. While the order of the regions are recorded, the sizes of those regions and which windows correspond to which regions are not. If no filename is specified, the default is <span Class="emphasis">layout-dump</span>, saved in the directory that the <span Class="emphasis">screen</span> process was started in. If the file already exists, <span Class="bold">layout dump</span> will append to that file. As an example: 
<p class="level1"><pre class="level1">
	C-a : layout dump /home/user/.screenrc
</pre>

<p class="level1">
<p class="level1">will save or append the layout to the user's <span Class="emphasis">.screenrc</span> file. 
<p class="level1">
<p class="level1"><span Class="bold">license</span> 
<p class="level1">Display the disclaimer page. This is done whenever <span Class="emphasis">screen</span> is started without options, which should be often enough. See also  the *Qstartup_message*U command. 
<p class="level1">
<p class="level1"><span Class="bold">lockscreen</span> 
<p class="level1">Lock this display. Call a screenlock program (/local/bin/lck or /usr/bin/lock or a builtin if no other is available). Screen does not accept any command keys until this program terminates. Meanwhile processes in the windows may continue, as the windows  are in the `detached' state. The screenlock program may be changed through the environment variable $LOCKPRG (which must be set in the shell from which  <span Class="emphasis">screen</span> is started) and is executed with the user's uid and gid. <br>Warning:  When you leave other shells unlocked and you have no password set on            <span Class="emphasis">screen ,</span> the lock is void: One could easily re-attach from an unlocked shell. This feature should rather be called `lockterminal'. 
<p class="level1">
<p class="level1"><span Class="manpage">log  [ on | off ]</span>
<p class="level1">Start/stop writing output of the current window to a file  *Qscreenlog.<a class="emphasis" href="#n">n</a>*U in the window's default directory, where <a class="emphasis" href="#n">n</a>  is the number of the current window. This filename can be changed with the `logfile' command. If no parameter is given, the state of logging is toggled. The session log is appended to the previous contents  of the file if it already exists. The current contents and the contents  of the scrollback history are not included in the session log. Default is `off'. 
<p class="level1">
<p class="level1"><span Class="bold">logfile  filename</span> <br><span Class="bold">logfile flush  secs</span> 
<p class="level1">Defines the name the log files will get. The default is *Qscreenlog.%n*U. The second form changes the number of seconds <span Class="emphasis">screen</span> will wait before flushing the logfile buffer to the file-system. The default value is 10 seconds. 
<p class="level1">
<p class="level1"><span Class="manpage">login  [ on | off ]</span>
<p class="level1">Adds or removes the entry in the utmp database file for the current window. This controls if the window is `logged in'. When no parameter is given, the login state of the window is toggled. Additionally to that toggle, it is convenient having a `log in' and a `log out' key. E.|g. `bind I login on' and `bind O login off' will map these keys to be C-a I and C-a O. The default setting (in config.h.in) should be *Qon*U for a  <span Class="emphasis">screen</span> that runs under suid-root. Use the *Qdeflogin*U command to change the default login state for new  windows. Both commands are only present when  <span Class="emphasis">screen</span> has been compiled with utmp support. 
<p class="level1">
<p class="level1"><span Class="manpage">logtstamp  [ on | off ]</span><br><span Class="bold">logtstamp after</span> 
<p class="level1"><br><span Class="bold">logtstamp string</span> 
<p class="level1">
<p class="level1">This command controls logfile time-stamp mechanism of  <span Class="emphasis">screen.</span> If time-stamps are turned *Qon*U,  <span Class="emphasis">screen </span> adds a string containing the current time to the logfile after two minutes of inactivity. When output continues and more than another two minutes have passed, a second time-stamp is added to document the restart of the output. You can change this timeout with the second form of the command. The third form is used for customizing the time-stamp string (`-- %n:%t -- time-stamp -- %M/%d/%y %c:%s --\n' by default). 
<p class="level1">
<p class="level1"><span Class="bold">mapdefault</span> 
<p class="level1">Tell  <span Class="emphasis">screen </span> that the next input character should only be looked up in the default bindkey table. See also *Qbindkey*U. 
<p class="level1">
<p class="level1"><span Class="bold">mapnotnext</span> 
<p class="level1">Like mapdefault, but don't even look in the default bindkey table. 
<p class="level1">
<p class="level1"><span Class="bold">maptimeout</span> 
<p class="level1">
<p class="level1">Set the inter-character timer for input sequence detection to a timeout of <span Class="emphasis">timeout</span> ms. The default timeout is 300ms. Maptimeout with no arguments shows the current setting. See also *Qbindkey*U. 
<p class="level1">
<p class="level1"><span Class="bold">markkeys  string</span> 
<p class="level1">This is a method of changing the keymap used for copy/history mode. The string is made up of <span Class="emphasis">oldchar</span>=<span Class="emphasis">newchar</span> pairs which are separated by `:'. Example: The string *QB=^B:F=^F*U will change the  keys `C-b' and `C-f' to the vi style binding (scroll up/down fill page). This happens to be the default binding for `B' and `F'. The command *Qmarkkeys h=^B:l=^F:$=^E*U would set the mode for an emacs-style binding. If your terminal sends characters, that cause you to abort copy mode, then this command may help by binding these characters to do nothing. The no-op character is `@' and is used like this: *Qmarkkeys @=L=H*U if you do not want to use the `H' or `L' commands any longer. As shown in this example, multiple keys can be assigned to one function in a  single statement. 
<p class="level1">
<p class="level1"><span Class="bold">maxwin  num</span> 
<p class="level1">Set the maximum window number screen will create. Doesn't affect already existing windows. The number can be increased only when there are no existing windows. 
<p class="level1">
<p class="level1"><span Class="bold">meta</span> 
<p class="level1">Insert the command character (C-a) in the current window's input stream. 
<p class="level1">
<p class="level1"><span Class="manpage">monitor  [ on | off ]</span>
<p class="level1">Toggles activity monitoring of windows. When monitoring is turned on and an affected window is switched into the background, you will receive the activity notification message in the status line at the first sign of output and the window will also be marked with an `@' in the window-status display. Monitoring is initially off for all windows. 
<p class="level1">
<p class="level1"><span Class="manpage">mousetrack  [ on | off ]</span>
<p class="level1">This command determines whether <span Class="emphasis">screen</span> will watch for mouse clicks. When this command is enabled, regions that have been split in various ways can be selected by pointing to them with a mouse and left-clicking them. Without specifying <span Class="bold">on</span> or <span Class="bold">off</span>, the current state is displayed. The default state is determined by the *Qdefmousetrack*U command. 
<p class="level1">
<p class="level1"><span Class="bold">msgminwait  sec</span> 
<p class="level1">Defines the time  <span Class="emphasis">screen </span> delays a new message when one message is currently displayed.  The default is 1 second. 
<p class="level1">
<p class="level1"><span Class="bold">msgwait  sec</span> 
<p class="level1">Defines the time a message is displayed if  <span Class="emphasis">screen</span> is not disturbed by other activity. The default is 5 seconds. 
<p class="level1">
<p class="level1"><span Class="manpage">multiuser on | off</span>
<p class="level1">Switch between singleuser and multiuser mode. Standard <span Class="emphasis">screen</span> operation is singleuser. In multiuser mode the commands `acladd', `aclchg', `aclgrp' and `acldel' can be used to enable (and disable) other users accessing this  <span Class="emphasis">screen</span> session.  
<p class="level1">
<p class="level1"><span Class="manpage">nethack on | off</span>
<p class="level1">Changes the kind of error messages used by <span Class="emphasis">screen .</span> When you are familiar with the game *Qnethack*U, you may enjoy the nethack-style messages which will often blur the facts a little, but are much funnier to read. Anyway, standard messages often tend to be unclear as well. <br>This option is only  available if <span Class="emphasis">screen</span> was compiled with the NETHACK flag defined. The default setting is then determined by the presence of the environment  variable $NETHACKOPTIONS and the file ~/.nethackrc - if either one is present, the default is <span Class="bold">on</span>. 
<p class="level1">
<p class="level1"><span Class="bold">next</span> 
<p class="level1">Switch to the next window. This command can be used repeatedly to cycle through the list of windows. 
<p class="level1">
<p class="level1"><span Class="bold">nonblock </span> 
<p class="level1">
<p class="level1">Tell screen how to deal with user interfaces (displays) that cease to accept output. This can happen if a user presses ^S or a TCP/modem connection gets cut but no hangup is received. If nonblock is <span Class="bold">off</span> (this is the default) screen waits until the display restarts to accept the output. If nonblock is <span Class="bold">on</span>, screen waits until the timeout is reached (<span Class="bold">on</span> is treated as 1s). If the display still doesn't receive characters, screen will consider it *Qblocked*U and stop sending characters to it. If at some time it restarts to accept characters, screen will unblock the display and redisplay the updated window contents. 
<p class="level1">
<p class="level1"><span Class="manpage">number  [[+|-] \fIn ]</span>
<p class="level1">Change the current window's number. If the given number <a class="emphasis" href="#n">n</a> is already  used by another window, both windows exchange their numbers. If no argument is specified, the current window number (and title) is shown. Using `+' or `-' will change the window's number by the relative amount specified. 
<p class="level1">
<p class="level1"><span Class="manpage">obuflimit  [ \fIlimit ]</span>
<p class="level1">If the output buffer contains more bytes than the specified limit, no more data will be read from the windows. The default value is 256. If you have a fast display (like xterm), you can set it to some higher value. If no argument is specified, the current setting is displayed. 
<p class="level1">
<p class="level1"><span Class="bold">only</span> 
<p class="level1">Kill all regions but the current one. 
<p class="level1">
<p class="level1"><span Class="bold">other</span> 
<p class="level1">Switch to the window displayed previously. If this window does no longer exist, <span Class="emphasis">other</span> has the same effect as <span Class="emphasis">next</span>. 
<p class="level1">
<p class="level1"><span Class="manpage">partial on | off</span>
<p class="level1">Defines whether the display should be refreshed (as with <span Class="emphasis">redisplay</span>) after switching to the current window. This command only affects the current window. To immediately affect all windows use the <span Class="emphasis">allpartial</span> command. Default is `off', of course.  This default is fixed, as there is currently no  <span Class="emphasis">defpartial</span> command. 
<p class="level1">
<p class="level1"><span Class="manpage">password  [ \fIcrypted_pw ]</span>
<p class="level1">Present a crypted password in your *Q.screenrc*U file and <span Class="emphasis">screen</span> will ask for it, whenever someone attempts to resume a detached. This is useful if you have privileged programs running under <span Class="emphasis">screen</span> and you want to protect your session from reattach attempts by another user masquerading as your uid (i.e. any superuser.) If no crypted password is specified, <span Class="emphasis">screen</span> prompts twice for typing a password and places its encryption in the paste buffer. Default is `none', this disables password checking. 
<p class="level1">
<p class="level1"><span Class="manpage">paste</span>
<p class="level1">
<p class="level1">Write the (concatenated) contents of the specified registers to the stdin queue of the current window. The register '.' is treated as the paste buffer. If no parameter is given the user is prompted for a single  register to paste. The paste buffer can be filled with the <span Class="emphasis">copy</span>, <span Class="emphasis">history</span> and  <span Class="emphasis">readbuf</span> commands.  Other registers can be filled with the <span Class="emphasis">register</span>, <span Class="emphasis">readreg</span> and  <span Class="emphasis">paste</span> commands. If <span Class="emphasis">paste</span> is called with a second argument, the contents of the specified registers is pasted into the named destination register rather than  the window. If '.' is used as the second argument, the displays paste buffer is the destination. Note, that *Qpaste*U uses a wide variety of resources: Whenever a second  argument is specified no current window is needed. When the source specification only contains registers (not the paste buffer) then there need not be a current  display (terminal attached), as the registers are a global resource. The  paste buffer exists once for every user. 
<p class="level1">
<p class="level1"><span Class="manpage">pastefont  [ on | off ]</span>
<p class="level1">Tell  <span Class="emphasis">screen </span> to include font information in the paste buffer. The default is not to do so. This command is especially useful for multi character fonts like kanji. 
<p class="level1">
<p class="level1"><span Class="bold">pow_break</span> 
<p class="level1">Reopen the window's terminal line and send a break condition. See `break'. 
<p class="level1">
<p class="level1"><span Class="bold">pow_detach</span> 
<p class="level1">Power detach.  Mainly the same as <span Class="emphasis">detach</span>, but also sends a HANGUP signal to the parent process of <span Class="emphasis">screen .</span> CAUTION: This will result in a logout, when  <span Class="emphasis">screen</span> was started from your login-shell. 
<p class="level1">
<p class="level1"><span Class="bold">pow_detach_msg</span> 
<p class="level1">
<p class="level1">The <span Class="emphasis">message</span> specified here is output whenever a `Power detach' was performed. It may be used as a replacement for a logout message or to reset  baud rate, etc.  Without parameter, the current message is shown. 
<p class="level1">
<p class="level1"><span Class="bold">prev</span> 
<p class="level1">Switch to the window with the next lower number. This command can be used repeatedly to cycle through the list of windows. 
<p class="level1">
<p class="level1"><span Class="bold">printcmd</span> 
<p class="level1">
<p class="level1">If <span Class="emphasis">cmd</span> is not an empty string,  <span Class="emphasis">screen </span> will not use the terminal capabilities *Qpo/pf*U if it detects an ansi print sequence <span Class="manpage">ESC [ 5 i</span>but pipe the output into <span Class="emphasis">cmd .</span> This should normally be a command like *Qlpr*U or *Q'cat &gt; /tmp/scrprint'*U. <span Class="bold">printcmd</span> without a command displays the current setting. The ansi sequence <span Class="bold">ESC \e</span> ends printing and closes the pipe. <br>Warning: Be careful with this command! If other user have write access to your terminal, they will be able to fire off print commands. 
<p class="level1">
<p class="level1"><span Class="manpage">process  [ \fIkey ]</span>
<p class="level1">Stuff the contents of the specified register into  <span Class="emphasis">screen 's</span> input queue. If no argument is given you are prompted for a register name. The text is parsed as if it had been typed in from the user's keyboard. This command can be used to bind multiple actions to a single key. 
<p class="level1">
<p class="level1"><span Class="bold">quit</span> 
<p class="level1">Kill all windows and terminate <span Class="emphasis">screen .</span> Note that on VT100-style terminals the keys C-4 and C-e are identical. This makes the default bindings dangerous: Be careful not to type C-a C-4 when selecting window no. 4. Use the empty bind command (as in *Qbind '^e'*U) to remove a key binding. 
<p class="level1">
<p class="level1"><span Class="bold">readbuf</span> 
<p class="level1"><span Class="emphasis">encoding ]</span> 
<p class="level1">
<p class="level1">Reads the contents of the specified file into the paste buffer. You can tell screen the encoding of the file via the <span Class="bold">-e</span> option. If no file is specified, the screen-exchange filename is used. See also *Qbufferfile*U command. 
<p class="level1">
<p class="level1"><span Class="bold">readreg </span> 
<p class="level1"><span Class="emphasis">encoding ]</span> 
<p class="level1">
<p class="level1">Does one of two things, dependent on number of arguments: with zero or one arguments it it duplicates the paste buffer contents into the register specified or entered at the prompt. With two arguments it reads the contents of the named  file into the register, just as <span Class="emphasis">readbuf</span> reads the screen-exchange file into the paste buffer. You can tell screen the encoding of the file via the <span Class="bold">-e</span> option. The following example will paste the system's password file into  the  <span Class="emphasis">screen </span> window (using register p, where a copy remains): 
<p class="level1"><pre class="level1">
	C-a : readreg p /etc/passwd
	C-a : paste p
</pre>

<p class="level1">
<p class="level1">
<p class="level1"><span Class="bold">redisplay</span> 
<p class="level1">Redisplay the current window. Needed to get a full redisplay when in partial redraw mode. 
<p class="level1">
<p class="level1"><span Class="bold">register</span> 
<p class="level1"><span Class="emphasis">encoding ]</span> <span Class="emphasis">key string</span> 
<p class="level1">Save the specified <span Class="emphasis">string</span> to the register <span Class="emphasis">key</span>. The encoding of the string can be specified via the <span Class="bold">-e</span> option. See also the *Qpaste*U command. 
<p class="level1">
<p class="level1"><span Class="bold">remove</span> 
<p class="level1">Kill the current region. This is a no-op if there is only one region. 
<p class="level1">
<p class="level1"><span Class="bold">removebuf</span> 
<p class="level1">Unlinks the screen-exchange file used by the commands *Qwritebuf*U and  *Qreadbuf*U.  
<p class="level1">
<p class="level1"><span Class="bold">rendition bell | monitor | silence | so</span> 
<p class="level1">
<p class="level1">Change the way <span Class="emphasis">screen</span> renders the titles of windows that have monitor or bell flags set in caption or hardstatus or windowlist. See the *QSTRING ESCAPES*U chapter for the syntax of the modifiers. The default for monitor is currently *Q=b *U (bold, active colors), for bell *Q=ub *U (underline, bold and active colors), and *Q=u *U for silence. 
<p class="level1">
<p class="level1"><span Class="bold">reset</span> 
<p class="level1">Reset the virtual terminal to its *Qpower-on*U values. Useful when strange settings (like scroll regions or graphics character set) are left over from an application. 
<p class="level1">
<p class="level1"><span Class="bold">resize</span> 
<p class="level1">Resize the current region. The space will be removed from or added to the region below or if there's not enough space from the region above. 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">resize +N	increase current region height by N 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">resize -N	decrease current region height by N 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">resize  N	set current region height to N 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">resize  =	make all windows equally high 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">resize  max	maximize current region height 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">resize  min	minimize current region height 
<p class="level1">
<p class="level1">
<p class="level1"><span Class="bold">screen [-opts] [n] [cmd [args]|\fB//group]</span> 
<p class="level1">Establish a new window. The flow-control options (<span Class="bold">-f</span>, <span Class="bold">-fn</span> and <span Class="bold">-fa</span>), title (a.|k.|a.) option (<span Class="bold">-t</span>), login options (<span Class="bold">-l</span> and <span Class="bold">-ln</span>) , terminal type option (<span Class="bold">-T</span> &lt;term&gt;), the all-capability-flag (<span Class="bold">-a</span>) and scrollback option (<span Class="bold">-h</span> &lt;num&gt;) may be specified with each command. The option (<span Class="bold">-M</span>) turns monitoring on for this window. The option (<span Class="bold">-L</span>) turns output logging on for this window. If an optional number <a class="emphasis" href="#n">n</a> in the range 0..MAXWIN-1 is given, the window number <a class="emphasis" href="#n">n</a> is assigned to the newly created window (or, if this number is already in-use, the next available number). If a command is specified after *Qscreen*U, this command (with the given arguments) is started in the window; otherwise, a shell is created. If <span Class="bold">//group</span> is supplied, a container-type window is created in which other windows may be created inside it.  
<p class="level1">Thus, if your *Q.screenrc*U contains the lines 
<p class="level1"><pre class="level1">
	&#35; example for .screenrc:
	screen 1
	screen -fn -t foobar -L 2 telnet foobar
</pre>

<p class="level1">
<p class="level1"><span Class="emphasis">screen</span> creates a shell window (in window &#35;1) and a window with a TELNET connection to the machine foobar (with no flow-control using the title *Qfoobar*U in window &#35;2) and will write a logfile (*Qscreenlog.2*U) of the telnet  session. Note, that unlike previous versions of <span Class="emphasis">screen</span> no additional default window is created when *Qscreen*U commands are  included in your *Q.screenrc*U file. When the initialization is completed, <span Class="emphasis">screen</span> switches to the last window specified in your .screenrc file or, if none, opens a default window &#35;0. <br>Screen has built in some functionality of *Qcu*U and *Qtelnet*U. See also chapter *QWINDOW TYPES*U. 
<p class="level1">
<p class="level1"><span Class="bold">scrollback num</span> 
<p class="level1">Set the size of the scrollback buffer for the current windows to <span Class="emphasis">num</span>  lines. The default scrollback is 100 lines. See also the *Qdefscrollback*U command and use *Qinfo*U to view the current setting. To access and use the contents in the scrollback buffer, use the *Qcopy*U command. 
<p class="level1">
<p class="level1"><span Class="manpage">select  [ \fIWindowID ]</span>
<p class="level1">Switch to the window identified by <span Class="emphasis">WindowID</span>. This can be a prefix of a window title (alphanumeric window name) or a window number. The parameter is optional and if omitted, you get prompted for an identifier.  When a new window is established, the first available number is assigned to this window. Thus, the first window can be activated by *Qselect 0*U. The number of windows is limited at compile-time by the MAXWIN configuration parameter (which defaults to 40). There are two special WindowIDs, *Q-*U selects the internal blank window and *Q.*U selects the current window. The latter is useful if used with screen's *Q-X*U option. 
<p class="level1">
<p class="level1"><span Class="manpage">sessionname  [ \fIname ]</span>
<p class="level1">Rename the current session. Note, that for *Qscreen -list*U the name shows up with the process-id prepended. If the argument *Qname*U is omitted, the name of this session is displayed. Caution: The $STY  environment variables will still reflect the old name in pre-existing shells. This may result in confusion. Use of this command is generally discouraged. Use the *Q-S*U command-line option if you want to name a new session. The default is constructed from the tty and host names. 
<p class="level1">
<p class="level1"><span Class="bold">setenv  </span> 
<p class="level1">
<p class="level1">Set the environment variable <span Class="emphasis">var</span> to value <span Class="emphasis">string</span>. If only <span Class="emphasis">var</span> is specified, the user will be prompted to enter a value. If no parameters are specified, the user will be prompted for both variable and value. The environment is inherited by all subsequently forked shells. 
<p class="level1">
<p class="level1"><span Class="manpage">setsid  [ on | off ]</span>
<p class="level1">Normally screen uses different sessions and process groups for the windows. If setsid is turned <span Class="emphasis">off</span>, this is not done anymore and all windows will be in the same process group as the screen backend process. This also breaks job-control, so be careful. The default is <span Class="emphasis">on</span>, of course. This command is probably useful only in rare circumstances. 
<p class="level1">
<p class="level1"><span Class="bold">shell command</span> 
<p class="level1">Set the command to be used to create a new shell. This overrides the value of the environment variable $SHELL. This is useful if you'd like to run a tty-enhancer which is expecting to execute the program specified in $SHELL.  If the command begins with a '-' character, the shell will be started as a login-shell. Typical shells do only minimal initialization when not started as a login-shell. E.g. Bash will not read your *Q~/.bashrc*U unless it is a login-shell. 
<p class="level1">
<p class="level1"><span Class="bold">shelltitle title</span> 
<p class="level1">Set the title for all shells created during startup or by the C-A C-c command. For details about what a title is, see the discussion entitled *QTITLES (naming windows)*U. 
<p class="level1">
<p class="level1"><span Class="manpage">silence  [ on | off |\fIsec\fP]</span>
<p class="level1">Toggles silence monitoring of windows. When silence is turned on and an affected window is switched into the background, you will receive the silence notification message in the status line after a specified period of inactivity (silence). The default timeout can be changed with the `silencewait' command or by specifying a  number of seconds instead of `on' or `off'. Silence is initially off for all windows. 
<p class="level1">
<p class="level1"><span Class="bold">silencewait  sec</span> 
<p class="level1">Define the time that all windows monitored for silence should wait before displaying a message. Default 30 seconds. 
<p class="level1">
<p class="level1"><span Class="bold">sleep num</span> 
<p class="level1">This command will pause the execution of a .screenrc file for <span Class="emphasis">num</span> seconds. Keyboard activity will end the sleep. It may be used to give users a chance to read the messages output by *Qecho*U. 
<p class="level1">
<p class="level1"><span Class="bold">slowpaste msec</span> 
<p class="level1">Define the speed at which text is inserted into the current window by the  paste ("C-a ]") command.  If the slowpaste value is nonzero text is written character by character. <span Class="emphasis">screen</span> will make a pause of <span Class="emphasis">msec</span> milliseconds after each single character write  to allow the application to process its input. Only use slowpaste if your  underlying system exposes flow control problems while pasting large amounts of  text.  
<p class="level1">
<p class="level1"><span Class="bold">source  file</span> 
<p class="level1">Read and execute commands from file <span Class="emphasis">file</span>. Source commands may be nested to a maximum recursion level of ten. If file is not an absolute path and screen is already processing a source command, the parent directory of the running source command file is used to search for the new command file before screen's current directory. 
<p class="level1">Note that termcap/terminfo/termcapinfo commands only work at startup and reattach time, so they must be reached via the default screenrc files to have an effect. 
<p class="level1">
<p class="level1"><span Class="bold">sorendition</span> 
<p class="level1">
<p class="level1">This command is deprecated. See "rendition so" instead. 
<p class="level1">
<p class="level1"><span Class="bold">split</span> 
<p class="level1">
<p class="level1">Split the current region into two new ones. All regions on the display are resized to make room for the new region. The blank window is displayed on the new region. Splits are made horizontally unless -v is used. Use the *Qremove*U or the *Qonly*U command to delete regions. Use *Qfocus*U to toggle between regions. 
<p class="level1">
<p class="level1"><span Class="bold">startup_message on|\fBoff</span> 
<p class="level1">Select whether you want to see the copyright notice during startup. Default is `on', as you probably noticed. 
<p class="level1">
<p class="level1"><span Class="bold">stuff </span> 
<p class="level1">
<p class="level1">Stuff the string <span Class="emphasis">string</span> in the input buffer of the current window. This is like the *Qpaste*U command but with much less overhead. Without a parameter, screen will prompt for a string to stuff. You cannot paste large buffers with the *Qstuff*U command. It is most useful for key bindings. See also *Qbindkey*U. 
<p class="level1">
<p class="level1"><span Class="bold">su</span> 
<p class="level1">
<p class="level1">
<p class="level1">Substitute the user of a display. The command prompts for all parameters that are omitted. If passwords are specified as parameters, they have to be specified un-crypted. The first password is matched against the systems passwd database, the second password is matched against the  <span Class="emphasis">screen</span> password as set with the commands *Qacladd*U or *Qpassword*U. *QSu*U may be useful for the  <span Class="emphasis">screen</span> administrator to test multiuser setups. When the identification fails, the user has access to the commands available for user <span Class="manpage">nobody .</span>These are *Qdetach*U, *Qlicense*U, *Qversion*U, *Qhelp*U and *Qdisplays*U. 
<p class="level1">
<p class="level1"><span Class="bold">suspend</span> 
<p class="level1">Suspend <span Class="emphasis">screen .</span> The windows are in the `detached' state, while  <span Class="emphasis">screen</span> is suspended. This feature relies on the shell being able to do job control. 
<p class="level1">
<p class="level1"><span Class="bold">term term</span> 
<p class="level1">In each window's environment <span Class="emphasis">screen</span> opens, the $TERM variable is set to *Qscreen*U by default.  But when no description for *Qscreen*U is installed in the local termcap or terminfo data base, you set $TERM to - say - *Qvt100*U. This won't do much harm, as  <span Class="emphasis">screen</span> is VT100/ANSI compatible. The use of the *Qterm*U command is discouraged for non-default purpose. That is, one may want to specify special $TERM settings (e.g. vt100) for the next *Qscreen rlogin othermachine*U command. Use the command *Qscreen -T vt100 rlogin othermachine*U rather than setting and resetting the default. 
<p class="level1">
<p class="level1"><span Class="bold">termcap  term terminal-tweaks</span> 
<p class="level1"><br><span Class="bold">terminfo  term terminal-tweaks</span> 
<p class="level1"><br><span Class="bold">termcapinfo  term terminal-tweaks</span> 
<p class="level1">
<p class="level1">Use this command to modify your terminal's termcap entry without going through all the hassles involved in creating a custom termcap entry. Plus, you can optionally customize the termcap generated for the windows. You have to place these commands in one of the screenrc startup files, as they are meaningless once the terminal emulator is booted.   <br>If your system works uses the terminfo database rather than termcap,  <span Class="emphasis">screen </span> will understand the `terminfo' command, which has the same effects as the `termcap' command.  Two separate commands are provided, as there are subtle syntactic differences, e.g. when parameter interpolation (using `%') is required. Note that termcap names of the capabilities have to be used with the `terminfo' command.  <br>In many cases, where the arguments are valid in both terminfo and termcap syntax, you can use the command `termcapinfo', which is just a shorthand for a pair of `termcap' and `terminfo' commands with identical arguments. 
<p class="level1">The first argument specifies which terminal(s) should be affected by this definition. You can specify multiple terminal names by separating them with `|'s. Use `*' to match all terminals and `vt*' to match all terminals that begin with *Qvt*U. 
<p class="level1">Each <span Class="emphasis">tweak</span> argument contains one or more termcap defines (separated by `:'s) to be inserted at the start of the appropriate termcap entry, enhancing it or overriding existing values. The first tweak modifies your terminal's termcap, and contains definitions that your terminal uses to perform certain functions. Specify a null string to leave this unchanged (e.|g. ''). The second (optional) tweak modifies all the window termcaps, and should contain definitions that <span Class="emphasis">screen</span> understands (see the *QVIRTUAL TERMINAL*U section). 
<p class="level1">Some examples: 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">termcap xterm*  LP:hs@ 
<p class="level1">Informs <span Class="emphasis">screen</span> that all terminals that begin with `xterm' have firm auto-margins that allow the last position on the screen to be updated (LP), but they don't really have a status line (no 'hs' - append `@' to turn entries off). Note that we assume `LP' for all terminal names that start with *Qvt*U, but only if you don't specify a termcap command for that terminal. 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">termcap vt*  LP <br>termcap vt102|vt220  Z0=eE[?3h:Z1=eE[?3l 
<p class="level1">Specifies the firm-margined `LP' capability for all terminals that begin with `vt', and the second line will also add the escape-sequences to switch into (Z0) and back out of (Z1) 132-character-per-line mode if this is a VT102 or VT220. (You must specify Z0 and Z1 in your termcap to use the width-changing commands.) 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">termcap vt100  ""  l0=PF1:l1=PF2:l2=PF3:l3=PF4 
<p class="level1">This leaves your vt100 termcap alone and adds the function key labels to each window's termcap entry. 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">termcap h19|z19  am@:im=eE@:ei=eEO  dc=eE[P 
<p class="level1">Takes a h19 or z19 termcap and turns off auto-margins (am@) and enables the insert mode (im) and end-insert (ei) capabilities (the `@' in the `im' string is after the `=', so it is part of the string). Having the `im' and `ei' definitions put into your terminal's termcap will cause <span Class="emphasis">screen</span> to automatically advertise the character-insert capability in each window's termcap. Each window will also get the delete-character capability (dc) added to its termcap, which <span Class="emphasis">screen</span> will translate into a line-update for the terminal (we're pretending it doesn't support character deletion). 
<p class="level1">If you would like to fully specify each window's termcap entry, you should instead set the $SCREENCAP variable prior to running <span Class="emphasis">screen .</span> See the discussion on the *QVIRTUAL TERMINAL*U in this manual, and the termcap(5) man page for more information on termcap definitions. 
<p class="level1">
<p class="level1"><span Class="bold">time</span> 
<p class="level1">
<p class="level1">Uses the message line to display the time of day, the host name, and the load averages over 1, 5, and 15 minutes (if this is available on your system). For window specific information, use *Qinfo*U. 
<p class="level1">If a string is specified, it changes the format of the time report like it is described in the *QSTRING ESCAPES*U chapter. Screen uses a default of "%c:%s %M %d %H%? %l%?". 
<p class="level1">
<p class="level1"><span Class="manpage">title  [ \fIwindowtitle ]</span>
<p class="level1">Set the name of the current window to <span Class="emphasis">windowtitle</span>. If no name is  specified, <span Class="emphasis">screen</span> prompts for one. This command was known as `aka' in previous releases. 
<p class="level1">
<p class="level1"><span Class="bold">unbindall </span> 
<p class="level1">Unbind all the bindings. This can be useful when screen is used solely for its detaching abilities, such as when letting a console application run as a daemon. If, for some reason, it is necessary to bind commands after this, use 'screen -X'. 
<p class="level1">
<p class="level1"><span Class="bold">unsetenv  var</span> 
<p class="level1">Unset an environment variable. 
<p class="level1">
<p class="level1"><span Class="bold">utf8</span> 
<p class="level1">
<p class="level1">
<p class="level1">Change the encoding used in the current window. If utf8 is enabled, the strings sent to the window will be UTF-8 encoded and vice versa. Omitting the parameter toggles the setting. If a second parameter is given, the display's encoding is also changed (this should rather be done with screen's *Q-U*U option). See also *Qdefutf8*U, which changes the default setting of a new window. 
<p class="level1">
<p class="level1"><span Class="bold">vbell </span> 
<p class="level1">
<p class="level1">Sets the visual bell setting for this window. Omitting the parameter toggles the setting. If vbell is switched on, but your terminal does not  support a visual bell, a `vbell-message' is displayed in the status line when the bell character (^G) is received. Visual bell support of a terminal is defined by the termcap variable `vb'  (terminfo: 'flash').  <br>Per default, vbell is off, thus the audible bell is used.  See also `bell_msg'. 
<p class="level1">
<p class="level1"><span Class="bold">vbell_msg</span> 
<p class="level1">
<p class="level1">Sets the visual bell message. <span Class="emphasis">message</span> is printed to the status line if the window receives a bell character (^G), vbell is set to *Qon*U, but the  terminal does not support a visual bell. The default message is *QWuff, Wuff!!*U. Without a parameter, the current message is shown. 
<p class="level1">
<p class="level1"><span Class="bold">vbellwait  sec</span> 
<p class="level1">Define a delay in seconds after each display of  <span Class="emphasis">screen 's</span> visual bell message. The default is 1 second. 
<p class="level1">
<p class="level1"><span Class="bold">verbose</span> 
<p class="level1">
<p class="level1">If verbose is switched on, the command name is echoed, whenever a window is created (or resurrected from zombie state). Default is off. Without a parameter, the current setting is shown. 
<p class="level1">
<p class="level1"><span Class="bold">version</span> 
<p class="level1">Print the current version and the compile date in the status line. 
<p class="level1">
<p class="level1"><span Class="bold">wall  message</span> 
<p class="level1">Write a message to all displays. The message will appear in the terminal's status line. 
<p class="level1">
<p class="level1"><span Class="bold">width</span> 
<p class="level1">
<p class="level1">
<p class="level1">Toggle the window width between 80 and 132 columns or set it to <span Class="emphasis">cols</span>  columns if an argument is specified.  This requires a capable terminal and the termcap entries *QZ0*U and *QZ1*U. See the *Qtermcap*U command for more information. You can also specify a new height if you want to change both values. The <span Class="bold">-w</span> option tells screen to leave the display size unchanged and just set the window size, <span Class="bold">-d</span> vice versa. 
<p class="level1">
<p class="level1"><span Class="bold">windowlist</span> 
<p class="level1">
<p class="level1">
<p class="level1"><br><span Class="bold">windowlist</span> <span Class="bold">string</span> 
<p class="level1"><br><span Class="bold">windowlist</span> <span Class="bold">title</span> 
<p class="level1">
<p class="level1">Display all windows in a table for visual window selection. If screen was in a window group, screen will back out of the group and then display the windows in that group. If the  <span Class="bold">-b</span> option is given, screen will switch to the blank window before presenting the list, so that the current window is also selectable. The <span Class="bold">-m</span> option changes the order of the windows, instead of sorting by window numbers screen uses its internal most-recently-used list. The <span Class="bold">-g</span> option will show the windows inside any groups in that level and downwards. 
<p class="level1">The following keys are used to navigate in *Qwindowlist*U: <br>
<p class="level1">
<p class="level1"><a class="bold" href="#k">k</a>, <span Class="bold">C-p</span>, or <span Class="bold">up</span> Move up one line. <br>
<p class="level1"><span Class="bold">j</span>, <span Class="bold">C-n</span>, or <span Class="bold">down</span> Move down one line. <br>
<p class="level1"><span Class="bold">C-g</span> or <span Class="bold">escape</span> Exit windowlist. <br>
<p class="level1"><span Class="bold">C-a</span> or <span Class="bold">home</span> Move to the first line. <br>
<p class="level1"><span Class="bold">C-e</span> or <span Class="bold">end</span> Move to the last line. <br>
<p class="level1"><span Class="bold">C-u</span> or <span Class="bold">C-d</span> Move one half page up or down. <br>
<p class="level1"><span Class="bold">C-b</span> or <span Class="bold">C-f</span> Move one full page up or down. <br>
<p class="level1"><span Class="bold">0..9</span> Using the number keys, move to the selected line. <br>
<p class="level1"><span Class="bold">mouseclick</span> Move to the selected line. Available when *Qmousetrack*U is set to *Qon*U <br>
<p class="level1"><a class="bold" href="#">/</a> Search. <br>
<p class="level1"><a class="bold" href="#n">n</a> Repeat search in the forward direction. <br>
<p class="level1"><span Class="bold">N</span> Repeat search in the backward direction. <br>
<p class="level1"><a class="bold" href="#m">m</a> Toggle MRU. <br>
<p class="level1"><a class="bold" href="#g">g</a> Toggle group nesting. <br>
<p class="level1"><a class="bold" href="#a">a</a> All window view. <br>
<p class="level1"><span Class="bold">C-h</span> or backspace Back out the group. <br>
<p class="level1"><a class="bold" href="#">,</a> Switch numbers with the previous window. <br>
<p class="level1"><a class="bold" href="#">.</a> Switch numbers with the next window. <br>
<p class="level1"><span Class="bold">K</span> Kill that window. <br>
<p class="level1"><span Class="bold">space</span> or <span Class="bold">enter</span> Select that window. <br>
<p class="level1">
<p class="level1">The table format can be changed with the <span Class="bold">string</span> and <span Class="bold">title</span> option, the title is displayed as table heading, while the lines are made by using the string setting. The default setting is *QNum Name%=Flags*U for the title and *Q%3n %t%=%f*U for the lines. See the *QSTRING ESCAPES*U chapter for more codes (e.g. color settings). 
<p class="level1">*QWindowlist*U needs a region size of at least 10 characters wide and 6 characters high in order to display. 
<p class="level1">
<p class="level1"><span Class="bold">windows</span> 
<p class="level1">Uses the message line to display a list of all the windows. Each window is listed by number with the name of process that has been started in the window (or its title); the current window is marked with a `*'; the previous window is marked with a `-'; all the windows that are *Qlogged in*U are marked with a `$'; a background window that has received a bell is marked with a `!'; a background window that is being monitored and has had activity occur is marked with an `@'; a window which has output logging turned on is marked with `(L)';  windows occupied by other users are marked with `&'; windows in the zombie state are marked with `Z'. If this list is too long to fit on the terminal's status line only the portion around the current window is displayed. 
<p class="level1">
<p class="level1"><span Class="manpage">wrap  [ on | off ]</span>
<p class="level1">Sets the line-wrap setting for the current window. When line-wrap is on, the second consecutive printable character output at the last column of a line will wrap to the start of the following line. As an added feature, backspace (^H) will also wrap through the left margin to the previous line. Default is `on'. Without any options, the state of wrap is toggled. 
<p class="level1">
<p class="level1"><span Class="bold">writebuf</span> 
<p class="level1"><span Class="emphasis">encoding ]</span> 
<p class="level1">
<p class="level1">Writes the contents of the paste buffer to the specified file, or the public accessible screen-exchange file if no filename is given. This is thought of as a primitive means of communication between <span Class="emphasis">screen</span> users on the same host. If an encoding is specified the paste buffer is recoded on the fly to match the encoding. The filename can be set with the <span Class="emphasis">bufferfile</span> command and defaults to *Q/tmp/screen-exchange*U. 
<p class="level1">
<p class="level1"><span Class="manpage">writelock  [ on | off\fR|\fBauto\fR]</span>
<p class="level1">In addition to access control lists, not all users may be able to write to the same window at once. Per default, writelock is in `auto' mode and grants exclusive input permission to the user who is the first to switch to the particular window. When he leaves the window, other users may obtain the writelock (automatically). The writelock of the current window is disabled by the command *Qwritelock off*U. If the user issues the command  *Qwritelock on*U he keeps the exclusive write permission while switching to other windows. 
<p class="level1">
<p class="level1"><span Class="bold">xoff</span> <br><span Class="bold">xon</span> 
<p class="level1">Insert a CTRL-s / CTRL-q character to the stdin queue of the current window. 
<p class="level1">
<p class="level1"><span Class="bold">zmodem</span> 
<p class="level1"><br><span Class="bold">zmodem sendcmd</span> 
<p class="level1"><br><span Class="bold">zmodem recvcmd</span> 
<p class="level1">
<p class="level1">Define zmodem support for screen. Screen understands two different modes when it detects a zmodem request: *Qpass*U and *Qcatch*U. If the mode is set to *Qpass*U, screen will relay all data to the attacher until the end of the transmission is reached. In *Qcatch*U mode screen acts as a zmodem endpoint and starts the corresponding rz/sz commands. If the mode is set to *Qauto*U, screen will use *Qcatch*U if the window is a tty (e.g. a serial line), otherwise it will use *Qpass*U. <br>You can define the templates screen uses in *Qcatch*U mode via the second and the third form. <br>Note also that this is an experimental feature. 
<p class="level1">
<p class="level1"><span Class="manpage">zombie  [\fIkeys\fP [ onerror ] ]</span><br><span Class="manpage">defzombie  [\fIkeys\fP]</span>
<p class="level1">Per default <span Class="emphasis">screen </span> windows are removed from the window list as soon as the windows process (e.g. shell) exits. When a string of two keys is  specified to the zombie command, `dead' windows will remain in the list. The <span Class="bold">kill</span> command may be used to remove such a window. Pressing the  first key in the dead window has the same effect. When pressing the second  key,  <span Class="emphasis">screen </span> will attempt to resurrect the window. The process that was  initially running in the window will be launched again. Calling <span Class="bold">zombie</span> without parameters will clear the zombie setting, thus making windows disappear  when their process exits. 
<p class="level1">As the zombie-setting is manipulated globally for all windows, this command  should only be called <span Class="bold">defzombie</span>. Until we need this as a per window  setting, the commands <span Class="bold">zombie</span> and <span Class="bold">defzombie</span> are synonymous. 
<p class="level1">Optionally you can put the word *Qonerror*U after the keys. This will cause screen to monitor exit status of the process running in the window. If it exits normally ('0'),  the window disappears. Any other exit value causes the window to become a zombie. 
<p class="level1"><a name="THE"></a><h2 class="nroffsh">THE MESSAGE LINE</h2>
<p class="level0"><span Class="emphasis">Screen</span> displays informational messages and other diagnostics in a <span Class="emphasis">message line</span>. While this line is distributed to appear at the bottom of the screen, it can be defined to appear at the top of the screen during compilation. If your terminal has a status line defined in its termcap, <span Class="emphasis">screen</span> will use this for displaying its messages, otherwise a line of the current screen will be temporarily overwritten and output will be momentarily interrupted. The message line is automatically removed after a few seconds delay, but it can also be removed early (on terminals without a status line) by beginning to type. 
<p class="level0">The message line facility can be used by an application running in the current window by means of the ANSI <span Class="emphasis">Privacy message</span> control sequence. For instance, from within the shell, try something like: 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">echo '&lt;esc&gt;^Hello world from window '$WINDOW'&lt;esc&gt;ee' 
<p class="level1">where '&lt;esc&gt;' is an <span Class="emphasis">escape</span>, '^' is a literal up-arrow, and 'ee' turns into a single backslash. 
<p class="level1"><a name="WINDOW"></a><h2 class="nroffsh">WINDOW TYPES</h2>
<p class="level0">Screen provides three different window types. New windows are created with  <span Class="emphasis">screen 's</span> <span Class="bold">screen</span> command (see also the entry in chapter *QCUSTOMIZATION*U). The first parameter to the  <span Class="bold">screen</span> command defines which type of window is created. The different window types are all special cases of the normal type. They have been added in order to allow  <span Class="emphasis">screen </span> to be used efficiently as a console multiplexer with 100 or more windows. 
<p class="level0">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 3</span> 
<p class="level1">The normal window contains a shell (default, if no parameter is given) or any other system command that could be executed from a shell (e.g.   <span Class="manpage">slogin</span>etc…) 
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1">If a tty (character special device) name (e.g. *Q/dev/ttya*U) is specified as the first parameter, then the window is directly connected to this device.  This window type is similar to *Qscreen cu -l /dev/ttya*U. Read and write access is required on the device node, an exclusive open is attempted on the node to mark the connection line as busy. An optional parameter is allowed consisting of a comma separated list of flags in the notation used by stty(1): 
<p class="level2">
<p class="level1"><a name="baudrate"></a><span class="nroffip">&lt;baud_rate&gt;		</span> 
<p class="level2">Usually 300, 1200, 9600 or 19200. This affects transmission as well as receive speed. 
<p class="level1"><a name="cs8"></a><span class="nroffip">cs8 or cs7</span> 
<p class="level2">Specify the transmission of eight (or seven) bits per byte. 
<p class="level1"><a name="ixon"></a><span class="nroffip">ixon or -ixon</span> 
<p class="level2">Enables (or disables) software flow-control (CTRL-S/CTRL-Q) for sending data. 
<p class="level1"><a name="ixoff"></a><span class="nroffip">ixoff or -ixoff</span> 
<p class="level2">Enables (or disables) software flow-control for receiving data. 
<p class="level1"><a name="istrip"></a><span class="nroffip">istrip or -istrip</span> 
<p class="level2">Clear (or keep) the eight bit in each received byte. 
<p class="level2">You may want to specify as many of these options as applicable. Unspecified options cause the terminal driver to make up the parameter values of the connection.  These values are system dependent and may be in defaults or values saved from a previous connection. 
<p class="level2">For tty windows, the  <span Class="bold">info</span> command shows some of the modem control lines in the status line. These may include `RTS', `CTS', 'DTR', `DSR', `CD' and more. This depends on the available ioctl()'s and system header files as well as the on the physical capabilities of the serial board.  Signals that are logical low (inactive) have their name preceded by an exclamation mark (!), otherwise the signal is logical high (active). Signals not supported by the hardware but available to the ioctl() interface are usually shown low.  
<p class="level2">When the CLOCAL status bit is true, the whole set of modem signals is placed  inside curly braces ({ and }). When the CRTSCTS or TIOCSOFTCAR bit is set, the signals `CTS' or `CD'  are shown in parenthesis, respectively.  
<p class="level2">For tty windows, the command <span Class="bold">break</span> causes the Data transmission line (TxD) to go low for a specified period of time. This is expected to be interpreted as break signal on the other side. No data is sent and no modem control line is changed when a  <span Class="bold">break</span> is issued. 
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1">If the first parameter is *Q//telnet*U, the second parameter is expected to be a host name, and an optional third parameter may specify a TCP port number (default decimal 23).  Screen will connect to a server listening on the remote host and use the telnet protocol to communicate with that server. <br><br>For telnet windows, the command <span Class="bold">info</span> shows details about the connection in square brackets ([ and ]) at the end of the status line.  
<p class="level2">
<p class="level1"><a name="b"></a><span class="nroffip">b</span> 
<p class="level2">BINARY. The connection is in binary mode. 
<p class="level1"><a name="e"></a><span class="nroffip">e</span> 
<p class="level2">ECHO. Local echo is disabled. 
<p class="level1"><a name="c"></a><span class="nroffip">c</span> 
<p class="level2">SGA. The connection is in `character mode' (default: `line mode'). 
<p class="level1"><a name="t"></a><span class="nroffip">t</span> 
<p class="level2">TTYPE. The terminal type has been requested by the remote host. Screen sends the name *Qscreen*U unless instructed otherwise (see also the command `term'). 
<p class="level1"><a name="w"></a><span class="nroffip">w</span> 
<p class="level2">NAWS. The remote site is notified about window size changes. 
<p class="level1"><a name="f"></a><span class="nroffip">f</span> 
<p class="level2">LFLOW. The remote host will send flow control information. (Ignored at the moment.) 
<p class="level2">Additional flags for debugging are x, t and n (XDISPLOC, TSPEED and NEWENV). 
<p class="level2">For telnet windows, the command <span Class="bold">break</span> sends the telnet code IAC BREAK (decimal 243) to the remote host. 
<p class="level2">
<p class="level2">This window type is only available if <span Class="emphasis">screen</span> was compiled with the BUILTIN_TELNET option defined. 
<p class="level1">
<p class="level1">
<p class="level1"><a name="STRING"></a><h2 class="nroffsh">STRING ESCAPES</h2>
<p class="level0">Screen provides an escape mechanism to insert information like the current time into messages or file names. The escape character is '%' with one exception: inside of a window's hardstatus '^%' ('^E') is used instead. 
<p class="level0">Here is the full list of supported escapes: 
<p class="level0"><a name=""></a><span class="nroffip">%</span> 
<p class="level1">the escape character itself 
<p class="level0"><a name="a"></a><span class="nroffip">a</span> 
<p class="level1">either 'am' or 'pm' 
<p class="level0"><a name="A"></a><span class="nroffip">A</span> 
<p class="level1">either 'AM' or 'PM' 
<p class="level0"><a name="c"></a><span class="nroffip">c</span> 
<p class="level1">current time HH:MM in 24h format 
<p class="level0"><a name="C"></a><span class="nroffip">C</span> 
<p class="level1">current time HH:MM in 12h format 
<p class="level0"><a name="d"></a><span class="nroffip">d</span> 
<p class="level1">day number 
<p class="level0"><a name="D"></a><span class="nroffip">D</span> 
<p class="level1">weekday name 
<p class="level0"><a name="E"></a><span class="nroffip">E</span> 
<p class="level1">sets %? to true if the escape character has been pressed. 
<p class="level0"><a name="f"></a><span class="nroffip">f</span> 
<p class="level1">flags of the window, see *Qwindows*U for meanings of the various flags 
<p class="level0"><a name="F"></a><span class="nroffip">F</span> 
<p class="level1">sets %? to true if the window has the focus 
<p class="level0"><a name="h"></a><span class="nroffip">h</span> 
<p class="level1">hardstatus of the window 
<p class="level0"><a name="H"></a><span class="nroffip">H</span> 
<p class="level1">hostname of the system 
<p class="level0"><a name="l"></a><span class="nroffip">l</span> 
<p class="level1">current load of the system 
<p class="level0"><a name="m"></a><span class="nroffip">m</span> 
<p class="level1">month number 
<p class="level0"><a name="M"></a><span class="nroffip">M</span> 
<p class="level1">month name 
<p class="level0"><a name="n"></a><span class="nroffip">n</span> 
<p class="level1">window number 
<p class="level0"><a name="P"></a><span class="nroffip">P</span> 
<p class="level1">sets %? to true if the current region is in copy/paste mode 
<p class="level0"><a name="S"></a><span class="nroffip">S</span> 
<p class="level1">session name 
<p class="level0"><a name="s"></a><span class="nroffip">s</span> 
<p class="level1">seconds 
<p class="level0"><a name="t"></a><span class="nroffip">t</span> 
<p class="level1">window title 
<p class="level0"><a name="u"></a><span class="nroffip">u</span> 
<p class="level1">all other users on this window 
<p class="level0"><a name="w"></a><span class="nroffip">w</span> 
<p class="level1">all window numbers and names. With '-' qualifier: up to the current window; with '+' qualifier: starting with the window after the current one. 
<p class="level0"><a name="W"></a><span class="nroffip">W</span> 
<p class="level1">all window numbers and names except the current one 
<p class="level0"><a name="y"></a><span class="nroffip">y</span> 
<p class="level1">last two digits of the year number 
<p class="level0"><a name="Y"></a><span class="nroffip">Y</span> 
<p class="level1">full year number 
<p class="level0"><a name=""></a><span class="nroffip">?</span> 
<p class="level1">the part to the next '%?' is displayed only if a '%' escape inside the part expands to a non-empty string 
<p class="level0"><a name=""></a><span class="nroffip">:</span> 
<p class="level1">else part of '%?' 
<p class="level0"><a name=""></a><span class="nroffip">=</span> 
<p class="level1">pad the string to the display's width (like TeX's hfill). If a number is specified, pad to the percentage of the window's width. A '0' qualifier tells screen to treat the number as absolute position. You can specify to pad relative to the last absolute pad position by adding a '+' qualifier or to pad relative to the right margin by using '-'. The padding truncates the string if the specified position lies before the current position. Add the 'L' qualifier to change this. 
<p class="level0"><a name=""></a><span class="nroffip">&lt;</span> 
<p class="level1">same as '%=' but just do truncation, do not fill with spaces 
<p class="level0"><a name=""></a><span class="nroffip">&gt;</span> 
<p class="level1">mark the current text position for the next truncation. When screen needs to do truncation, it tries to do it in a way that the marked position gets moved to the specified percentage of the output area. (The area starts from the last absolute pad position and ends with the position specified by the truncation operator.) The 'L' qualifier tells screen to mark the truncated parts with '…'. 
<p class="level0"><a name=""></a><span class="nroffip">{</span> 
<p class="level1">attribute/color modifier string terminated by the next *Q}*U 
<p class="level0"><a name=""></a><span class="nroffip">`</span> 
<p class="level1">Substitute with the output of a 'backtick' command. The length qualifier is misused to identify one of the commands. 
<p class="level1">The 'c' and 'C' escape may be qualified with a '0' to make  <span Class="emphasis">screen </span> use zero instead of space as fill character. The '0' qualifier also makes the '=' escape use absolute positions. The 'n' and '=' escapes understand a length qualifier (e.g. '%3n'), 'D' and 'M' can be prefixed with 'L' to generate long names, 'w' and 'W' also show the window flags if 'L' is given. 
<p class="level1">An attribute/color modifier is is used to change the attributes or the color settings. Its format is *Q[attribute modifier] [color description]*U. The attribute modifier must be prefixed by a change type indicator if it can be confused with a color description. The following change types are known: 
<p class="level0"><a name=""></a><span class="nroffip">+</span> 
<p class="level1">add the specified set to the current attributes 
<p class="level0"><a name="-"></a><span class="nroffip">-</span> 
<p class="level1">remove the set from the current attributes 
<p class="level0"><a name=""></a><span class="nroffip">!</span> 
<p class="level1">invert the set in the current attributes 
<p class="level0"><a name=""></a><span class="nroffip">=</span> 
<p class="level1">change the current attributes to the specified set 
<p class="level1">The attribute set can either be specified as a hexadecimal number or a combination of the following letters: 
<p class="level0"><a name="d"></a><span class="nroffip">d</span> 
<p class="level1">dim 
<p class="level1">
<p class="level0"><a name="u"></a><span class="nroffip">u</span> 
<p class="level1">underline 
<p class="level0"><a name="b"></a><span class="nroffip">b</span> 
<p class="level1">bold 
<p class="level0"><a name="r"></a><span class="nroffip">r</span> 
<p class="level1">reverse 
<p class="level0"><a name="s"></a><span class="nroffip">s</span> 
<p class="level1">standout 
<p class="level0"><a name="B"></a><span class="nroffip">B</span> 
<p class="level1">blinking 
<p class="level1">
<p class="level1">Colors are coded either as a hexadecimal number or two letters specifying the desired background and foreground color (in that order). The following colors are known: 
<p class="level0"><a name="k"></a><span class="nroffip">k</span> 
<p class="level1">black 
<p class="level1">
<p class="level0"><a name="r"></a><span class="nroffip">r</span> 
<p class="level1">red 
<p class="level0"><a name="g"></a><span class="nroffip">g</span> 
<p class="level1">green 
<p class="level0"><a name="y"></a><span class="nroffip">y</span> 
<p class="level1">yellow 
<p class="level0"><a name="b"></a><span class="nroffip">b</span> 
<p class="level1">blue 
<p class="level0"><a name="m"></a><span class="nroffip">m</span> 
<p class="level1">magenta 
<p class="level0"><a name="c"></a><span class="nroffip">c</span> 
<p class="level1">cyan 
<p class="level0"><a name="w"></a><span class="nroffip">w</span> 
<p class="level1">white 
<p class="level0"><a name="d"></a><span class="nroffip">d</span> 
<p class="level1">default color 
<p class="level0"><a name=""></a><span class="nroffip">.</span> 
<p class="level1">leave color unchanged 
<p class="level1">
<p class="level1">The capitalized versions of the letter specify bright colors. You can also use the pseudo-color 'i' to set just the brightness and leave the color unchanged. <br>A one digit/letter color description is treated as foreground or background color dependent on the current attributes: if reverse mode is set, the background color is changed instead of the foreground color. If you don't like this, prefix the color with a *Q.*U. If you want the same behavior for two-letter color descriptions, also prefix them with a *Q.*U. <br>As a special case, *Q%{-}*U restores the attributes and colors that were set before the last change was made (i.e., pops one level of the color-change stack). 
<p class="level1">Examples: 
<p class="level0"><a name="QGU"></a><span class="nroffip">\*QG\*U</span> 
<p class="level1">set color to bright green 
<p class="level0"><a name="Qb"></a><span class="nroffip">\*Q+b r\*U</span> 
<p class="level1">use bold red 
<p class="level0"><a name="Q"></a><span class="nroffip">\*Q= yd\*U</span> 
<p class="level1">clear all attributes, write in default color on yellow background. 
<p class="level0"><a name="-Lw"></a><span class="nroffip">%-Lw%{= BW}%50&gt;%n%f* %t%{-}%+Lw%&lt;</span> 
<p class="level1">The available windows centered at the current window and truncated to the available width. The current window is displayed white on blue. This can be used with *Qhardstatus alwayslastline*U. 
<p class="level0"><a name="FR3n"></a><span class="nroffip">%?%F%{.R.}%?%3n %t%? [%h]%?</span> 
<p class="level1">The window number and title and the window's hardstatus, if one is set. Also use a red background if this is the active focus. Useful for *Qcaption string*U. <a name="FLOW-CONTROL"></a><h2 class="nroffsh">FLOW-CONTROL</h2>
<p class="level0">Each window has a flow-control setting that determines how <span Class="emphasis">screen</span> deals with the XON and XOFF characters (and perhaps the interrupt character). When flow-control is turned off, <span Class="emphasis">screen</span> ignores the XON and XOFF characters, which allows the user to send them to the current program by simply typing them (useful for the <span Class="emphasis">emacs</span> editor, for instance). The trade-off is that it will take longer for output from a *Qnormal*U program to pause in response to an XOFF. With flow-control turned on, XON and XOFF characters are used to immediately pause the output of the current window. You can still send these characters to the current program, but you must use the appropriate two-character <span Class="emphasis">screen</span> commands (typically *QC-a q*U (xon) and *QC-a s*U (xoff)). The xon/xoff commands are also useful for typing C-s and C-q past a terminal that intercepts these characters. 
<p class="level0">Each window has an initial flow-control value set with either the <span Class="bold">-f</span> option or the *Qdefflow*U .screenrc command. Per default the windows are set to automatic flow-switching. It can then be toggled between the three states 'fixed on', 'fixed off' and 'automatic' interactively with the *Qflow*U command bound to "C-a f". 
<p class="level0">The automatic flow-switching mode deals with flow control using the TIOCPKT mode (like *Qrlogin*U does). If the tty driver does not support TIOCPKT, <span Class="emphasis">screen</span> tries to find out the right mode based on the current setting of the application keypad - when it is enabled, flow-control is turned off and visa versa. Of course, you can still manipulate flow-control manually when needed. 
<p class="level0">If you're running with flow-control enabled and find that pressing the interrupt key (usually C-c) does not interrupt the display until another 6-8 lines have scrolled by, try running <span Class="emphasis">screen</span> with the *Qinterrupt*U option (add the *Qinterrupt*U flag to the *Qflow*U command in your .screenrc, or use the <span Class="bold">-i</span> command-line option). This causes the output that <span Class="emphasis">screen</span> has accumulated from the interrupted program to be flushed. One disadvantage is that the virtual terminal's memory contains the non-flushed version of the output, which in rare cases can cause minor inaccuracies in the output. For example, if you switch screens and return, or update the screen with *QC-a l*U you would see the version of the output you would have gotten without *Qinterrupt*U being on. Also, you might need to turn off flow-control (or use auto-flow mode to turn it off automatically) when running a program that expects you to type the interrupt character as input, as it is possible to interrupt the output of the virtual terminal to your physical terminal when flow-control is enabled. If this happens, a simple refresh of the screen with *QC-a l*U will restore it. Give each mode a try, and use whichever mode you find more comfortable. 
<p class="level0">
<p class="level0"><a name="TITLES"></a><h2 class="nroffsh">TITLES (naming windows)</h2>
<p class="level0">You can customize each window's name in the window display (viewed with the *Qwindows*U command (C-a w)) by setting it with one of the title commands. Normally the name displayed is the actual command name of the program created in the window. However, it is sometimes useful to distinguish various programs of the same name or to change the name on-the-fly to reflect the current state of the window. 
<p class="level0">The default name for all shell windows can be set with the *Qshelltitle*U command in the .screenrc file, while all other windows are created with a *Qscreen*U command and thus can have their name set with the <span Class="bold">-t</span> option. Interactively, there is the title-string escape-sequence (&lt;esc&gt;k<span Class="emphasis">name</span>&lt;esc&gt;e) and the *Qtitle*U command (C-a A). The former can be output from an application to control the window's name under software control, and the latter will prompt for a name when typed. You can also bind pre-defined names to keys with the *Qtitle*U command to set things quickly without prompting. 
<p class="level0">Finally, <span Class="emphasis">screen</span> has a shell-specific heuristic that is enabled by setting the window's name to *Q<span Class="emphasis">search|name</span>*U and arranging to have a null title escape-sequence output as a part of your prompt. The <span Class="emphasis">search</span> portion specifies an end-of-prompt search string, while the <span Class="emphasis">name</span> portion specifies the default shell name for the window. If the <span Class="emphasis">name</span> ends in a `:' <span Class="emphasis">screen</span> will add what it believes to be the current command running in the window to the end of the window's shell name (e.|g. *Q<span Class="emphasis">name:cmd</span>*U). Otherwise the current command name supersedes the shell name while it is running. 
<p class="level0">Here's how it works:  you must modify your shell prompt to output a null title-escape-sequence (&lt;esc&gt;k&lt;esc&gt;e) as a part of your prompt. The last part of your prompt must be the same as the string you specified for the <span Class="emphasis">search</span> portion of the title. Once this is set up, <span Class="emphasis">screen</span> will use the title-escape-sequence to clear the previous command name and get ready for the next command. Then, when a newline is received from the shell, a search is made for the end of the prompt. If found, it will grab the first word after the matched string and use it as the command name. If the command name begins with either '!', '%', or '^' <span Class="emphasis">screen</span> will use the first word on the following line (if found) in preference to the just-found name. This helps csh users get better command names when using job control or history recall commands. 
<p class="level0">Here's some .screenrc examples: 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">screen -t top 2 nice top 
<p class="level1">Adding this line to your .screenrc would start a nice-d version of the *Qtop*U command in window 2 named *Qtop*U rather than *Qnice*U. 
<p class="level1"><pre class="level1">
	shelltitle '&gt; |csh'
	screen 1
</pre>

<p class="level1">
<p class="level1">These commands would start a shell with the given shelltitle. The title specified is an auto-title that would expect the prompt and the typed command to look something like the following: 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">/usr/joe/src/dir&gt; trn 
<p class="level1">(it looks after the '&gt; ' for the command name). The window status would show the name *Qtrn*U while the command was running, and revert to *Qcsh*U upon completion. 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">bind R screen -t '% |root:' su 
<p class="level1">Having this command in your .screenrc would bind the key sequence *QC-a R*U to the *Qsu*U command and give it an auto-title name of *Qroot:*U. For this auto-title to work, the screen could look something like this: 
<p class="level1"><pre class="level1">
	% !em
	emacs file.c
</pre>

<p class="level1">
<p class="level1">Here the user typed the csh history command *Q!em*U which ran the previously entered *Qemacs*U command. The window status would show *Qroot:emacs*U during the execution of the command, and revert to simply *Qroot:*U at its completion. 
<p class="level1"><pre class="level1">
	bind o title
	bind E title ""
	bind u title (unknown)
</pre>

<p class="level1">
<p class="level1">The first binding doesn't have any arguments, so it would prompt you for a title. when you type *QC-a o*U. The second binding would clear an auto-title's current setting (C-a E). The third binding would set the current window's title to *Q(unknown)*U (C-a u). 
<p class="level1">One thing to keep in mind when adding a null title-escape-sequence to your prompt is that some shells (like the csh) count all the non-control characters as part of the prompt's length. If these invisible characters aren't a multiple of 8 then backspacing over a tab will result in an incorrect display. One way to get around this is to use a prompt like this: 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">set prompt='^[[0000m^[k^[e% ' 
<p class="level1">The escape-sequence *Q&lt;esc&gt;[0000m*U not only normalizes the character attributes, but all the zeros round the length of the invisible characters up to 8. Bash users will probably want to echo the escape sequence in the PROMPT_COMMAND: 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">PROMPT_COMMAND='printf "e033ke033e134"' 
<p class="level1">(I used *Q134*U to output a `e' because of a bug in bash v1.04). 
<p class="level1">
<p class="level1"><a name="THE"></a><h2 class="nroffsh">THE VIRTUAL TERMINAL</h2>
<p class="level0">Each window in a  <span Class="emphasis">screen</span> session emulates a VT100 terminal, with some extra functions added. The VT100 emulator is hard-coded, no other terminal types can be emulated. <br>Usually <span Class="emphasis">screen</span> tries to emulate as much of the VT100/ANSI standard as possible. But if your terminal lacks certain capabilities, the emulation may not be complete. In these cases <span Class="emphasis">screen</span> has to tell the applications that some of the features are missing. This is no problem on machines using termcap, because <span Class="emphasis">screen</span> can use the $TERMCAP variable to customize the standard <span Class="emphasis">screen</span> termcap. 
<p class="level0">But if you do a rlogin on another machine or your machine supports only terminfo this method fails. Because of this, <span Class="emphasis">screen</span> offers a way to deal with these cases.  Here is how it works: 
<p class="level0">When  <span Class="emphasis">screen</span> tries to figure out a terminal name for itself, it first looks for an entry named *Qscreen.&lt;term&gt;*U, where &lt;term&gt; is the contents of your $TERM variable. If no such entry exists, <span Class="emphasis">screen</span> tries *Qscreen*U (or *Qscreen-w*U if the terminal is wide (132 cols or more)). If even this entry cannot be found, *Qvt100*U is used as a substitute. 
<p class="level0">The idea is that if you have a terminal which doesn't support an important feature (e.g. delete char or clear to EOS) you can build a new termcap/terminfo entry for <span Class="emphasis">screen</span> (named *Qscreen.&lt;dumbterm&gt;*U) in which this capability has been disabled. If this entry is installed on your machines you are able to do a rlogin and still keep the correct termcap/terminfo entry. The terminal name is put in the $TERM variable of all new windows. <span Class="emphasis">Screen</span> also sets the $TERMCAP variable reflecting the capabilities of the virtual terminal emulated. Notice that, however, on machines using the terminfo database this variable has no effect. Furthermore, the variable $WINDOW is set to the window number of each window. 
<p class="level0">The actual set of capabilities supported by the virtual terminal depends on the capabilities supported by the physical terminal. If, for instance, the physical terminal does not support underscore mode, <span Class="emphasis">screen</span> does not put the `us' and `ue' capabilities into the window's $TERMCAP variable, accordingly. However, a minimum number of capabilities must be supported by a terminal in order to run <span Class="emphasis">screen ;</span> namely scrolling, clear screen, and direct cursor addressing (in addition, <span Class="emphasis">screen</span> does not run on hardcopy terminals or on terminals that over-strike). 
<p class="level0">Also, you can customize the $TERMCAP value used by <span Class="emphasis">screen</span> by using the *Qtermcap*U .screenrc command, or by defining the variable $SCREENCAP prior to startup. When the is latter defined, its value will be copied verbatim into each window's $TERMCAP variable. This can either be the full terminal definition, or a filename where the terminal *Qscreen*U (and/or *Qscreen-w*U) is defined. 
<p class="level0">Note that  <span Class="emphasis">screen</span> honors the *Qterminfo*U .screenrc command if the system uses the terminfo database rather than termcap. 
<p class="level0">When the boolean `G0' capability is present in the termcap entry for the terminal on which <span Class="emphasis">screen</span> has been called, the terminal emulation of <span Class="emphasis">screen</span> supports multiple character sets. This allows an application to make use of, for instance, the VT100 graphics character set or national character sets. The following control functions from ISO 2022 are supported: <span Class="emphasis">lock shift G0</span> (<span Class="emphasis">SI</span>), <span Class="emphasis">lock shift G1</span> (<span Class="emphasis">SO</span>), <span Class="emphasis">lock shift G2</span>, <span Class="emphasis">lock shift G3</span>, <span Class="emphasis">single shift G2</span>, and <span Class="emphasis">single shift G3</span>. When a virtual terminal is created or reset, the ASCII character set is designated as <span Class="emphasis">G0</span> through <span Class="emphasis">G3</span>. When the `G0' capability is present, <span Class="emphasis">screen</span> evaluates the capabilities `S0', `E0', and `C0' if present. `S0' is the sequence the terminal uses to enable and start the graphics character set rather than <span Class="emphasis">SI</span>.  `E0' is the corresponding replacement for <span Class="emphasis">SO</span>. `C0' gives a character by character translation string that is used during semi-graphics mode. This  string is built like the `acsc' terminfo capability. 
<p class="level0">When the `po' and `pf' capabilities are present in the terminal's termcap entry, applications running in a <span Class="emphasis">screen</span> window can send output to the printer port of the terminal. This allows a user to have an application in one window sending output to a printer connected to the terminal, while all other windows are still active (the printer port is enabled and disabled again for each chunk of output). As a side-effect, programs running in different windows can send output to the printer simultaneously. Data sent to the printer is not displayed in the window.  The  <span Class="emphasis">info</span> command displays a line starting `PRIN' while the printer is active. 
<p class="level0"><span Class="emphasis">Screen</span> maintains a hardstatus line for every window. If a window gets selected, the display's hardstatus will be updated to match the window's hardstatus line. If the display has no hardstatus the line will be displayed as a standard  <span Class="emphasis">screen </span> message. The hardstatus line can be changed with the ANSI Application Program Command (APC): *QESC_&lt;string&gt;ESCe*U. As a convenience for xterm users the sequence *QESC]0..2;&lt;string&gt;^G*U is also accepted. 
<p class="level0">Some capabilities are only put into the $TERMCAP variable of the virtual terminal if they can be efficiently implemented by the physical terminal. For instance, `dl' (delete line) is only put into the $TERMCAP variable if the terminal supports either delete line itself or scrolling regions. Note that this may provoke confusion, when  the session is reattached on a different terminal, as the value of $TERMCAP cannot be modified by parent processes. 
<p class="level0">The "alternate screen" capability is not enabled by default. Set the <span Class="bold">altscreen</span> .screenrc command to enable it. 
<p class="level0">The following is a list of control sequences recognized by <span Class="emphasis">screen .</span> *Q(V)*U and *Q(A)*U indicate VT100-specific and ANSI- or ISO-specific functions, respectively. 
<p class="level0">
<p class="level0">
<p class="level0"><span Class="bold">ESC E</span> Next Line 
<p class="level0"><span Class="bold">ESC D</span> Index 
<p class="level0"><span Class="bold">ESC M</span> Reverse Index 
<p class="level0"><span Class="bold">ESC H</span> Horizontal Tab Set 
<p class="level0"><span Class="bold">ESC Z</span> Send VT100 Identification String 
<p class="level0"><span Class="manpage">ESC 7 	(V)</span>Save Cursor and Attributes 
<p class="level0"><span Class="manpage">ESC 8 	(V)</span>Restore Cursor and Attributes 
<p class="level0"><span Class="manpage">ESC [s 	(A)</span>Save Cursor and Attributes 
<p class="level0"><span Class="manpage">ESC [u 	(A)</span>Restore Cursor and Attributes 
<p class="level0"><span Class="bold">ESC c</span> Reset to Initial State 
<p class="level0"><span Class="bold">ESC g</span> Visual Bell 
<p class="level0"><span Class="bold">ESC Pn\fB p</span> Cursor Visibility (97801) 
<p class="level0">h'w'ESC 'u'Pn = <span Class="bold">6</span> Invisible 
<p class="level0">h'w'ESC Pn = 'u'<span Class="bold">7</span> Visible 
<p class="level0"><span Class="manpage">ESC = 	(V)</span>Application Keypad Mode 
<p class="level0"><span Class="manpage">ESC &gt; 	(V)</span>Numeric Keypad Mode 
<p class="level0"><span Class="manpage">ESC # 8 	(V)</span>Fill Screen with E's 
<p class="level0"><span Class="manpage">ESC \e 	(A)</span>String Terminator 
<p class="level0"><span Class="manpage">ESC ^ 	(A)</span>Privacy Message String (Message Line) 
<p class="level0"><span Class="bold">ESC !</span> Global Message String (Message Line) 
<p class="level0"><span Class="bold">ESC k</span> A.|k.|a. Definition String 
<p class="level0"><span Class="manpage">ESC P 	(A)</span>Device Control String. Outputs a string directly to the host terminal without interpretation. 
<p class="level0"><span Class="manpage">ESC _ 	(A)</span>Application Program Command (Hardstatus) 
<p class="level0"><span Class="manpage">ESC ] 0 ; string ^G 	(A)</span>Operating System Command (Hardstatus, xterm title hack) 
<p class="level0"><span Class="manpage">ESC ] 83 ; cmd ^G 	(A)</span>Execute screen command. This only works if multi-user support is compiled into screen. The pseudo-user *Q:window:*U is used to check the access control list. Use *Qaddacl :window: -rwx &#35;?*U to create a user with no rights and allow only the needed commands. 
<p class="level0"><span Class="manpage">Control-N 	(A)</span>Lock Shift G1 (SO) 
<p class="level0"><span Class="manpage">Control-O 	(A)</span>Lock Shift G0 (SI) 
<p class="level0"><span Class="manpage">ESC n 	(A)</span>Lock Shift G2 
<p class="level0"><span Class="manpage">ESC o 	(A)</span>Lock Shift G3 
<p class="level0"><span Class="manpage">ESC N 	(A)</span>Single Shift G2 
<p class="level0"><span Class="manpage">ESC O 	(A)</span>Single Shift G3 
<p class="level0"><span Class="manpage">ESC ( \fPPcs 	(A)</span>Designate character set as G0 
<p class="level0"><span Class="manpage">ESC ) \fPPcs 	(A)</span>Designate character set as G1 
<p class="level0"><span Class="manpage">ESC * \fPPcs 	(A)</span>Designate character set as G2 
<p class="level0"><span Class="manpage">ESC + \fPPcs 	(A)</span>Designate character set as G3 
<p class="level0"><span Class="bold">ESC [ Pn\fB ; Pn\fB H</span> Direct Cursor Addressing 
<p class="level0"><span Class="bold">ESC [ Pn\fB ; Pn\fB f</span> same as above 
<p class="level0"><span Class="bold">ESC [ Pn\fB J</span> Erase in Display 
<p class="level0">h'w'ESC [ 'u'Pn = None or <span Class="bold">0</span> From Cursor to End of Screen 
<p class="level0">h'w'ESC [ Pn = 'u'<span Class="bold">1</span> From Beginning of Screen to Cursor 
<p class="level0">h'w'ESC [ Pn = 'u'<span Class="bold">2</span> Entire Screen 
<p class="level0"><span Class="bold">ESC [ Pn\fB K</span> Erase in Line 
<p class="level0">h'w'ESC [ 'u'Pn = None or <span Class="bold">0</span> From Cursor to End of Line 
<p class="level0">h'w'ESC [ Pn = 'u'<span Class="bold">1</span> From Beginning of Line to Cursor 
<p class="level0">h'w'ESC [ Pn = 'u'<span Class="bold">2</span> Entire Line 
<p class="level0"><span Class="bold">ESC [ Pn\fB X</span> Erase character 
<p class="level0"><span Class="bold">ESC [ Pn\fB A</span> Cursor Up 
<p class="level0"><span Class="bold">ESC [ Pn\fB B</span> Cursor Down 
<p class="level0"><span Class="bold">ESC [ Pn\fB C</span> Cursor Right 
<p class="level0"><span Class="bold">ESC [ Pn\fB D</span> Cursor Left 
<p class="level0"><span Class="bold">ESC [ Pn\fB E</span> Cursor next line 
<p class="level0"><span Class="bold">ESC [ Pn\fB F</span> Cursor previous line 
<p class="level0"><span Class="bold">ESC [ Pn\fB G</span> Cursor horizontal position 
<p class="level0"><span Class="bold">ESC [ Pn\fB `</span> same as above 
<p class="level0"><span Class="bold">ESC [ Pn\fB d</span> Cursor vertical position 
<p class="level0"><span Class="bold">ESC [ Ps\fB ;…\fB; Ps\fB m</span> Select Graphic Rendition 
<p class="level0">h'w'ESC [ 'u'Ps = None or <span Class="bold">0</span> Default Rendition 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">1</span> Bold 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">2</span>	(A) Faint 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">3</span>	(A) <span Class="emphasis">Standout</span> Mode (ANSI: Italicized) 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">4</span> Underlined 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">5</span> Blinking 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">7</span> Negative Image 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">22</span>	(A) Normal Intensity 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">23</span>	(A) <span Class="emphasis">Standout</span> Mode off (ANSI: Italicized off) 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">24</span>	(A) Not Underlined 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">25</span>	(A) Not Blinking 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">27</span>	(A) Positive Image 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">30</span>	(A) Foreground Black 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">31</span>	(A) Foreground Red 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">32</span>	(A) Foreground Green 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">33</span>	(A) Foreground Yellow 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">34</span>	(A) Foreground Blue 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">35</span>	(A) Foreground Magenta 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">36</span>	(A) Foreground Cyan 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">37</span>	(A) Foreground White 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">39</span>	(A) Foreground Default 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">40</span>	(A) Background Black 
<p class="level0">h'w'ESC [ Ps = 'u'<a class="bold" href="#">…</a> … 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">49</span>	(A) Background Default 
<p class="level0"><span Class="bold">ESC [ Pn\fB g</span> Tab Clear 
<p class="level0">h'w'ESC [ 'u'Pn = None or <span Class="bold">0</span> Clear Tab at Current Position 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">3</span> Clear All Tabs 
<p class="level0"><span Class="manpage">ESC [ \fPPn\fB ; \fPPn\fB r 	(V)</span>Set Scrolling Region 
<p class="level0"><span Class="manpage">ESC [ \fPPn\fB I 	(A)</span>Horizontal Tab 
<p class="level0"><span Class="manpage">ESC [ \fPPn\fB Z 	(A)</span>Backward Tab 
<p class="level0"><span Class="manpage">ESC [ \fPPn\fB L 	(A)</span>Insert Line 
<p class="level0"><span Class="manpage">ESC [ \fPPn\fB M 	(A)</span>Delete Line 
<p class="level0"><span Class="manpage">ESC [ \fPPn\fB @ 	(A)</span>Insert Character 
<p class="level0"><span Class="manpage">ESC [ \fPPn\fB P 	(A)</span>Delete Character 
<p class="level0"><span Class="bold">ESC [ Pn\fB S</span> Scroll Scrolling Region Up 
<p class="level0"><span Class="bold">ESC [ Pn\fB T</span> Scroll Scrolling Region Down 
<p class="level0"><span Class="bold">ESC [ Pn\fB ^</span> same as above 
<p class="level0"><span Class="bold">ESC [ Ps\fB ;…\fB; Ps\fB h</span> Set Mode 
<p class="level0"><span Class="bold">ESC [ Ps\fB ;…\fB; Ps\fB l</span> Reset Mode 
<p class="level0">h'w'ESC [ 'u'Ps = <span Class="bold">4</span>	(A) Insert Mode 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">20</span>	(A) <span Class="emphasis">Automatic Linefeed</span> Mode 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">34</span> Normal Cursor Visibility 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">?1</span>	(V) Application Cursor Keys 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">?3</span>	(V) Change Terminal Width to 132 columns 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">?5</span>	(V) Reverse Video 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">?6</span>	(V) <span Class="emphasis">Origin</span> Mode 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">?7</span>	(V) <span Class="emphasis">Wrap</span> Mode 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">?9</span> X10 mouse tracking 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">?25</span>	(V) Visible Cursor 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">?47</span> Alternate Screen (old xterm code) 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">?1000</span>	(V) VT200 mouse tracking 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">?1047</span> Alternate Screen (new xterm code) 
<p class="level0">h'w'ESC [ Ps = 'u'<span Class="bold">?1049</span> Alternate Screen (new xterm code) 
<p class="level0"><span Class="manpage">ESC [ 5 i 	(A)</span>Start relay to printer (ANSI Media Copy) 
<p class="level0"><span Class="manpage">ESC [ 4 i 	(A)</span>Stop relay to printer (ANSI Media Copy) 
<p class="level0"><span Class="bold">ESC [ 8 ; Ph\fB ; Pw\fB t</span> Resize the window to `Ph' lines and `Pw' columns (SunView special) 
<p class="level0"><span Class="bold">ESC [ c</span> Send VT100 Identification String 
<p class="level0"><span Class="bold">ESC [ x</span> Send Terminal Parameter Report 
<p class="level0"><span Class="bold">ESC [ &gt; c</span> Send VT220 Secondary Device Attributes String 
<p class="level0"><span Class="bold">ESC [ 6 n</span> Send Cursor Position Report 
<p class="level0">
<p class="level0"><a name="INPUT"></a><h2 class="nroffsh">INPUT TRANSLATION</h2>
<p class="level0">In order to do a full VT100 emulation  <span Class="emphasis">screen</span> has to detect that a sequence of characters in the input stream was generated by a keypress on the user's keyboard and insert the VT100 style escape sequence. <span Class="emphasis">Screen</span> has a very flexible way of doing this by making it possible to map arbitrary commands on arbitrary sequences of characters. For standard VT100 emulation the command will always insert a string in the input buffer of the window (see also command <span Class="bold">stuff</span> in the command table). Because the sequences generated by a keypress can change after a reattach from a different terminal type, it is possible to bind commands to the termcap name of the keys. <span Class="emphasis">Screen</span> will insert the correct binding after each reattach. See the <span Class="bold">bindkey</span> command for further details on the syntax and examples. 
<p class="level0">Here is the table of the default key bindings. (A) means that the command is executed if the keyboard is switched into application mode. 
<p class="level0">
<p class="level0"><pre class="level0">
Key name	Termcap name	Command
l'54n'
Cursor up	ku	stuff e033[A
		stuff e033OA	(A)
Cursor down	kd	stuff e033[B
		stuff e033OB	(A)
Cursor right	kr	stuff e033[C
		stuff e033OC	(A)
Cursor left	kl	stuff e033[D
		stuff e033OD	(A)
Function key 0	k0	stuff e033[10~
Function key 1	k1	stuff e033OP
Function key 2	k2	stuff e033OQ
Function key 3	k3	stuff e033OR
Function key 4	k4	stuff e033OS
Function key 5	k5	stuff e033[15~
Function key 6	k6	stuff e033[17~
Function key 7	k7	stuff e033[18~
Function key 8	k8	stuff e033[19~
Function key 9	k9	stuff e033[20~
Function key 10	k;	stuff e033[21~
Function key 11	F1	stuff e033[23~
Function key 12	F2	stuff e033[24~
Home	kh	stuff e033[1~
End	kH	stuff e033[4~
Insert	kI	stuff e033[2~
Delete	kD	stuff e033[3~
Page up	kP	stuff e033[5~
Page down	kN	stuff e033[6~
Keypad 0	f0	stuff 0
		stuff e033Op	(A)
Keypad 1	f1	stuff 1
		stuff e033Oq	(A)
Keypad 2	f2	stuff 2
		stuff e033Or	(A)
Keypad 3	f3	stuff 3
		stuff e033Os	(A)
Keypad 4	f4	stuff 4
		stuff e033Ot	(A)
Keypad 5	f5	stuff 5
		stuff e033Ou	(A)
Keypad 6	f6	stuff 6
		stuff e033Ov	(A)
Keypad 7	f7	stuff 7
		stuff e033Ow	(A)
Keypad 8	f8	stuff 8
		stuff e033Ox	(A)
Keypad 9	f9	stuff 9
		stuff e033Oy	(A)
Keypad +	f+	stuff +
		stuff e033Ok	(A)
Keypad -	f-	stuff -
		stuff e033Om	(A)
Keypad *	f*	stuff *
		stuff e033Oj	(A)
Keypad /	f/	stuff /
		stuff e033Oo	(A)
Keypad =	fq	stuff =
		stuff e033OX	(A)
Keypad .	f.	stuff .
		stuff e033On	(A)
Keypad ,	f,	stuff ,
		stuff e033Ol	(A)
Keypad enter	fe	stuff e015
		stuff e033OM	(A)
</pre>

<p class="level0">
<p class="level0">
<p class="level0"><a name="SPECIAL"></a><h2 class="nroffsh">SPECIAL TERMINAL CAPABILITIES</h2>
<p class="level0">The following table describes all terminal capabilities that are recognized by  <span Class="emphasis">screen</span> and are not in the termcap(5) manual. You can place these capabilities in your termcap entries (in `/etc/termcap') or use them with the commands `termcap', `terminfo' and `termcapinfo' in your screenrc files. It is often not possible to place these capabilities in the terminfo database. 
<p class="level0">
<p class="level0">
<p class="level0"><span Class="bold">LP 	(bool)</span> Terminal has VT100 style margins (`magic margins'). Note that this capability is obsolete because  <span Class="emphasis">screen</span> uses the standard 'xn' instead. 
<p class="level0"><span Class="bold">Z0 	(str)</span> Change width to 132 columns. 
<p class="level0"><span Class="bold">Z1 	(str)</span> Change width to 80 columns. 
<p class="level0"><span Class="bold">WS 	(str)</span> Resize display. This capability has the desired width and height as arguments. <span Class="emphasis">SunView(tm)</span> example: 'eE[8;%d;%dt'. 
<p class="level0"><span Class="bold">NF 	(bool)</span> Terminal doesn't need flow control. Send ^S and ^Q direct to the application. Same as 'flow off'. The opposite of this capability is 'nx'. 
<p class="level0"><span Class="bold">G0 	(bool)</span> Terminal can deal with ISO 2022 font selection sequences. 
<p class="level0"><span Class="bold">S0 	(str)</span> Switch charset 'G0' to the specified charset. Default is 'eE(%.'. 
<p class="level0"><span Class="bold">E0 	(str)</span> Switch charset 'G0' back to standard charset. Default is 'eE(B'. 
<p class="level0"><span Class="bold">C0 	(str)</span> Use the string as a conversion table for font '0'. See the 'ac' capability for more details. 
<p class="level0"><span Class="bold">CS 	(str)</span> Switch cursor-keys to application mode. 
<p class="level0"><span Class="bold">CE 	(str)</span> Switch cursor-keys back to normal mode. 
<p class="level0"><span Class="bold">AN 	(bool)</span> Turn on autonuke. See the 'autonuke' command for more details. 
<p class="level0"><span Class="bold">OL 	(num)</span> Set the output buffer limit. See the 'obuflimit' command for more details. 
<p class="level0"><span Class="bold">KJ 	(str)</span> Set the encoding of the terminal. See the 'encoding' command for valid encodings. 
<p class="level0"><span Class="bold">AF 	(str)</span> Change character foreground color in an ANSI conform way. This capability will almost always be set to 'eE[3%dm' ('eE[3%p1%dm' on terminfo machines). 
<p class="level0"><span Class="bold">AB 	(str)</span> Same as 'AF', but change background color. 
<p class="level0"><span Class="bold">AX 	(bool)</span> Does understand ANSI set default fg/bg color (eE[39m / eE[49m). 
<p class="level0"><span Class="bold">XC 	(str)</span> Describe a translation of characters to strings depending on the current font. More details follow in the next section. 
<p class="level0"><span Class="bold">XT 	(bool)</span> Terminal understands special xterm sequences (OSC, mouse tracking). 
<p class="level0"><span Class="bold">C8 	(bool)</span> Terminal needs bold to display high-intensity colors (e.g. Eterm). 
<p class="level0"><span Class="bold">TF 	(bool)</span> Add missing capabilities to the termcap/info entry. (Set by default). 
<p class="level0"><a name="CHARACTER"></a><h2 class="nroffsh">CHARACTER TRANSLATION</h2>
<p class="level0"><span Class="emphasis">Screen</span> has a powerful mechanism to translate characters to arbitrary strings depending on the current font and terminal type. Use this feature if you want to work with a common standard character set (say ISO8851-latin1) even on terminals that scatter the more unusual characters over several national language font pages. 
<p class="level0">Syntax: <pre class="level0">
&nbsp;   <span class="bold">XC=</span><span class="emphasis">&lt;charset-mapping&gt;</span>{<span class="bold">,,</span><span class="emphasis">&lt;charset-mapping&gt;</span>}
&nbsp;   <span class="emphasis">&lt;charset-mapping&gt;</span> := <span class="emphasis">&lt;designator&gt;&lt;template&gt;</span>{<span class="bold">,</span><span class="emphasis">&lt;mapping&gt;</span>}
&nbsp;   <span class="emphasis">&lt;mapping&gt;</span> := <span class="emphasis">&lt;char-to-be-mapped&gt;&lt;template-arg&gt;</span>
</pre>

<p class="level0">
<p class="level0">The things in braces may be repeated any number of times. 
<p class="level0">A <span Class="emphasis">&lt;charset-mapping&gt;</span> tells  <span Class="emphasis">screen</span> how to map characters in font <span Class="emphasis">&lt;designator&gt;</span> ('B': Ascii, 'A': UK, 'K': German, etc.) to strings. Every <span Class="emphasis">&lt;mapping&gt;</span> describes to what string a single character will be translated. A template mechanism is used, as  most of the time the codes have a lot in common (for example strings to switch to and from another charset). Each occurrence of '%' in <span Class="emphasis">&lt;template&gt;</span> gets substituted with the <span Class="emphasis">&lt;template-arg&gt;</span> specified together with the character. If your strings are not similar at all, then use '%' as a template and place the full string in <span Class="emphasis">&lt;template-arg&gt;</span>. A quoting mechanism was added to make it possible to use a real '%'. The 'e' character quotes the special characters 'e', '%', and ','. 
<p class="level0">Here is an example: 
<p class="level0">&nbsp;   termcap hp700 'XC=BeE(K%eE(B,e304[,e326eeee,e334]' 
<p class="level0">This tells <span Class="emphasis">screen</span> how to translate ISOlatin1 (charset 'B') upper case umlaut characters on a hp700 terminal that has a German charset. 'e304' gets translated to 'eE(K[eE(B' and so on. Note that this line gets parsed *three* times before the internal lookup table is built, therefore a lot of quoting is needed to create a single 'e'. 
<p class="level0">Another extension was added to allow more emulation: If a mapping translates the unquoted '%' char, it will be sent to the terminal whenever  <span Class="emphasis">screen</span> switches to the corresponding <span Class="emphasis">&lt;designator&gt;</span>. In this special case the template is assumed to be just '%' because the charset switch sequence and the character mappings normally haven't much in common. 
<p class="level0">This example shows one use of the extension: 
<p class="level0">&nbsp;   termcap xterm 'XC=K%,%eE(B,[e304,eeeee326,]e334' 
<p class="level0">Here, a part of the German ('K') charset is emulated on an xterm. If  <span Class="emphasis">screen</span> has to change to the 'K' charset, 'eE(B' will be sent to the terminal, i.e. the ASCII charset is used instead. The template is just '%', so the mapping is straightforward: '[' to 'e304', 'e' to 'e326', and ']' to 'e334'. 
<p class="level0"><a name="ENVIRONMENT"></a><h2 class="nroffsh">ENVIRONMENT</h2>
<p class="level0">
<p class="level0">
<p class="level0"><a name="COLUMNS"></a><span class="nroffip">COLUMNS 15</span> 
<p class="level1">Number of columns on the terminal (overrides termcap entry). 
<p class="level0"><a name="HOME"></a><span class="nroffip">HOME</span> 
<p class="level1">Directory in which to look for .screenrc. 
<p class="level0"><a name="LINES"></a><span class="nroffip">LINES </span> 
<p class="level1">Number of lines on the terminal (overrides termcap entry). 
<p class="level0"><a name="LOCKPRG"></a><span class="nroffip">LOCKPRG</span> 
<p class="level1">Screen lock program. 
<p class="level0"><a name="NETHACKOPTIONS"></a><span class="nroffip">NETHACKOPTIONS</span> 
<p class="level1">Turns on nethack option. 
<p class="level0"><a name="PATH"></a><span class="nroffip">PATH</span> 
<p class="level1">Used for locating programs to run. 
<p class="level0"><a name="SCREENCAP"></a><span class="nroffip">SCREENCAP</span> 
<p class="level1">For customizing a terminal's TERMCAP value. 
<p class="level0"><a name="SCREENDIR"></a><span class="nroffip">SCREENDIR</span> 
<p class="level1">Alternate socket directory. 
<p class="level0"><a name="SCREENRC"></a><span class="nroffip">SCREENRC</span> 
<p class="level1">Alternate user screenrc file. 
<p class="level0"><a name="SHELL"></a><span class="nroffip">SHELL</span> 
<p class="level1">Default shell program for opening windows (default *Q/bin/sh*U). See also *Qshell*U .screenrc command. 
<p class="level0"><a name="STY"></a><span class="nroffip">STY</span> 
<p class="level1">Alternate socket name. 
<p class="level0"><a name="SYSSCREENRC"></a><span class="nroffip">SYSSCREENRC</span> 
<p class="level1">Alternate system screenrc file. 
<p class="level0"><a name="TERM"></a><span class="nroffip">TERM</span> 
<p class="level1">Terminal name. 
<p class="level0"><a name="TERMCAP"></a><span class="nroffip">TERMCAP</span> 
<p class="level1">Terminal description. 
<p class="level0"><a name="WINDOW"></a><span class="nroffip">WINDOW</span> 
<p class="level1">Window number of a window (at creation time). 
<p class="level1"><a name="FILES"></a><h2 class="nroffsh">FILES</h2>
<p class="level0">
<p class="level0">
<p class="level0"><a name="screen-4etcscreenrc"></a><span class="nroffip">…/screen-4.?.??/etc/screenrc 34</span> 
<p class="level1">
<p class="level0"><a name="screen-4etcetcscreenrc"></a><span class="nroffip">…/screen-4.?.??/etc/etcscreenrc</span> 
<p class="level1">Examples in the  <span Class="emphasis">screen</span> distribution package for private and global initialization files. 
<p class="level0"><a name="SYSSCREENRC"></a><span class="nroffip">$SYSSCREENRC </span> 
<p class="level1">
<p class="level0"><a name="etcscreenrc"></a><span class="nroffip">/etc/screenrc</span> 
<p class="level1"><span Class="emphasis">screen</span> initialization commands 
<p class="level0"><a name="SCREENRC"></a><span class="nroffip">$SCREENRC</span> 
<p class="level1">
<p class="level0"><a name="HOMEscreenrc"></a><span class="nroffip">$HOME/.screenrc</span> 
<p class="level1">Read in after /etc/screenrc 
<p class="level0"><a name="SCREENDIRS-login"></a><span class="nroffip">$SCREENDIR/S-&lt;login&gt;</span> 
<p class="level1">
<p class="level0"><a name="varrunscreenS-login"></a><span class="nroffip">/var/run/screen/S-&lt;login&gt;</span> 
<p class="level1">Socket directories (default) 
<p class="level0"><a name="usrtmpscreensS-login"></a><span class="nroffip">/usr/tmp/screens/S-&lt;login&gt;</span> 
<p class="level1">Alternate socket directories. 
<p class="level0"><a name="socket"></a><span class="nroffip">&lt;socket directory&gt;/.termcap</span> 
<p class="level1">Written by the "termcap" output function 
<p class="level0"><a name="usrtmpscreensscreen-exchange"></a><span class="nroffip">/usr/tmp/screens/screen-exchange</span> 
<p class="level1">or 
<p class="level0"><a name="tmpscreen-exchange"></a><span class="nroffip">/tmp/screen-exchange</span> 
<p class="level1"><span Class="emphasis">screen</span> `interprocess communication buffer' 
<p class="level0"><a name="hardcopy0-9"></a><span class="nroffip">hardcopy.[0-9]</span> 
<p class="level1">Screen images created by the hardcopy function 
<p class="level0"><a name="screenlog0-9"></a><span class="nroffip">screenlog.[0-9]</span> 
<p class="level1">Output log files created by the log function 
<p class="level0"><a name="usrlibterminfo"></a><span class="nroffip">/usr/lib/terminfo/?/*</span> 
<p class="level1">or 
<p class="level0"><a name="etctermcap"></a><span class="nroffip">/etc/termcap</span> 
<p class="level1">Terminal capability databases 
<p class="level0"><a name="varrunutmp"></a><span class="nroffip">/var/run/utmp</span> 
<p class="level1">Login records 
<p class="level0"><a name="LOCKPRG"></a><span class="nroffip">$LOCKPRG</span> 
<p class="level1">Program that locks a terminal. 
<p class="level1">
<p class="level1"><a name="SEE"></a><h2 class="nroffsh">SEE ALSO</h2>
<p class="level0">termcap(5), utmp(5), vi(1), captoinfo(1), tic(1) 
<p class="level0">
<p class="level0"><a name="AUTHORS"></a><h2 class="nroffsh">AUTHORS</h2>
<p class="level0">Originally created by Oliver Laumann, this latest version was produced by Juergen Weigert, Michael Schroeder, Micah Cowan and Sadrul Habib Chowdhury. 
<p class="level0"><a name="COPYLEFT"></a><h2 class="nroffsh">COPYLEFT</h2>
<p class="level0"><pre class="level0">
Copyright (c) 2010
	Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
	Sadrul Habib Chowdhury (sadrul@users.sourceforge.net)
Copyright (c) 2008, 2009
	Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
	Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
	Micah Cowan (micah@cowan.name)
	Sadrul Habib Chowdhury (sadrul@users.sourceforge.net)
Copyright (C) 1993-2003
	Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
	Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
Copyright (C) 1987 Oliver Laumann
</pre>

<p class="level0">
<p class="level0">This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3, or (at your option) any later version. 
<p class="level0">This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. 
<p class="level0">You should have received a copy of the GNU General Public License along with this program (see the file COPYING); if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA 
<p class="level0"><a name="CONTRIBUTORS"></a><h2 class="nroffsh">CONTRIBUTORS</h2>
<p class="level0"><pre class="level0">
Ken Beal (kbeal@amber.ssd.csd.harris.com),
Rudolf Koenig (rfkoenig@immd4.informatik.uni-erlangen.de),
Toerless Eckert (eckert@immd4.informatik.uni-erlangen.de),
Wayne Davison (davison@borland.com),
Patrick Wolfe (pat@kai.com, kailand!pat),
Bart Schaefer (schaefer@cse.ogi.edu),
Nathan Glasser (nathan@brokaw.lcs.mit.edu),
Larry W. Virden (lvirden@cas.org),
Howard Chu (hyc@hanauma.jpl.nasa.gov),
Tim MacKenzie (tym@dibbler.cs.monash.edu.au),
Markku Jarvinen (mta@{cc,cs,ee}.tut.fi),
Marc Boucher (marc@CAM.ORG),
Doug Siebert (dsiebert@isca.uiowa.edu),
Ken Stillson (stillson@tsfsrv.mitre.org),
Ian Frechett (frechett@spot.Colorado.EDU),
Brian Koehmstedt (bpk@gnu.ai.mit.edu),
Don Smith (djs6015@ultb.isc.rit.edu),
Frank van der Linden (vdlinden@fwi.uva.nl),
Martin Schweikert (schweik@cpp.ob.open.de),
David Vrona (dave@sashimi.lcu.com),
E. Tye McQueen (tye%spillman.UUCP@uunet.uu.net),
Matthew Green (mrg@eterna.com.au),
Christopher Williams (cgw@pobox.com),
Matt Mosley (mattm@access.digex.net),
Gregory Neil Shapiro (gshapiro@wpi.WPI.EDU),
Johannes Zellner (johannes@zellner.org),
Pablo Averbuj (pablo@averbuj.com).
</pre>

<p class="level0">
<p class="level0">
<p class="level0"><a name="VERSION"></a><h2 class="nroffsh">VERSION</h2>
<p class="level0">This is version 4.1.0. Its roots are a merge of a custom version 2.3PR7 by Wayne Davison and several enhancements to Oliver Laumann's version 2.0. Note that all versions numbered 2.x are copyright by Oliver Laumann.  
<p class="level0"><a name="AVAILABILITY"></a><h2 class="nroffsh">AVAILABILITY</h2>
<p class="level0">The latest official release of  <span Class="emphasis">screen</span> available via anonymous ftp from gnudist.gnu.org, nic.funet.fi or any other  <span Class="emphasis">GNU </span> distribution site. The home site of <span Class="emphasis">screen</span> is ftp.uni-erlangen.de, in the directory pub/utilities/screen. The subdirectory `private' contains the latest beta testing release. If you want to help, send a note to screen@uni-erlangen.de. 
<p class="level0"><a name="BUGS"></a><h2 class="nroffsh">BUGS</h2>
<p class="level0">
<p class="level0">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 3</span> 
<p class="level1">`dm' (delete mode) and `xs' are not handled correctly (they are ignored). `xn' is treated as a magic-margin indicator. 
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1"><span Class="emphasis">Screen</span> has no clue about double-high or double-wide characters.          But this is the only area where  <span Class="emphasis">vttest</span> is allowed to fail. 
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1">It is not possible to change the environment variable $TERMCAP when  reattaching under a different terminal type. 
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1">The support of terminfo based systems is very limited. Adding extra capabilities to $TERMCAP may not have any effects. 
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1"><span Class="emphasis">Screen</span> does not make use of hardware tabs. 
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1"><span Class="emphasis">Screen</span> must be installed as set-uid with owner root on most systems in order to be able to correctly change the owner of the tty device file for each window. Special permission may also be required to write the file *Q/var/run/utmp*U. 
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1">Entries in *Q/var/run/utmp*U are not removed when <span Class="emphasis">screen</span> is killed with SIGKILL. This will cause some programs (like "w" or "rwho") to advertise that a user is logged on who really isn't. 
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1"><span Class="emphasis">Screen</span> may give a strange warning when your tty has no utmp entry. 
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1">When the modem line was hung up,  <span Class="emphasis">screen</span> may not automatically detach (or quit) unless the device driver is configured to send a HANGUP signal.  To detach a  <span Class="emphasis">screen</span> session use the -D or -d command line option. 
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1">If a password is set, the command line options -d and -D still detach a session without asking. 
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1">Both *Qbreaktype*U and *Qdefbreaktype*U change the break generating method used by all terminal devices. The first should change a window specific setting, where the latter should change only the default for new  windows. 
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1">When attaching to a multiuser session, the user's .screenrc file is not sourced. Each user's personal settings have to be included in the .screenrc file from which the session is booted, or have to be changed manually. 
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1">A weird imagination is most useful to gain full advantage of all the features. 
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu</span> 
<p class="level1">Send bug-reports, fixes, enhancements, t-shirts, money, beer & pizza to <span Class="manpage">screen@uni-erlangen.de .</span>
<p class="level1">