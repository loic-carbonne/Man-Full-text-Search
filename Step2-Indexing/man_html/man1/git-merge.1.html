
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0"><a name="NAME"></a><h2 class="nroffsh">NAME</h2>
<p class="level0">git-merge - Join two or more development histories together <a name="SYNOPSIS"></a><h2 class="nroffsh">SYNOPSIS</h2>
<p class="level0">
<p class="level0"><pre class="level0">
<span class="emphasis">git merge</span> [-n] [--stat] [--no-commit] [--squash] [--[no-]edit]
&nbsp;       [-s &lt;strategy&gt;] [-X &lt;strategy-option&gt;] [-S[&lt;key-id&gt;]]
&nbsp;       [--[no-]rerere-autoupdate] [-m &lt;msg&gt;] [&lt;commit&gt;...]
<span class="emphasis">git merge</span> &lt;msg&gt; HEAD &lt;commit&gt;...
<span class="emphasis">git merge</span> --abort
</pre>

<p class="level0">
<p class="level0"><a name="DESCRIPTION"></a><h2 class="nroffsh">DESCRIPTION</h2>
<p class="level0">
<p class="level0">Incorporates changes from the named commits (since the time their histories diverged from the current branch) into the current branch. This command is used by <span Class="emphasis">git pull</span> to incorporate changes from another repository and can be used by hand to merge changes from one branch into another. 
<p class="level0">Assume the following history exists and the current branch is "master": 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1"><pre class="level1">
&nbsp;         A---B---C topic
&nbsp;        /
&nbsp;   D---E---F---G master
</pre>

<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">Then "git merge topic" will replay the changes made on the topic branch since it diverged from master (i.e., E) until its current commit (C) on top of master, and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes. 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1"><pre class="level1">
&nbsp;         A---B---C topic
&nbsp;        /         e
&nbsp;   D---E---F---G---H master
</pre>

<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">The second syntax (&lt;msg&gt; HEAD &lt;commit&gt;...) is supported for historical reasons. Do not use it from the command line or in new scripts. It is the same as git merge -m &lt;msg&gt; &lt;commit&gt;.... 
<p class="level0">The third syntax ("git merge --abort") can only be run after the merge has resulted in conflicts. <span Class="emphasis">git merge --abort</span> will abort the merge process and try to reconstruct the pre-merge state. However, if there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), <span Class="emphasis">git merge --abort</span> will in some cases be unable to reconstruct the original (pre-merge) changes. Therefore: 
<p class="level0"><span Class="bold">Warning</span>: Running <span Class="emphasis">git merge</span> with non-trivial uncommitted changes is discouraged: while possible, it may leave you in a state that is hard to back out of in the case of a conflict. <a name="OPTIONS"></a><h2 class="nroffsh">OPTIONS</h2>
<p class="level0">
<p class="level0">--commit, --no-commit 
<p class="level1">Perform the merge and commit the result. This option can be used to override --no-commit. 
<p class="level1">With --no-commit perform the merge but pretend the merge failed and do not autocommit, to give the user a chance to inspect and further tweak the merge result before committing. 
<p class="level0">
<p class="level0">--edit, -e, --no-edit 
<p class="level1">Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The --no-edit option can be used to accept the auto-generated message (this is generally discouraged). The --edit (or -e) option is still useful if you are giving a draft message with the -m option from the command line and want to edit it in the editor. 
<p class="level1">Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run git merge. To make it easier to adjust such scripts to the updated behaviour, the environment variable GIT_MERGE_AUTOEDIT can be set to no at the beginning of them. 
<p class="level0">
<p class="level0">--ff 
<p class="level1">When the merge resolves as a fast-forward, only update the branch pointer, without creating a merge commit. This is the default behavior. 
<p class="level0">
<p class="level0">--no-ff 
<p class="level1">Create a merge commit even when the merge resolves as a fast-forward. This is the default behaviour when merging an annotated (and possibly signed) tag. 
<p class="level0">
<p class="level0">--ff-only 
<p class="level1">Refuse to merge and exit with a non-zero status unless the current HEAD is already up-to-date or the merge can be resolved as a fast-forward. 
<p class="level0">
<p class="level0">--log[=&lt;n&gt;], --no-log 
<p class="level1">In addition to branch names, populate the log message with one-line descriptions from at most &lt;n&gt; actual commits that are being merged. See also <span Class="bold">git-fmt-merge-msg</span>(1). 
<p class="level1">With --no-log do not list one-line descriptions from the actual commits being merged. 
<p class="level0">
<p class="level0">--stat, -n, --no-stat 
<p class="level1">Show a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat. 
<p class="level1">With -n or --no-stat do not show a diffstat at the end of the merge. 
<p class="level0">
<p class="level0">--squash, --no-squash 
<p class="level1">Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to cause the next git commit command to create a merge commit). This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus). 
<p class="level1">With --no-squash perform the merge and commit the result. This option can be used to override --squash. 
<p class="level0">
<p class="level0">-s &lt;strategy&gt;, --strategy=&lt;strategy&gt; 
<p class="level1">Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no -s option, a built-in list of strategies is used instead (<span Class="emphasis">git merge-recursive</span> when merging a single head, <span Class="emphasis">git merge-octopus</span> otherwise). 
<p class="level0">
<p class="level0">-X &lt;option&gt;, --strategy-option=&lt;option&gt; 
<p class="level1">Pass merge strategy specific option through to the merge strategy. 
<p class="level0">
<p class="level0">--verify-signatures, --no-verify-signatures 
<p class="level1">Verify that the commits being merged have good and trusted GPG signatures and abort the merge in case they do not. 
<p class="level0">
<p class="level0">--summary, --no-summary 
<p class="level1">Synonyms to --stat and --no-stat; these are deprecated and will be removed in the future. 
<p class="level0">
<p class="level0">-q, --quiet 
<p class="level1">Operate quietly. Implies --no-progress. 
<p class="level0">
<p class="level0">-v, --verbose 
<p class="level1">Be verbose. 
<p class="level0">
<p class="level0">--progress, --no-progress 
<p class="level1">Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Note that not all merge strategies may support progress reporting. 
<p class="level0">
<p class="level0">-S[&lt;keyid&gt;], --gpg-sign[=&lt;keyid&gt;] 
<p class="level1">GPG-sign the resulting merge commit. 
<p class="level0">
<p class="level0">-m &lt;msg&gt; 
<p class="level1">Set the commit message to be used for the merge commit (in case one is created). 
<p class="level1">If --log is specified, a shortlog of the commits being merged will be appended to the specified message. 
<p class="level1">The <span Class="emphasis">git fmt-merge-msg</span> command can be used to give a good default for automated <span Class="emphasis">git merge</span> invocations. 
<p class="level0">
<p class="level0">--[no-]rerere-autoupdate 
<p class="level1">Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible. 
<p class="level0">
<p class="level0">--abort 
<p class="level1">Abort the current conflict resolution process, and try to reconstruct the pre-merge state. 
<p class="level1">If there were uncommitted worktree changes present when the merge started, <span Class="emphasis">git merge --abort</span> will in some cases be unable to reconstruct these changes. It is therefore recommended to always commit or stash your changes before running <span Class="emphasis">git merge</span>. 
<p class="level1"><span Class="emphasis">git merge --abort</span> is equivalent to <span Class="emphasis">git reset --merge</span> when MERGE_HEAD is present. 
<p class="level0">
<p class="level0">&lt;commit&gt;... 
<p class="level1">Commits, usually other branch heads, to merge into our branch. Specifying more than one commit will create a merge with more than two parents (affectionately called an Octopus merge). 
<p class="level1">If no commit is given from the command line, merge the remote-tracking branches that the current branch is configured to use as its upstream. See also the configuration section of this manual page. 
<p class="level0"><a name="PRE-MERGE"></a><h2 class="nroffsh">PRE-MERGE CHECKS</h2>
<p class="level0">
<p class="level0">Before applying outside changes, you should get your own work in good shape and committed locally, so it will not be clobbered if there are conflicts. See also <span Class="bold">git-stash</span>(1). <span Class="emphasis">git pull</span> and <span Class="emphasis">git merge</span> will stop without doing anything when local uncommitted changes overlap with files that <span Class="emphasis">git pull</span>/<span Class="emphasis">git merge</span> may need to update. 
<p class="level0">To avoid recording unrelated changes in the merge commit, <span Class="emphasis">git pull</span> and <span Class="emphasis">git merge</span> will also abort if there are any changes registered in the index relative to the HEAD commit. (One exception is when the changed index entries are in the state that would result from the merge already.) 
<p class="level0">If all named commits are already ancestors of HEAD, <span Class="emphasis">git merge</span> will exit early with the message "Already up-to-date." <a name="FAST-FORWARD"></a><h2 class="nroffsh">FAST-FORWARD MERGE</h2>
<p class="level0">
<p class="level0">Often the current branch head is an ancestor of the named commit. This is the most common case especially when invoked from <span Class="emphasis">git pull</span>: you are tracking an upstream repository, you have committed no local changes, and now you want to update to a newer upstream revision. In this case, a new commit is not needed to store the combined history; instead, the HEAD (along with the index) is updated to point at the named commit, without creating an extra merge commit. 
<p class="level0">This behavior can be suppressed with the --no-ff option. <a name="TRUE"></a><h2 class="nroffsh">TRUE MERGE</h2>
<p class="level0">
<p class="level0">Except in a fast-forward merge (see above), the branches to be merged must be tied together by a merge commit that has both of them as its parents. 
<p class="level0">A merged version reconciling the changes from all branches to be merged is committed, and your HEAD, index, and working tree are updated to it. It is possible to have modifications in the working tree as long as they do not overlap; the update will preserve them. 
<p class="level0">When it is not obvious how to reconcile the changes, the following happens: 
<p class="level0">
<p class="level1">
<p class="level1">h'-04' 1.h'+01'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name=""></a><span class="nroffip">  1. 4.2</span> 
<p class="level1">
<p class="level1">The HEAD pointer stays the same. 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04' 2.h'+01'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name=""></a><span class="nroffip">  2. 4.2</span> 
<p class="level1">
<p class="level1">The MERGE_HEAD ref is set to point to the other branch head. 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04' 3.h'+01'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name=""></a><span class="nroffip">  3. 4.2</span> 
<p class="level1">
<p class="level1">Paths that merged cleanly are updated both in the index file and in your working tree. 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04' 4.h'+01'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name=""></a><span class="nroffip">  4. 4.2</span> 
<p class="level1">
<p class="level1">For conflicting paths, the index file records up to three versions: stage 1 stores the version from the common ancestor, stage 2 from HEAD, and stage 3 from MERGE_HEAD (you can inspect the stages with git ls-files -u). The working tree files contain the result of the "merge" program; i.e. 3-way merge results with familiar conflict markers &lt;&lt;&lt;===&gt;&gt;&gt;. 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04' 5.h'+01'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name=""></a><span class="nroffip">  5. 4.2</span> 
<p class="level1">
<p class="level1">No other changes are made. In particular, the local modifications you had before you started merge will stay the same and the index entries for them stay as they were, i.e. matching HEAD. 
<p class="level0">
<p class="level0">If you tried a merge which resulted in complex conflicts and want to start over, you can recover with git merge --abort. <a name="MERGING"></a><h2 class="nroffsh">MERGING TAG</h2>
<p class="level0">
<p class="level0">When merging an annotated (and possibly signed) tag, Git always creates a merge commit even if a fast-forward merge is possible, and the commit message template is prepared with the tag message. Additionally, if the tag is signed, the signature check is reported as a comment in the message template. See also <span Class="bold">git-tag</span>(1). 
<p class="level0">When you want to just integrate with the work leading to the commit that happens to be tagged, e.g. synchronizing with an upstream release point, you may not want to make an unnecessary merge commit. 
<p class="level0">In such a case, you can "unwrap" the tag yourself before feeding it to git merge, or pass --ff-only when you do not have any work on your own. e.g. 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1"><pre class="level1">
git fetch origin
git merge v1.2.3^0
git merge --ff-only v1.2.3
</pre>

<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0"><a name="HOW"></a><h2 class="nroffsh">HOW CONFLICTS ARE PRESENTED</h2>
<p class="level0">
<p class="level0">During a merge, the working tree files are updated to reflect the result of the merge. Among the changes made to the common ancestor(cqs version, non-overlapping ones (that is, you changed an area of the file while the other side left that area intact, or vice versa) are incorporated in the final result verbatim. When both sides made changes to the same area, however, Git cannot randomly pick one side over the other, and asks you to resolve it by leaving what both sides did to that area. 
<p class="level0">By default, Git uses the same style as the one used by the "merge" program from the RCS suite to present such a conflicted hunk, like this: 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1"><pre class="level1">
Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed.
&lt;&lt;&lt;&lt;&lt;&lt;&lt; yours:sample.txt
Conflict resolution is hard;
let*(Aqs go shopping.
=======
Git makes conflict resolution easy.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs:sample.txt
And here is another line that is cleanly resolved or unmodified.
</pre>

<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">The area where a pair of conflicting changes happened is marked with markers &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, and &gt;&gt;&gt;&gt;&gt;&gt;&gt;. The part before the ======= is typically your side, and the part afterwards is typically their side. 
<p class="level0">The default format does not show what the original said in the conflicting area. You cannot tell how many lines are deleted and replaced with Barbie(cqs remark on your side. The only thing you can tell is that your side wants to say it is hard and you(cqd prefer to go shopping, while the other side wants to claim it is easy. 
<p class="level0">An alternative style can be used by setting the "merge.conflictstyle" configuration variable to "diff3". In "diff3" style, the above conflict may look like this: 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1"><pre class="level1">
Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed.
&lt;&lt;&lt;&lt;&lt;&lt;&lt; yours:sample.txt
Conflict resolution is hard;
let*(Aqs go shopping.
|||||||
Conflict resolution is hard.
=======
Git makes conflict resolution easy.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs:sample.txt
And here is another line that is cleanly resolved or unmodified.
</pre>

<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">In addition to the &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, and &gt;&gt;&gt;&gt;&gt;&gt;&gt; markers, it uses another ||||||| marker that is followed by the original text. You can tell that the original just stated a fact, and your side simply gave in to that statement and gave up, while the other side tried to have a more positive attitude. You can sometimes come up with a better resolution by viewing the original. <a name="HOW"></a><h2 class="nroffsh">HOW TO RESOLVE CONFLICTS</h2>
<p class="level0">
<p class="level0">After seeing a conflict, you can do two things: 
<p class="level0">
<p class="level1">
<p class="level1">h'-04'(buh'+03'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level1">
<p class="level1">Decide not to merge. The only clean-ups you need are to reset the index file to the HEAD commit to reverse 2. and to clean up working tree changes made by 2. and 3.; git merge --abort can be used for this. 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04'(buh'+03'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level1">
<p class="level1">Resolve the conflicts. Git will mark the conflicts in the working tree. Edit the files into shape and <span Class="emphasis">git add</span> them to the index. Use <span Class="emphasis">git commit</span> to seal the deal. 
<p class="level0">
<p class="level0">You can work through the conflict with a number of tools: 
<p class="level0">
<p class="level1">
<p class="level1">h'-04'(buh'+03'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level1">
<p class="level1">Use a mergetool. git mergetool to launch a graphical mergetool which will work you through the merge. 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04'(buh'+03'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level1">
<p class="level1">Look at the diffs. git diff will show a three-way diff, highlighting changes from both the HEAD and MERGE_HEAD versions. 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04'(buh'+03'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level1">
<p class="level1">Look at the diffs from each branch. git log --merge -p &lt;path&gt; will show diffs first for the HEAD version and then the MERGE_HEAD version. 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04'(buh'+03'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level1">
<p class="level1">Look at the originals. git show :1:filename shows the common ancestor, git show :2:filename shows the HEAD version, and git show :3:filename shows the MERGE_HEAD version. 
<p class="level0"><a name="EXAMPLES"></a><h2 class="nroffsh">EXAMPLES</h2>
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04'(buh'+03'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level1">
<p class="level1">Merge branches fixes and enhancements on top of the current branch, making an octopus merge: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
$ git merge fixes enhancements
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04'(buh'+03'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level1">
<p class="level1">Merge branch obsolete into the current branch, using ours merge strategy: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
$ git merge -s ours obsolete
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04'(buh'+03'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level1">
<p class="level1">Merge branch maint into the current branch, but do not make a new commit automatically: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
$ git merge --no-commit maint
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">This can be used when you want to include further changes to the merge, or want to write your own merge commit message. 
<p class="level1">You should refrain from abusing this option to sneak substantial changes into a merge commit. Small fixups like bumping release/version name would be acceptable. 
<p class="level0"><a name="MERGE"></a><h2 class="nroffsh">MERGE STRATEGIES</h2>
<p class="level0">
<p class="level0">The merge mechanism (git merge and git pull commands) allows the backend <span Class="emphasis">merge strategies</span> to be chosen with -s option. Some strategies can also take their own options, which can be passed by giving -X&lt;option&gt; arguments to git merge and/or git pull. 
<p class="level0">resolve 
<p class="level1">This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities and is considered generally safe and fast. 
<p class="level0">
<p class="level0">recursive 
<p class="level1">This can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this can detect and handle merges involving renames. This is the default merge strategy when pulling or merging one branch. 
<p class="level1">The <span Class="emphasis">recursive</span> strategy can take the following options: 
<p class="level1">ours 
<p class="level2">This option forces conflicting hunks to be auto-resolved cleanly by favoring <span Class="emphasis">our</span> version. Changes from the other tree that do not conflict with our side are reflected to the merge result. For a binary file, the entire contents are taken from our side. 
<p class="level2">This should not be confused with the <span Class="emphasis">ours</span> merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring <span Class="emphasis">our</span> history contains all that happened in it. 
<p class="level1">
<p class="level1">theirs 
<p class="level2">This is the opposite of <span Class="emphasis">ours</span>. 
<p class="level1">
<p class="level1">patience 
<p class="level2">With this option, <span Class="emphasis">merge-recursive</span> spends a little extra time to avoid mismerges that sometimes occur due to unimportant matching lines (e.g., braces from distinct functions). Use this when the branches to be merged have diverged wildly. See also <span Class="bold">git-diff</span>(1)--patience. 
<p class="level1">
<p class="level1">diff-algorithm=[patience|minimal|histogram|myers] 
<p class="level2">Tells <span Class="emphasis">merge-recursive</span> to use a different diff algorithm, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also <span Class="bold">git-diff</span>(1)--diff-algorithm. 
<p class="level1">
<p class="level1">ignore-space-change, ignore-all-space, ignore-space-at-eol 
<p class="level2">Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also <span Class="bold">git-diff</span>(1)-b, -w, and --ignore-space-at-eol. 
<p class="level2">
<p class="level3">
<p class="level3">h'-04'(buh'+03'c 
<p class="level3">
<p class="level3">
<p class="level3">
<p class="level2"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level3">
<p class="level3">If <span Class="emphasis">their</span> version only introduces whitespace changes to a line, <span Class="emphasis">our</span> version is used; 
<p class="level2">
<p class="level2">
<p class="level3">
<p class="level3">h'-04'(buh'+03'c 
<p class="level3">
<p class="level3">
<p class="level3">
<p class="level2"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level3">
<p class="level3">If <span Class="emphasis">our</span> version introduces whitespace changes but <span Class="emphasis">their</span> version includes a substantial change, <span Class="emphasis">their</span> version is used; 
<p class="level2">
<p class="level2">
<p class="level3">
<p class="level3">h'-04'(buh'+03'c 
<p class="level3">
<p class="level3">
<p class="level3">
<p class="level2"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level3">
<p class="level3">Otherwise, the merge proceeds in the usual way. 
<p class="level2">
<p class="level1">
<p class="level1">renormalize 
<p class="level2">This runs a virtual check-out and check-in of all three stages of a file when resolving a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See "Merging branches with differing checkin/checkout attributes" in <span Class="bold">gitattributes</span>(5) for details. 
<p class="level1">
<p class="level1">no-renormalize 
<p class="level2">Disables the renormalize option. This overrides the merge.renormalize configuration variable. 
<p class="level1">
<p class="level1">rename-threshold=&lt;n&gt; 
<p class="level2">Controls the similarity threshold used for rename detection. See also <span Class="bold">git-diff</span>(1)-M. 
<p class="level1">
<p class="level1">subtree[=&lt;path&gt;] 
<p class="level2">This option is a more advanced form of <span Class="emphasis">subtree</span> strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match. 
<p class="level1">
<p class="level0">
<p class="level0">octopus 
<p class="level1">This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch. 
<p class="level0">
<p class="level0">ours 
<p class="level1">This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the <span Class="emphasis">recursive</span> merge strategy. 
<p class="level0">
<p class="level0">subtree 
<p class="level1">This is a modified recursive strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree. 
<p class="level0">
<p class="level0">With the strategies that use 3-way merge (including the default, <span Class="emphasis">recursive</span>), if a change is made on both branches, but later reverted on one of the branches, that change will be present in the merged result; some people find this behavior confusing. It occurs because only the heads and the merge base are considered when performing a merge, not the individual commits. The merge algorithm therefore considers the reverted change as no change at all, and substitutes the changed version instead. <a name="CONFIGURATION"></a><h2 class="nroffsh">CONFIGURATION</h2>
<p class="level0">
<p class="level0">merge.conflictstyle 
<p class="level1">Specify the style in which conflicted hunks are written out to working tree files upon merge. The default is "merge", which shows a &lt;&lt;&lt;&lt;&lt;&lt;&lt; conflict marker, changes made by one side, a ======= marker, changes made by the other side, and then a &gt;&gt;&gt;&gt;&gt;&gt;&gt; marker. An alternate style, "diff3", adds a ||||||| marker and the original text before the ======= marker. 
<p class="level0">
<p class="level0">merge.defaultToUpstream 
<p class="level1">If merge is called without any commit argument, merge the upstream branches configured for the current branch by using their last observed values stored in their remote-tracking branches. The values of the branch.&lt;current branch&gt;.merge that name the branches at the remote named by branch.&lt;current branch&gt;.remote are consulted, and then they are mapped via remote.&lt;remote&gt;.fetch to their corresponding remote-tracking branches, and the tips of these tracking branches are merged. 
<p class="level0">
<p class="level0">merge.ff 
<p class="level1">By default, Git does not create an extra merge commit when merging a commit that is a descendant of the current commit. Instead, the tip of the current branch is fast-forwarded. When set to false, this variable tells Git to create an extra merge commit in such a case (equivalent to giving the --no-ff option from the command line). When set to only, only such fast-forward merges are allowed (equivalent to giving the --ff-only option from the command line). 
<p class="level0">
<p class="level0">merge.log 
<p class="level1">In addition to branch names, populate the log message with at most the specified number of one-line descriptions from the actual commits that are being merged. Defaults to false, and true is a synonym for 20. 
<p class="level0">
<p class="level0">merge.renameLimit 
<p class="level1">The number of files to consider when performing rename detection during a merge; if not specified, defaults to the value of diff.renameLimit. 
<p class="level0">
<p class="level0">merge.renormalize 
<p class="level1">Tell Git that canonical representation of files in the repository has changed over time (e.g. earlier commits record text files with CRLF line endings, but recent ones use LF line endings). In such a repository, Git can convert the data recorded in commits to a canonical form before performing a merge to reduce unnecessary conflicts. For more information, see section "Merging branches with differing checkin/checkout attributes" in <span Class="bold">gitattributes</span>(5). 
<p class="level0">
<p class="level0">merge.stat 
<p class="level1">Whether to print the diffstat between ORIG_HEAD and the merge result at the end of the merge. True by default. 
<p class="level0">
<p class="level0">merge.tool 
<p class="level1">Controls which merge tool is used by <span Class="bold">git-mergetool</span>(1). The list below shows the valid built-in values. Any other value is treated as a custom merge tool and requires that a corresponding mergetool.&lt;tool&gt;.cmd variable is defined. 
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">araxis 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">bc3 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">codecompare 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">deltawalker 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">diffmerge 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">diffuse 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">ecmerge 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">emerge 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">gvimdiff 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">gvimdiff2 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">gvimdiff3 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">kdiff3 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">meld 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">opendiff 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">p4merge 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">tkdiff 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">tortoisemerge 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">vimdiff 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">vimdiff2 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">vimdiff3 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">h'-04'(buh'+03'c 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level1"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level2">
<p class="level2">xxdiff 
<p class="level1">
<p class="level0">
<p class="level0">merge.verbosity 
<p class="level1">Controls the amount of output shown by the recursive merge strategy. Level 0 outputs nothing except a final error message if conflicts were detected. Level 1 outputs only conflicts, 2 outputs conflicts and file changes. Level 5 and above outputs debugging information. The default is level 2. Can be overridden by the <span Class="emphasis">GIT_MERGE_VERBOSITY</span> environment variable. 
<p class="level0">
<p class="level0">merge.&lt;driver&gt;.name 
<p class="level1">Defines a human-readable name for a custom low-level merge driver. See <span Class="bold">gitattributes</span>(5) for details. 
<p class="level0">
<p class="level0">merge.&lt;driver&gt;.driver 
<p class="level1">Defines the command that implements a custom low-level merge driver. See <span Class="bold">gitattributes</span>(5) for details. 
<p class="level0">
<p class="level0">merge.&lt;driver&gt;.recursive 
<p class="level1">Names a low-level merge driver to be used when performing an internal merge between common ancestors. See <span Class="bold">gitattributes</span>(5) for details. 
<p class="level0">
<p class="level0">branch.&lt;name&gt;.mergeoptions 
<p class="level1">Sets default options for merging into branch &lt;name&gt;. The syntax and supported options are the same as those of <span Class="emphasis">git merge</span>, but option values containing whitespace characters are currently not supported. 
<p class="level0"><a name="SEE"></a><h2 class="nroffsh">SEE ALSO</h2>
<p class="level0">
<p class="level0"><span Class="bold">git-fmt-merge-msg</span>(1), <span Class="bold">git-pull</span>(1), <span Class="bold">gitattributes</span>(5), <span Class="bold">git-reset</span>(1), <span Class="bold">git-diff</span>(1), <span Class="bold">git-ls-files</span>(1), <span Class="bold">git-add</span>(1), <span Class="bold">git-rm</span>(1), <span Class="bold">git-mergetool</span>(1) <a name="GIT"></a><h2 class="nroffsh">GIT</h2>
<p class="level0">
<p class="level0">Part of the <span Class="bold">git</span>(1) suite 