
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0"><a name="NAME"></a><h2 class="nroffsh">NAME</h2>
<p class="level0">f4rpcgenf1 - an RPC protocol compiler <a name="SYNOPSIS"></a><h2 class="nroffsh">SYNOPSIS</h2>
<p class="level0"><pre class="level0">
rpcgen f2infilef4
</pre>

<p class="level0"><br><pre class="level0">
rpcgen [-Df2namef4[=f2valuef4]] [-T] [-K f2secs</span>] f2infilef4
</pre>

<p class="level0"><br><pre class="level0">
rpcgen -c|-h|-l|-m|-M|-t [-o f2outfilef4 ] f2infilef4
</pre>

<p class="level0"><br><pre class="level0">
rpcgen [-I] -s f2nettypef4 [-o f2outfilef4] f2infilef4
</pre>

<p class="level0"><br><pre class="level0">
rpcgen -n f2netidf4 [-o f2outfilef4] f2infilef4
</pre>
<a name="DESCRIPTION"></a><h2 class="nroffsh">DESCRIPTION</h2>
<p class="level0">
<p class="level0">f4rpcgenf1 is a tool that generates C code to implement an RPC protocol. The input to f4rpcgenf1 is a language similar to C known as RPC Language (Remote Procedure Call Language). 
<p class="level0">f4rpcgenf1 is normally used as in the first synopsis where it takes an input file and generates up to four output files. If the f2infilef1 is named f4proto.xf1, then f4rpcgenf1 will generate a header file in f4proto.hf1, XDR routines in f4proto_xdr.cf1, server-side stubs in f4proto_svc.cf1, and client-side stubs in f4proto_clnt.cf1. With the f4-Tf1 option, it will also generate the RPC dispatch table in f4proto_tbl.if1. With the f4-Scf1 option, it will also generate sample code which would illustrate how to use the remote procedures on the client side.  This code would be created in f4proto_client.cf1. With the f4-Ssf1 option, it will also generate a sample server code which would illustrate how to write the remote procedures.  This code would be created in f4proto_server.cf1. 
<p class="level0">The server created can be started both by the port monitors (for example, f4inetdf1 or f4listenf1) or by itself. When it is started by a port monitor, it creates servers only for the transport for which the file descriptor f40</span> was passed. The name of the transport must be specified by setting up the environmental variable f4PM_TRANSPORTf1. When the server generated by f4rpcgenf1 is executed, it creates server handles for all the transports specified in f4NETPATHf1 environment variable, or if it is unset, it creates server handles for all the visible transports from f4/etc/netconfigf1 file. Note: the transports are chosen at run time and not at compile time. 
<p class="level0">When built for a port monitor (f4rpcgenf1 f4-If1), and that the server is self-started, it backgrounds itself by default.  A special define symbol f4RPC_SVC_FGf1 can be used to run the server process in foreground. 
<p class="level0">The second synopsis provides special features which allow for the creation of more sophisticated RPC servers. These features include support for user provided f4&#35;definesf1 and RPC dispatch tables. The entries in the RPC dispatch table contain: 
<p class="level1">
<p class="level1">
<p class="level1">(bu pointers to the service routine corresponding to that procedure, 
<p class="level1">(bu a pointer to the input and output arguments 
<p class="level1">(bu the size of these routines 
<p class="level1">
<p class="level0">A server can use the dispatch table to check authorization and then to execute the service routine; a client library may use it to deal with the details of storage management and XDR data conversion. 
<p class="level0">The other three synopses shown above are used when one does not want to generate all the output files, but only a particular one. Some examples of their usage is described in the EXAMPLE section below. When f4rpcgenf1 is executed with the f4-sf1 option, it creates servers for that particular class of transports. When executed with the f4-nf1 option, it creates a server for the transport specified by f2netidf1. If f2infilef1 is not specified, f4rpcgenf1 accepts the standard input. 
<p class="level0">The C preprocessor, f4cc -Ef1 [see f4cc</span>(1)], is run on the input file before it is actually interpreted by f4rpcgenf1. For each type of output file, f4rpcgenf1 defines a special preprocessor symbol for use by the f4rpcgenf1 programmer: 
<p class="level0">
<p class="level0">
<p class="level0">f4RPC_HDRf1 defined when compiling into header files 
<p class="level0">f4RPC_XDRf1 defined when compiling into XDR routines 
<p class="level0">f4RPC_SVCf1 defined when compiling into server-side stubs 
<p class="level0">f4RPC_CLNTf1 defined when compiling into client-side stubs 
<p class="level0">f4RPC_TBLf1 defined when compiling into RPC dispatch tables 
<p class="level0">
<p class="level0">Any line beginning with `f4%f1' is passed directly into the output file, uninterpreted by f4rpcgenf1. 
<p class="level0">For every data type referred to in f2infilef1, f4rpcgenf1 assumes that there exists a routine with the string f4xdr_f1 prepended to the name of the data type. If this routine does not exist in the RPC/XDR library, it must be provided. Providing an undefined data type allows customization of XDR routines. <br>
<p class="level0">
<p class="level0">The following options are available: 
<p class="level0">f4-af1 Generate all the files including sample code for client and server side. 
<p class="level0">f4-bf1 This generates code for the SunOS4.1 style of rpc.  It is for backward compatibility.  This is the default. 
<p class="level0">f4-5f1 This generates code for the SysVr4 style of rpc.  It is used by the Transport Independent RPC that is in Svr4 systems. By default rpcgen generates code for SunOS4.1 stype of rpc. 
<p class="level0">f4-cf1 Compile into XDR routines. 
<p class="level0">f4-Cf1 Generate code in ANSI C.  This option also generates code that could be compiled with the C++ compiler.  This is the default. 
<p class="level0">f4-kf1 Generate code in K&R C.  The default is ANSI C. 
<p class="level0">f4-Df2namef4[=f2valuef4]f1 Define a symbol f2namef1. Equivalent to the f4&#35;definef1 directive in the source. If no f2valuef1 is given, f2valuef1 is defined as f41f1. This option may be specified more than once. 
<p class="level0">f4-hf1 Compile into f4Cf1 data-definitions (a header file). f4-Tf1 option can be used in conjunction to produce a header file which supports RPC dispatch tables. 
<p class="level0">f4-If1 Generate a service that can be started from inetd.  The default is to generate a static service that handles transports selected with f4-sf1. Using f4-If1 allows starting a service by either method. 
<p class="level0">f4-Kf2 secsf1 By default, services created using f4rpcgen</span> wait f4120</span> seconds after servicing a request before exiting. That interval can be changed using the f4-K</span> flag. To create a server that exits immediately upon servicing a request, f4-K&nbsp;0</span> can be used. To create a server that never exits, the appropriate argument is f4-K&nbsp;-1</span>. 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">When monitoring for a server, some portmonitors, like f4listen</span>(1M), <span Class="emphasis">always</span> spawn a new process in response to a service request. If it is known that a server will be used with such a monitor, the server should exit immediately on completion. For such servers, f4rpcgen</span> should be used with f4-K&nbsp;-1</span>. 
<p class="level1">f4-lf1 Compile into client-side stubs. 
<p class="level1">f4-mf1 Compile into server-side stubs, but do not generate a (lqmain(rq routine. This option is useful for doing callback-routines and for users who need to write their own (lqmain(rq routine to do initialization. 
<p class="level1">f4-Mf1 Generate multithread-safe stubs for passing arguments and results between rpcgen-generated code and user written code. This option is useful for users who want to use threads in their code. 
<p class="level1">f4-n f2netidf1 Compile into server-side stubs for the transport specified by f2netidf1. There should be an entry for f2netidf1 in the netconfig database. This option may be specified more than once, so as to compile a server that serves multiple transports. 
<p class="level1">f4-Nf1 Use the newstyle of rpcgen.  This allows procedures to have multiple arguments. It also uses the style of parameter passing that closely resembles C.  So, when passing an argument to a remote procedure you do not have to pass a pointer to the argument but the argument itself.  This behaviour is different from the oldstyle of rpcgen generated code.  The newstyle is not the default case because of backward compatibility. 
<p class="level1">f4-o f2outfilef1 Specify the name of the output file. If none is specified, standard output is used (f4-cf1, f4-hf1, f4-lf1, f4-mf1, f4-nf1, f4-sf1, f4-Scf1, f4-Smf1, f4-Ssf1, and f4-tf1 modes only). 
<p class="level1">f4-s f2nettypef1 Compile into server-side stubs for all the transports belonging to the class f2nettypef1. The supported classes are f4netpathf1, f4visiblef1, f4circuit_nf1, f4circuit_vf1, f4datagram_nf1, f4datagram_vf1, f4tcpf1, and f4udpf1 [see f4rpc</span>(3N) for the meanings associated with these classes]. This option may be specified more than once. Note: the transports are chosen at run time and not at compile time. 
<p class="level1">f4-Scf1 Generate sample code to show the use of remote procedure and how to bind to the server before calling the client side stubs generated by rpcgen. 
<p class="level1">f4-Smf1 Generate a sample Makefile which can be used for compiling the application. 
<p class="level1">f4-Ssf1 Generate skeleton code for the remote procedures on the server side.  You would need to fill in the actual code for the remote procedures. 
<p class="level1">f4-tf1 Compile into RPC dispatch table. 
<p class="level1">f4-Tf1 Generate the code to support RPC dispatch tables. 
<p class="level1">The options f4-cf1, f4-hf1, f4-lf1, f4-mf1, f4-sf1 and f4-tf1 are used exclusively to generate a particular type of file, while the options f4-Df1 and f4-Tf1 are global and can be used with the other options. <br>
<p class="level1"><a name="NOTES"></a><h2 class="nroffsh">NOTES</h2>
<p class="level0">The RPC Language does not support nesting of structures. As a work-around, structures can be declared at the top-level, and their name used inside other structures in order to achieve the same effect. 
<p class="level0">Name clashes can occur when using program definitions, since the apparent scoping does not really apply. Most of these can be avoided by giving unique names for programs, versions, procedures and types. 
<p class="level0">The server code generated with f4-nf1 option refers to the transport indicated by f2netidf1 and hence is very site specific. <a name="EXAMPLE"></a><h2 class="nroffsh">EXAMPLE</h2>
<p class="level0">The following example: 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">$ rpcgen -T prot.x 
<p class="level1">generates the five files: f4prot.hf1, f4prot_clnt.cf1, f4prot_svc.cf1, f4prot_xdr.cf1 and f4prot_tbl.if1. 
<p class="level1">The following example sends the C data-definitions (header file) to the standard output. 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">$ rpcgen -h prot.x 
<p class="level1">To send the test version of the f4-DTESTf1, server side stubs for all the transport belonging to the class f4datagram_nf1 to standard output, use: 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">$ rpcgen -s datagram_n -DTEST prot.x 
<p class="level1">To create the server side stubs for the transport indicated by f2netidf1 f4tcpf1, use: 
<p class="level0"><a name=""></a><span class="nroffip"></span> 
<p class="level1">$ rpcgen -n tcp -o prot_svc.c prot.x <a name="SEE"></a><h2 class="nroffsh">SEE ALSO</h2>
<p class="level0">f4cc</span>(1). 