
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0"><a name="NAME"></a><h2 class="nroffsh">NAME</h2>
<p class="level0">psql - PostgreSQL interactive terminal <a name="SYNOPSIS"></a><h2 class="nroffsh">SYNOPSIS</h2>
<p class="level0">
<p class="level0"><span Class="bold">psql</span> [<span Class="emphasis">option</span>...] [<span Class="emphasis">dbname</span>&nbsp;[<span Class="emphasis">username</span>]] <a name="DESCRIPTION"></a><h2 class="nroffsh">DESCRIPTION</h2>
<p class="level0">
<p class="level0">
<p class="level0">psql is a terminal-based front-end to PostgreSQL. It enables you to type in queries interactively, issue them to PostgreSQL, and see the query results. Alternatively, input can be from a file. In addition, it provides a number of meta-commands and various shell-like features to facilitate writing scripts and automating a wide variety of tasks. <a name="OPTIONS"></a><h2 class="nroffsh">OPTIONS</h2>
<p class="level0">
<p class="level0"><span Class="bold">-a</span> <br><span Class="bold">--echo-all</span> 
<p class="level1">Print all nonempty input lines to standard output as they are read. (This does not apply to lines read interactively.) This is equivalent to setting the variable <span Class="emphasis">ECHO</span> to all. 
<p class="level0">
<p class="level0"><span Class="bold">-A</span> <br><span Class="bold">--no-align</span> 
<p class="level1">Switches to unaligned output mode. (The default output mode is otherwise aligned.) 
<p class="level0">
<p class="level0"><span Class="bold">-c </span><span class="bold"><span Class="emphasis">command</span></span> <br><span Class="bold">--command=</span><span class="bold"><span Class="emphasis">command</span></span> 
<p class="level1">Specifies that psql is to execute one command string, <span Class="emphasis">command</span>, and then exit. This is useful in shell scripts. Start-up files (psqlrc and ~/.psqlrc) are ignored with this option. 
<p class="level1">
<p class="level1"><span Class="emphasis">command</span> must be either a command string that is completely parsable by the server (i.e., it contains no psql-specific features), or a single backslash command. Thus you cannot mix SQL and psql meta-commands with this option. To achieve that, you could pipe the string into psql, for example: echo *(Aqex ee SELECT * FROM foo;*(Aq | psql. (ee is the separator meta-command.) 
<p class="level1">If the command string contains multiple SQL commands, they are processed in a single transaction, unless there are explicit <span Class="bold">BEGIN</span>/<span Class="bold">COMMIT</span> commands included in the string to divide it into multiple transactions. This is different from the behavior when the same string is fed to psql*(Aqs standard input. Also, only the result of the last SQL command is returned. 
<p class="level1">Because of these legacy behaviors, putting more than one command in the <span Class="bold">-c</span> string often has unexpected results. It*(Aqs better to feed multiple commands to psql*(Aqs standard input, either using echo as illustrated above, or via a shell here-document, for example: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
psql &lt;&lt;EOF
ex
SELECT * FROM foo;
EOF
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0"><span Class="bold">-d </span><span class="bold"><span Class="emphasis">dbname</span></span> <br><span Class="bold">--dbname=</span><span class="bold"><span Class="emphasis">dbname</span></span> 
<p class="level1">Specifies the name of the database to connect to. This is equivalent to specifying <span Class="emphasis">dbname</span> as the first non-option argument on the command line. 
<p class="level1">If this parameter contains an = sign or starts with a valid URI prefix (postgresql:// or postgres://), it is treated as a <span Class="emphasis">conninfo</span> string. See Section 31.1.1, (lqConnection Strings(rq, in the documentation for more information. 
<p class="level0">
<p class="level0"><span Class="bold">-e</span> <br><span Class="bold">--echo-queries</span> 
<p class="level1">Copy all SQL commands sent to the server to standard output as well. This is equivalent to setting the variable <span Class="emphasis">ECHO</span> to queries. 
<p class="level0">
<p class="level0"><span Class="bold">-E</span> <br><span Class="bold">--echo-hidden</span> 
<p class="level1">Echo the actual queries generated by <span Class="bold">ed</span> and other backslash commands. You can use this to study psql*(Aqs internal operations. This is equivalent to setting the variable <span Class="emphasis">ECHO_HIDDEN</span> to on. 
<p class="level0">
<p class="level0"><span Class="bold">-f </span><span class="bold"><span Class="emphasis">filename</span></span> <br><span Class="bold">--file=</span><span class="bold"><span Class="emphasis">filename</span></span> 
<p class="level1">Use the file <span Class="emphasis">filename</span> as the source of commands instead of reading commands interactively. After the file is processed, psql terminates. This is in many ways equivalent to the meta-command <span Class="bold">ei</span>. 
<p class="level1">If <span Class="emphasis">filename</span> is - (hyphen), then standard input is read. 
<p class="level1">Using this option is subtly different from writing psql &lt; <span Class="emphasis">filename</span>. In general, both will do what you expect, but using -f enables some nice features such as error messages with line numbers. There is also a slight chance that using this option will reduce the start-up overhead. On the other hand, the variant using the shell*(Aqs input redirection is (in theory) guaranteed to yield exactly the same output you would have received had you entered everything by hand. 
<p class="level0">
<p class="level0"><span Class="bold">-F </span><span class="bold"><span Class="emphasis">separator</span></span> <br><span Class="bold">--field-separator=</span><span class="bold"><span Class="emphasis">separator</span></span> 
<p class="level1">Use <span Class="emphasis">separator</span> as the field separator for unaligned output. This is equivalent to <span Class="bold">epset fieldsep</span> or <span Class="bold">ef</span>. 
<p class="level0">
<p class="level0"><span Class="bold">-h </span><span class="bold"><span Class="emphasis">hostname</span></span> <br><span Class="bold">--host=</span><span class="bold"><span Class="emphasis">hostname</span></span> 
<p class="level1">Specifies the host name of the machine on which the server is running. If the value begins with a slash, it is used as the directory for the Unix-domain socket. 
<p class="level0">
<p class="level0"><span Class="bold">-H</span> <br><span Class="bold">--html</span> 
<p class="level1">Turn on HTML tabular output. This is equivalent to epset format html or the <span Class="bold">eH</span> command. 
<p class="level0">
<p class="level0"><span Class="bold">-l</span> <br><span Class="bold">--list</span> 
<p class="level1">List all available databases, then exit. Other non-connection options are ignored. This is similar to the meta-command <span Class="bold">elist</span>. 
<p class="level0">
<p class="level0"><span Class="bold">-L </span><span class="bold"><span Class="emphasis">filename</span></span> <br><span Class="bold">--log-file=</span><span class="bold"><span Class="emphasis">filename</span></span> 
<p class="level1">Write all query output into file <span Class="emphasis">filename</span>, in addition to the normal output destination. 
<p class="level0">
<p class="level0"><span Class="bold">-n</span> <br><span Class="bold">--no-readline</span> 
<p class="level1">Do not use Readline for line editing and do not use the command history. This can be useful to turn off tab expansion when cutting and pasting. 
<p class="level0">
<p class="level0"><span Class="bold">-o </span><span class="bold"><span Class="emphasis">filename</span></span> <br><span Class="bold">--output=</span><span class="bold"><span Class="emphasis">filename</span></span> 
<p class="level1">Put all query output into file <span Class="emphasis">filename</span>. This is equivalent to the command <span Class="bold">eo</span>. 
<p class="level0">
<p class="level0"><span Class="bold">-p </span><span class="bold"><span Class="emphasis">port</span></span> <br><span Class="bold">--port=</span><span class="bold"><span Class="emphasis">port</span></span> 
<p class="level1">Specifies the TCP port or the local Unix-domain socket file extension on which the server is listening for connections. Defaults to the value of the <span Class="bold">PGPORT</span> environment variable or, if not set, to the port specified at compile time, usually 5432. 
<p class="level0">
<p class="level0"><span Class="bold">-P </span><span class="bold"><span Class="emphasis">assignment</span></span> <br><span Class="bold">--pset=</span><span class="bold"><span Class="emphasis">assignment</span></span> 
<p class="level1">Specifies printing options, in the style of <span Class="bold">epset</span>. Note that here you have to separate name and value with an equal sign instead of a space. For example, to set the output format to LaTeX, you could write -P format=latex. 
<p class="level0">
<p class="level0"><span Class="bold">-q</span> <br><span Class="bold">--quiet</span> 
<p class="level1">Specifies that psql should do its work quietly. By default, it prints welcome messages and various informational output. If this option is used, none of this happens. This is useful with the <span Class="bold">-c</span> option. This is equivalent to setting the variable <span Class="emphasis">QUIET</span> to on. 
<p class="level0">
<p class="level0"><span Class="bold">-R </span><span class="bold"><span Class="emphasis">separator</span></span> <br><span Class="bold">--record-separator=</span><span class="bold"><span Class="emphasis">separator</span></span> 
<p class="level1">Use <span Class="emphasis">separator</span> as the record separator for unaligned output. This is equivalent to the <span Class="bold">epset recordsep</span> command. 
<p class="level0">
<p class="level0"><span Class="bold">-s</span> <br><span Class="bold">--single-step</span> 
<p class="level1">Run in single-step mode. That means the user is prompted before each command is sent to the server, with the option to cancel execution as well. Use this to debug scripts. 
<p class="level0">
<p class="level0"><span Class="bold">-S</span> <br><span Class="bold">--single-line</span> 
<p class="level1">Runs in single-line mode where a newline terminates an SQL command, as a semicolon does. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Note</span> 
<p class="level2"><br>This mode is provided for those who insist on it, but you are not necessarily encouraged to use it. In particular, if you mix SQL and meta-commands on a line the order of execution might not always be clear to the inexperienced user. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0"><span Class="bold">-t</span> <br><span Class="bold">--tuples-only</span> 
<p class="level1">Turn off printing of column names and result row count footers, etc. This is equivalent to the <span Class="bold">et</span> command. 
<p class="level0">
<p class="level0"><span Class="bold">-T </span><span class="bold"><span Class="emphasis">table_options</span></span> <br><span Class="bold">--table-attr=</span><span class="bold"><span Class="emphasis">table_options</span></span> 
<p class="level1">Specifies options to be placed within the HTML table tag. See <span Class="bold">epset</span> for details. 
<p class="level0">
<p class="level0"><span Class="bold">-U </span><span class="bold"><span Class="emphasis">username</span></span> <br><span Class="bold">--username=</span><span class="bold"><span Class="emphasis">username</span></span> 
<p class="level1">Connect to the database as the user <span Class="emphasis">username</span> instead of the default. (You must have permission to do so, of course.) 
<p class="level0">
<p class="level0"><span Class="bold">-v </span><span class="bold"><span Class="emphasis">assignment</span></span> <br><span Class="bold">--set=</span><span class="bold"><span Class="emphasis">assignment</span></span> <br><span Class="bold">--variable=</span><span class="bold"><span Class="emphasis">assignment</span></span> 
<p class="level1">Perform a variable assignment, like the <span Class="bold">eset</span> meta-command. Note that you must separate name and value, if any, by an equal sign on the command line. To unset a variable, leave off the equal sign. To set a variable with an empty value, use the equal sign but leave off the value. These assignments are done during a very early stage of start-up, so variables reserved for internal purposes might get overwritten later. 
<p class="level0">
<p class="level0"><span Class="bold">-V</span> <br><span Class="bold">--version</span> 
<p class="level1">Print the psql version and exit. 
<p class="level0">
<p class="level0"><span Class="bold">-w</span> <br><span Class="bold">--no-password</span> 
<p class="level1">Never issue a password prompt. If the server requires password authentication and a password is not available by other means such as a .pgpass file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password. 
<p class="level1">Note that this option will remain set for the entire session, and so it affects uses of the meta-command <span Class="bold">econnect</span> as well as the initial connection attempt. 
<p class="level0">
<p class="level0"><span Class="bold">-W</span> <br><span Class="bold">--password</span> 
<p class="level1">Force psql to prompt for a password before connecting to a database. 
<p class="level1">This option is never essential, since psql will automatically prompt for a password if the server demands password authentication. However, psql will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing <span Class="bold">-W</span> to avoid the extra connection attempt. 
<p class="level1">Note that this option will remain set for the entire session, and so it affects uses of the meta-command <span Class="bold">econnect</span> as well as the initial connection attempt. 
<p class="level0">
<p class="level0"><span Class="bold">-x</span> <br><span Class="bold">--expanded</span> 
<p class="level1">Turn on the expanded table formatting mode. This is equivalent to the <span Class="bold">ex</span> command. 
<p class="level0">
<p class="level0"><span Class="bold">-X,</span> <br><span Class="bold">--no-psqlrc</span> 
<p class="level1">Do not read the start-up file (neither the system-wide psqlrc file nor the user*(Aqs ~/.psqlrc file). 
<p class="level0">
<p class="level0"><span Class="bold">-z</span> <br><span Class="bold">--field-separator-zero</span> 
<p class="level1">Set the field separator for unaligned output to a zero byte. 
<p class="level0">
<p class="level0"><span Class="bold">-0</span> <br><span Class="bold">--record-separator-zero</span> 
<p class="level1">Set the record separator for unaligned output to a zero byte. This is useful for interfacing, for example, with xargs -0. 
<p class="level0">
<p class="level0"><span Class="bold">-1</span> <br><span Class="bold">--single-transaction</span> 
<p class="level1">When psql executes a script, adding this option wraps <span Class="bold">BEGIN</span>/<span Class="bold">COMMIT</span> around the script to execute it as a single transaction. This ensures that either all the commands complete successfully, or no changes are applied. 
<p class="level1">If the script itself uses <span Class="bold">BEGIN</span>, <span Class="bold">COMMIT</span>, or <span Class="bold">ROLLBACK</span>, this option will not have the desired effects. Also, if the script contains any command that cannot be executed inside a transaction block, specifying this option will cause that command (and hence the whole transaction) to fail. 
<p class="level0">
<p class="level0"><span Class="bold">-?</span> <br><span Class="bold">--help</span> 
<p class="level1">Show help about psql command line arguments, and exit. 
<p class="level0"><a name="EXIT"></a><h2 class="nroffsh">EXIT STATUS</h2>
<p class="level0">
<p class="level0">
<p class="level0">psql returns 0 to the shell if it finished normally, 1 if a fatal error of its own occurs (e.g. out of memory, file not found), 2 if the connection to the server went bad and the session was not interactive, and 3 if an error occurred in a script and the variable <span Class="emphasis">ON_ERROR_STOP</span> was set. <a name="USAGE"></a><h2 class="nroffsh">USAGE</h2>
<p class="level0"><a name="Connecting"></a><h2 class="nroffsh">Connecting to a Database</h2>
<p class="level0">
<p class="level0">
<p class="level0">psql is a regular PostgreSQL client application. In order to connect to a database you need to know the name of your target database, the host name and port number of the server, and what user name you want to connect as. psql can be told about those parameters via command line options, namely <span Class="bold">-d</span>, <span Class="bold">-h</span>, <span Class="bold">-p</span>, and <span Class="bold">-U</span> respectively. If an argument is found that does not belong to any option it will be interpreted as the database name (or the user name, if the database name is already given). Not all of these options are required; there are useful defaults. If you omit the host name, psql will connect via a Unix-domain socket to a server on the local host, or via TCP/IP to localhost on machines that don*(Aqt have Unix-domain sockets. The default port number is determined at compile time. Since the database server uses the same default, you will not have to specify the port in most cases. The default user name is your operating-system user name, as is the default database name. Note that you cannot just connect to any database under any user name. Your database administrator should have informed you about your access rights. 
<p class="level0">When the defaults aren*(Aqt quite right, you can save yourself some typing by setting the environment variables <span Class="bold">PGDATABASE</span>, <span Class="bold">PGHOST</span>, <span Class="bold">PGPORT</span> and/or <span Class="bold">PGUSER</span> to appropriate values. (For additional environment variables, see Section 31.14, (lqEnvironment Variables(rq, in the documentation.) It is also convenient to have a ~/.pgpass file to avoid regularly having to type in passwords. See Section 31.15, (lqThe Password File(rq, in the documentation for more information. 
<p class="level0">An alternative way to specify connection parameters is in a <span Class="emphasis">conninfo</span> string or a URI, which is used instead of a database name. This mechanism give you very wide control over the connection. For example: 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1"><pre class="level1">
$ <span class="bold">psql "service=myservice sslmode=require"</span>
$ <span class="bold">psql postgresql://dbmaster:5433/mydb?sslmode=require</span>
</pre>

<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">This way you can also use LDAP for connection parameter lookup as described in Section 31.17, (lqLDAP Lookup of Connection Parameters(rq, in the documentation. See Section 31.1.2, (lqParameter Key Words(rq, in the documentation for more information on all the available connection options. 
<p class="level0">If the connection could not be made for any reason (e.g., insufficient privileges, server is not running on the targeted host, etc.), psql will return an error and terminate. 
<p class="level0">If both standard input and standard output are a terminal, then psql sets the client encoding to (lqauto(rq, which will detect the appropriate client encoding from the locale settings (<span Class="bold">LC_CTYPE</span> environment variable on Unix systems). If this doesn*(Aqt work out as expected, the client encoding can be overridden using the environment variable <span Class="bold">PGCLIENTENCODING</span>. <a name="Entering"></a><h2 class="nroffsh">Entering SQL Commands</h2>
<p class="level0">
<p class="level0">In normal operation, psql provides a prompt with the name of the database to which psql is currently connected, followed by the string =&gt;. For example: 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1"><pre class="level1">
$ <span class="bold">psql testdb</span>
psql (9.4.5)
Type "help" for help.
&nbsp;
testdb=&gt;
</pre>

<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">At the prompt, the user can type in SQL commands. Ordinarily, input lines are sent to the server when a command-terminating semicolon is reached. An end of line does not terminate a command. Thus commands can be spread over several lines for clarity. If the command was sent and executed without error, the results of the command are displayed on the screen. 
<p class="level0">Whenever a command is executed, psql also polls for asynchronous notification events generated by <span Class="bold">LISTEN</span>(7) and <span Class="bold">NOTIFY</span>(7). 
<p class="level0">While C-style block comments are passed to the server for processing and removal, SQL-standard comments are removed by psql. <a name="Meta-Commands"></a><h2 class="nroffsh">Meta-Commands</h2>
<p class="level0">
<p class="level0">Anything you enter in psql that begins with an unquoted backslash is a psql meta-command that is processed by psql itself. These commands make psql more useful for administration or scripting. Meta-commands are often called slash or backslash commands. 
<p class="level0">The format of a psql command is the backslash, followed immediately by a command verb, then any arguments. The arguments are separated from the command verb and each other by any number of whitespace characters. 
<p class="level0">To include whitespace in an argument you can quote it with single quotes. To include a single quote in an argument, write two single quotes within single-quoted text. Anything contained in single quotes is furthermore subject to C-like substitutions for en (new line), et (tab), eb (backspace), er (carriage return), ef (form feed), e<span Class="emphasis">digits</span> (octal), and ex<span Class="emphasis">digits</span> (hexadecimal). A backslash preceding any other character within single-quoted text quotes that single character, whatever it is. 
<p class="level0">Within an argument, text that is enclosed in backquotes (`) is taken as a command line that is passed to the shell. The output of the command (with any trailing newline removed) replaces the backquoted text. 
<p class="level0">If an unquoted colon (:) followed by a psql variable name appears within an argument, it is replaced by the variable*(Aqs value, as described in SQL Interpolation. 
<p class="level0">Some commands take an SQL identifier (such as a table name) as argument. These arguments follow the syntax rules of SQL: Unquoted letters are forced to lowercase, while double quotes (") protect letters from case conversion and allow incorporation of whitespace into the identifier. Within double quotes, paired double quotes reduce to a single double quote in the resulting name. For example, FOO"BAR"BAZ is interpreted as fooBARbaz, and "A weird"" name" becomes A weird" name. 
<p class="level0">Parsing for arguments stops at the end of the line, or when another unquoted backslash is found. An unquoted backslash is taken as the beginning of a new meta-command. The special sequence ee (two backslashes) marks the end of arguments and continues parsing SQL commands, if any. That way SQL and psql commands can be freely mixed on a line. But in any case, the arguments of a meta-command cannot continue beyond the end of the line. 
<p class="level0">The following meta-commands are defined: 
<p class="level0">ea 
<p class="level1">If the current table output format is unaligned, it is switched to aligned. If it is not unaligned, it is set to unaligned. This command is kept for backwards compatibility. See <span Class="bold">epset</span> for a more general solution. 
<p class="level0">
<p class="level0">ec or econnect [ <span Class="emphasis">dbname</span> [ <span Class="emphasis">username</span> ] [ <span Class="emphasis">host</span> ] [ <span Class="emphasis">port</span> ] ] | <span Class="emphasis">conninfo</span> 
<p class="level1">Establishes a new connection to a PostgreSQL server. The connection parameters to use can be specified either using a positional syntax, or using conninfo connection strings as detailed in Section 31.1.1, (lqConnection Strings(rq, in the documentation. 
<p class="level1">When using positional parameters, if any of <span Class="emphasis">dbname</span>, <span Class="emphasis">username</span>, <span Class="emphasis">host</span> or <span Class="emphasis">port</span> are omitted or specified as -, the value of that parameter from the previous connection is used; if there is no previous connection, the libpq default for the parameter*(Aqs value is used. When using conninfo strings, no values from the previous connection are used for the new connection. 
<p class="level1">If the new connection is successfully made, the previous connection is closed. If the connection attempt failed (wrong user name, access denied, etc.), the previous connection will only be kept if psql is in interactive mode. When executing a non-interactive script, processing will immediately stop with an error. This distinction was chosen as a user convenience against typos on the one hand, and a safety mechanism that scripts are not accidentally acting on the wrong database on the other hand. 
<p class="level1">Examples: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
=&gt; ec mydb myuser host.dom 6432
=&gt; ec service=foo
=&gt; ec "host=localhost port=5432 dbname=mydb connect_timeout=10 sslmode=disable"
=&gt; ec postgresql://tom@localhost/mydb?application_name=myapp
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">eC [ <span Class="emphasis">title</span> ] 
<p class="level1">Sets the title of any tables being printed as the result of a query or unset any such title. This command is equivalent to epset title <span Class="emphasis">title</span>. (The name of this command derives from (lqcaption(rq, as it was previously only used to set the caption in an HTML table.) 
<p class="level0">
<p class="level0">ecd [ <span Class="emphasis">directory</span> ] 
<p class="level1">Changes the current working directory to <span Class="emphasis">directory</span>. Without argument, changes to the current user*(Aqs home directory. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Tip</span> 
<p class="level2"><br>To print your current working directory, use e! pwd. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">econninfo 
<p class="level1">Outputs information about the current database connection. 
<p class="level0">
<p class="level0">ecopy { <span Class="emphasis">table</span> [ ( <span Class="emphasis">column_list</span> ) ] | ( <span Class="emphasis">query</span> ) } { from | to } { <span Class="emphasis">*(Aqfilename*(Aq</span> | program <span Class="emphasis">*(Aqcommand*(Aq</span> | stdin | stdout | pstdin | pstdout } [ [ with ] ( <span Class="emphasis">option</span> [, ...] ) ] 
<p class="level1">Performs a frontend (client) copy. This is an operation that runs an SQL <span Class="bold">COPY</span>(7) command, but instead of the server reading or writing the specified file, psql reads or writes the file and routes the data between the server and the local file system. This means that file accessibility and privileges are those of the local user, not the server, and no SQL superuser privileges are required. 
<p class="level1">When program is specified, <span Class="emphasis">command</span> is executed by psql and the data passed from or to <span Class="emphasis">command</span> is routed between the server and the client. Again, the execution privileges are those of the local user, not the server, and no SQL superuser privileges are required. 
<p class="level1">For ecopy ... from stdin, data rows are read from the same source that issued the command, continuing until e. is read or the stream reaches EOF. This option is useful for populating tables in-line within a SQL script file. For ecopy ... to stdout, output is sent to the same place as psql command output, and the COPY <span Class="emphasis">count</span> command status is not printed (since it might be confused with a data row). To read/write psql*(Aqs standard input or output regardless of the current command source or eo option, write from pstdin or to pstdout. 
<p class="level1">The syntax of this command is similar to that of the SQL <span Class="bold">COPY</span>(7) command. All options other than the data source/destination are as specified for <span Class="bold">COPY</span>(7). Because of this, special parsing rules apply to the <span Class="bold">ecopy</span> command. In particular, psql*(Aqs variable substitution rules and backslash escapes do not apply. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Tip</span> 
<p class="level2"><br>This operation is not as efficient as the SQL <span Class="bold">COPY</span> command because all data must pass through the client/server connection. For large amounts of data the SQL command might be preferable. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">ecopyright 
<p class="level1">Shows the copyright and distribution terms of PostgreSQL. 
<p class="level0">
<p class="level0">ed[S+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">For each relation (table, view, index, sequence, or foreign table) or composite type matching the <span Class="emphasis">pattern</span>, show all columns, their types, the tablespace (if not the default) and any special attributes such as NOT NULL or defaults. Associated indexes, constraints, rules, and triggers are also shown. For foreign tables, the associated foreign server is shown as well. ((lqMatching the pattern(rq is defined in Patterns below.) 
<p class="level1">For some types of relation, ed shows additional information for each column: column values for sequences, indexed expression for indexes and foreign data wrapper options for foreign tables. 
<p class="level1">The command form ed+ is identical, except that more information is displayed: any comments associated with the columns of the table are shown, as is the presence of OIDs in the table, the view definition if the relation is a view, a non-default replica identity setting. 
<p class="level1">By default, only user-created objects are shown; supply a pattern or the S modifier to include system objects. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Note</span> 
<p class="level2"><br>If <span Class="bold">ed</span> is used without a <span Class="emphasis">pattern</span> argument, it is equivalent to <span Class="bold">edtvsE</span> which will show a list of all visible tables, views, sequences and foreign tables. This is purely a convenience measure. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">eda[S] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists aggregate functions, together with their return type and the data types they operate on. If <span Class="emphasis">pattern</span> is specified, only aggregates whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the S modifier to include system objects. 
<p class="level0">
<p class="level0">edb[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists tablespaces. If <span Class="emphasis">pattern</span> is specified, only tablespaces whose names match the pattern are shown. If + is appended to the command name, each object is listed with its associated permissions. 
<p class="level0">
<p class="level0">edc[S+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists conversions between character-set encodings. If <span Class="emphasis">pattern</span> is specified, only conversions whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the S modifier to include system objects. If + is appended to the command name, each object is listed with its associated description. 
<p class="level0">
<p class="level0">edC[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists type casts. If <span Class="emphasis">pattern</span> is specified, only casts whose source or target types match the pattern are listed. If + is appended to the command name, each object is listed with its associated description. 
<p class="level0">
<p class="level0">edd[S] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Shows the descriptions of objects of type constraint, operator class, operator family, rule, and trigger. All other comments may be viewed by the respective backslash commands for those object types. 
<p class="level1">edd displays descriptions for objects matching the <span Class="emphasis">pattern</span>, or of visible objects of the appropriate type if no argument is given. But in either case, only objects that have a description are listed. By default, only user-created objects are shown; supply a pattern or the S modifier to include system objects. 
<p class="level1">Descriptions for objects can be created with the <span Class="bold">COMMENT</span>(7) SQL command. 
<p class="level0">
<p class="level0">eddp [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists default access privilege settings. An entry is shown for each role (and schema, if applicable) for which the default privilege settings have been changed from the built-in defaults. If <span Class="emphasis">pattern</span> is specified, only entries whose role name or schema name matches the pattern are listed. 
<p class="level1">The ALTER DEFAULT PRIVILEGES (<span Class="bold">ALTER_DEFAULT_PRIVILEGES</span>(7)) command is used to set default access privileges. The meaning of the privilege display is explained under <span Class="bold">GRANT</span>(7). 
<p class="level0">
<p class="level0">edD[S+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists domains. If <span Class="emphasis">pattern</span> is specified, only domains whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the S modifier to include system objects. If + is appended to the command name, each object is listed with its associated permissions and description. 
<p class="level0">
<p class="level0">edE[S+] [ <span Class="emphasis">pattern</span> ] <br>edi[S+] [ <span Class="emphasis">pattern</span> ] <br>edm[S+] [ <span Class="emphasis">pattern</span> ] <br>eds[S+] [ <span Class="emphasis">pattern</span> ] <br>edt[S+] [ <span Class="emphasis">pattern</span> ] <br>edv[S+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">In this group of commands, the letters E, i, m, s, t, and v stand for foreign table, index, materialized view, sequence, table, and view, respectively. You can specify any or all of these letters, in any order, to obtain a listing of objects of these types. For example, edit lists indexes and tables. If + is appended to the command name, each object is listed with its physical size on disk and its associated description, if any. If <span Class="emphasis">pattern</span> is specified, only objects whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the S modifier to include system objects. 
<p class="level0">
<p class="level0">edes[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists foreign servers (mnemonic: (lqexternal servers(rq). If <span Class="emphasis">pattern</span> is specified, only those servers whose name matches the pattern are listed. If the form edes+ is used, a full description of each server is shown, including the server*(Aqs ACL, type, version, options, and description. 
<p class="level0">
<p class="level0">edet[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists foreign tables (mnemonic: (lqexternal tables(rq). If <span Class="emphasis">pattern</span> is specified, only entries whose table name or schema name matches the pattern are listed. If the form edet+ is used, generic options and the foreign table description are also displayed. 
<p class="level0">
<p class="level0">edeu[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists user mappings (mnemonic: (lqexternal users(rq). If <span Class="emphasis">pattern</span> is specified, only those mappings whose user names match the pattern are listed. If the form edeu+ is used, additional information about each mapping is shown. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Caution</span> 
<p class="level2"><br>
<p class="level2">edeu+ might also display the user name and password of the remote user, so care should be taken not to disclose them. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">edew[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists foreign-data wrappers (mnemonic: (lqexternal wrappers(rq). If <span Class="emphasis">pattern</span> is specified, only those foreign-data wrappers whose name matches the pattern are listed. If the form edew+ is used, the ACL, options, and description of the foreign-data wrapper are also shown. 
<p class="level0">
<p class="level0">edf[antwS+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists functions, together with their arguments, return types, and function types, which are classified as (lqagg(rq (aggregate), (lqnormal(rq, (lqtrigger(rq, or (lqwindow(rq. To display only functions of specific type(s), add the corresponding letters a, n, t, or w to the command. If <span Class="emphasis">pattern</span> is specified, only functions whose names match the pattern are shown. By default, only user-created objects are shown; supply a pattern or the S modifier to include system objects. If the form edf+ is used, additional information about each function is shown, including security classification, volatility, owner, language, source code and description. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Tip</span> 
<p class="level2"><br>To look up functions taking arguments or returning values of a specific type, use your pager*(Aqs search capability to scroll through the edf output. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">edF[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists text search configurations. If <span Class="emphasis">pattern</span> is specified, only configurations whose names match the pattern are shown. If the form edF+ is used, a full description of each configuration is shown, including the underlying text search parser and the dictionary list for each parser token type. 
<p class="level0">
<p class="level0">edFd[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists text search dictionaries. If <span Class="emphasis">pattern</span> is specified, only dictionaries whose names match the pattern are shown. If the form edFd+ is used, additional information is shown about each selected dictionary, including the underlying text search template and the option values. 
<p class="level0">
<p class="level0">edFp[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists text search parsers. If <span Class="emphasis">pattern</span> is specified, only parsers whose names match the pattern are shown. If the form edFp+ is used, a full description of each parser is shown, including the underlying functions and the list of recognized token types. 
<p class="level0">
<p class="level0">edFt[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists text search templates. If <span Class="emphasis">pattern</span> is specified, only templates whose names match the pattern are shown. If the form edFt+ is used, additional information is shown about each template, including the underlying function names. 
<p class="level0">
<p class="level0">edg[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists database roles. (Since the concepts of (lqusers(rq and (lqgroups(rq have been unified into (lqroles(rq, this command is now equivalent to edu.) If <span Class="emphasis">pattern</span> is specified, only those roles whose names match the pattern are listed. If the form edg+ is used, additional information is shown about each role; currently this adds the comment for each role. 
<p class="level0">
<p class="level0">edl 
<p class="level1">This is an alias for <span Class="bold">elo_list</span>, which shows a list of large objects. 
<p class="level0">
<p class="level0">edL[S+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists procedural languages. If <span Class="emphasis">pattern</span> is specified, only languages whose names match the pattern are listed. By default, only user-created languages are shown; supply the S modifier to include system objects. If + is appended to the command name, each language is listed with its call handler, validator, access privileges, and whether it is a system object. 
<p class="level0">
<p class="level0">edn[S+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists schemas (namespaces). If <span Class="emphasis">pattern</span> is specified, only schemas whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the S modifier to include system objects. If + is appended to the command name, each object is listed with its associated permissions and description, if any. 
<p class="level0">
<p class="level0">edo[S+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists operators with their operand and result types. If <span Class="emphasis">pattern</span> is specified, only operators whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the S modifier to include system objects. If + is appended to the command name, additional information about each operator is shown, currently just the name of the underlying function. 
<p class="level0">
<p class="level0">edO[S+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists collations. If <span Class="emphasis">pattern</span> is specified, only collations whose names match the pattern are listed. By default, only user-created objects are shown; supply a pattern or the S modifier to include system objects. If + is appended to the command name, each collation is listed with its associated description, if any. Note that only collations usable with the current database*(Aqs encoding are shown, so the results may vary in different databases of the same installation. 
<p class="level0">
<p class="level0">edp [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists tables, views and sequences with their associated access privileges. If <span Class="emphasis">pattern</span> is specified, only tables, views and sequences whose names match the pattern are listed. 
<p class="level1">The <span Class="bold">GRANT</span>(7) and <span Class="bold">REVOKE</span>(7) commands are used to set access privileges. The meaning of the privilege display is explained under <span Class="bold">GRANT</span>(7). 
<p class="level0">
<p class="level0">edrds [ <span Class="emphasis">role-pattern</span> [ <span Class="emphasis">database-pattern</span> ] ] 
<p class="level1">Lists defined configuration settings. These settings can be role-specific, database-specific, or both. <span Class="emphasis">role-pattern</span> and <span Class="emphasis">database-pattern</span> are used to select specific roles and databases to list, respectively. If omitted, or if * is specified, all settings are listed, including those not role-specific or database-specific, respectively. 
<p class="level1">The ALTER ROLE (<span Class="bold">ALTER_ROLE</span>(7)) and ALTER DATABASE (<span Class="bold">ALTER_DATABASE</span>(7)) commands are used to define per-role and per-database configuration settings. 
<p class="level0">
<p class="level0">edT[S+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists data types. If <span Class="emphasis">pattern</span> is specified, only types whose names match the pattern are listed. If + is appended to the command name, each type is listed with its internal name and size, its allowed values if it is an enum type, and its associated permissions. By default, only user-created objects are shown; supply a pattern or the S modifier to include system objects. 
<p class="level0">
<p class="level0">edu[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists database roles. (Since the concepts of (lqusers(rq and (lqgroups(rq have been unified into (lqroles(rq, this command is now equivalent to edg.) If <span Class="emphasis">pattern</span> is specified, only those roles whose names match the pattern are listed. If the form edu+ is used, additional information is shown about each role; currently this adds the comment for each role. 
<p class="level0">
<p class="level0">edx[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists installed extensions. If <span Class="emphasis">pattern</span> is specified, only those extensions whose names match the pattern are listed. If the form edx+ is used, all the objects belonging to each matching extension are listed. 
<p class="level0">
<p class="level0">edy[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists event triggers. If <span Class="emphasis">pattern</span> is specified, only those event triggers whose names match the pattern are listed. If + is appended to the command name, each object is listed with its associated description. 
<p class="level0">
<p class="level0">ee or eedit [ <span Class="emphasis">filename</span> ] [ <span Class="emphasis">line_number</span> ] 
<p class="level1">If <span Class="emphasis">filename</span> is specified, the file is edited; after the editor exits, its content is copied back to the query buffer. If no <span Class="emphasis">filename</span> is given, the current query buffer is copied to a temporary file which is then edited in the same fashion. 
<p class="level1">The new query buffer is then re-parsed according to the normal rules of psql, where the whole buffer is treated as a single line. (Thus you cannot make scripts this way. Use <span Class="bold">ei</span> for that.) This means that if the query ends with (or contains) a semicolon, it is immediately executed. Otherwise it will merely wait in the query buffer; type semicolon or eg to send it, or er to cancel. 
<p class="level1">If a line number is specified, psql will position the cursor on the specified line of the file or query buffer. Note that if a single all-digits argument is given, psql assumes it is a line number, not a file name. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Tip</span> 
<p class="level2"><br>See under ENVIRONMENT for how to configure and customize your editor. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">eecho <span Class="emphasis">text</span> [ ... ] 
<p class="level1">Prints the arguments to the standard output, separated by one space and followed by a newline. This can be useful to intersperse information in the output of scripts. For example: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
=&gt; <span class="bold">eecho `date`</span>
Tue Oct 26 21:40:57 CEST 1999
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">If the first argument is an unquoted -n the trailing newline is not written. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Tip</span> 
<p class="level2"><br>If you use the <span Class="bold">eo</span> command to redirect your query output you might wish to use <span Class="bold">eqecho</span> instead of this command. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">eef [ <span Class="emphasis">function_description</span> [ <span Class="emphasis">line_number</span> ] ] 
<p class="level1">This command fetches and edits the definition of the named function, in the form of a <span Class="bold">CREATE OR REPLACE FUNCTION</span> command. Editing is done in the same way as for eedit. After the editor exits, the updated command waits in the query buffer; type semicolon or eg to send it, or er to cancel. 
<p class="level1">The target function can be specified by name alone, or by name and arguments, for example foo(integer, text). The argument types must be given if there is more than one function of the same name. 
<p class="level1">If no function is specified, a blank <span Class="bold">CREATE FUNCTION</span> template is presented for editing. 
<p class="level1">If a line number is specified, psql will position the cursor on the specified line of the function body. (Note that the function body typically does not begin on the first line of the file.) 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Tip</span> 
<p class="level2"><br>See under ENVIRONMENT for how to configure and customize your editor. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">eencoding [ <span Class="emphasis">encoding</span> ] 
<p class="level1">Sets the client character set encoding. Without an argument, this command shows the current encoding. 
<p class="level0">
<p class="level0">ef [ <span Class="emphasis">string</span> ] 
<p class="level1">Sets the field separator for unaligned query output. The default is the vertical bar (|). See also <span Class="bold">epset</span> for a generic way of setting output options. 
<p class="level0">
<p class="level0">eg [ <span Class="emphasis">filename</span> ] <br>eg [ |<span Class="emphasis">command</span> ] 
<p class="level1">Sends the current query input buffer to the server, and optionally stores the query*(Aqs output in <span Class="emphasis">filename</span> or pipes the output to the shell command <span Class="emphasis">command</span>. The file or command is written to only if the query successfully returns zero or more tuples, not if the query fails or is a non-data-returning SQL command. 
<p class="level1">A bare eg is essentially equivalent to a semicolon. A eg with argument is a (lqone-shot(rq alternative to the <span Class="bold">eo</span> command. 
<p class="level0">
<p class="level0">egset [ <span Class="emphasis">prefix</span> ] 
<p class="level1">Sends the current query input buffer to the server and stores the query*(Aqs output into psql variables (see Variables). The query to be executed must return exactly one row. Each column of the row is stored into a separate variable, named the same as the column. For example: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
=&gt; <span class="bold">SELECT *(Aqhello*(Aq AS var1, 10 AS var2</span>
-&gt; <span class="bold">egset</span>
=&gt; <span class="bold">eecho :var1 :var2</span>
hello 10
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">If you specify a <span Class="emphasis">prefix</span>, that string is prepended to the query*(Aqs column names to create the variable names to use: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
=&gt; <span class="bold">SELECT *(Aqhello*(Aq AS var1, 10 AS var2</span>
-&gt; <span class="bold">egset result_</span>
=&gt; <span class="bold">eecho :result_var1 :result_var2</span>
hello 10
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">If a column result is NULL, the corresponding variable is unset rather than being set. 
<p class="level1">If the query fails or does not return one row, no variables are changed. 
<p class="level0">
<p class="level0">eh or ehelp [ <span Class="emphasis">command</span> ] 
<p class="level1">Gives syntax help on the specified SQL command. If <span Class="emphasis">command</span> is not specified, then psql will list all the commands for which syntax help is available. If <span Class="emphasis">command</span> is an asterisk (*), then syntax help on all SQL commands is shown. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Note</span> 
<p class="level2"><br>To simplify typing, commands that consists of several words do not have to be quoted. Thus it is fine to type <span Class="bold">ehelp alter table</span>. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">eH or ehtml 
<p class="level1">Turns on HTML query output format. If the HTML format is already on, it is switched back to the default aligned text format. This command is for compatibility and convenience, but see <span Class="bold">epset</span> about setting other output options. 
<p class="level0">
<p class="level0">ei or einclude <span Class="emphasis">filename</span> 
<p class="level1">Reads input from the file <span Class="emphasis">filename</span> and executes it as though it had been typed on the keyboard. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Note</span> 
<p class="level2"><br>If you want to see the lines on the screen as they are read you must set the variable <span Class="emphasis">ECHO</span> to all. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">eir or einclude_relative <span Class="emphasis">filename</span> 
<p class="level1">The eir command is similar to ei, but resolves relative file names differently. When executing in interactive mode, the two commands behave identically. However, when invoked from a script, eir interprets file names relative to the directory in which the script is located, rather than the current working directory. 
<p class="level0">
<p class="level0">el[+] or elist[+] [ <span Class="emphasis">pattern</span> ] 
<p class="level1">List the databases in the server and show their names, owners, character set encodings, and access privileges. If <span Class="emphasis">pattern</span> is specified, only databases whose names match the pattern are listed. If + is appended to the command name, database sizes, default tablespaces, and descriptions are also displayed. (Size information is only available for databases that the current user can connect to.) 
<p class="level0">
<p class="level0">elo_export <span Class="emphasis">loid</span> <span Class="emphasis">filename</span> 
<p class="level1">Reads the large object with OID <span Class="emphasis">loid</span> from the database and writes it to <span Class="emphasis">filename</span>. Note that this is subtly different from the server function <span Class="bold">lo_export</span>, which acts with the permissions of the user that the database server runs as and on the server*(Aqs file system. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Tip</span> 
<p class="level2"><br>Use <span Class="bold">elo_list</span> to find out the large object*(Aqs OID. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">elo_import <span Class="emphasis">filename</span> [ <span Class="emphasis">comment</span> ] 
<p class="level1">Stores the file into a PostgreSQL large object. Optionally, it associates the given comment with the object. Example: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
foo=&gt; <span class="bold">elo_import *(Aq/home/peter/pictures/photo.xcf*(Aq *(Aqa picture of me*(Aq</span>
lo_import 152801
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">The response indicates that the large object received object ID 152801, which can be used to access the newly-created large object in the future. For the sake of readability, it is recommended to always associate a human-readable comment with every object. Both OIDs and comments can be viewed with the <span Class="bold">elo_list</span> command. 
<p class="level1">Note that this command is subtly different from the server-side <span Class="bold">lo_import</span> because it acts as the local user on the local file system, rather than the server*(Aqs user and file system. 
<p class="level0">
<p class="level0">elo_list 
<p class="level1">Shows a list of all PostgreSQL large objects currently stored in the database, along with any comments provided for them. 
<p class="level0">
<p class="level0">elo_unlink <span Class="emphasis">loid</span> 
<p class="level1">Deletes the large object with OID <span Class="emphasis">loid</span> from the database. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Tip</span> 
<p class="level2"><br>Use <span Class="bold">elo_list</span> to find out the large object*(Aqs OID. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">eo or eout [ <span Class="emphasis">filename</span> ] <br>eo or eout [ |<span Class="emphasis">command</span> ] 
<p class="level1">Arranges to save future query results to the file <span Class="emphasis">filename</span> or pipe future results to the shell command <span Class="emphasis">command</span>. If no argument is specified, the query output is reset to the standard output. 
<p class="level1">(lqQuery results(rq includes all tables, command responses, and notices obtained from the database server, as well as output of various backslash commands that query the database (such as <span Class="bold">ed</span>), but not error messages. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Tip</span> 
<p class="level2"><br>To intersperse text output in between query results, use <span Class="bold">eqecho</span>. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">ep or eprint 
<p class="level1">Print the current query buffer to the standard output. 
<p class="level0">
<p class="level0">epassword [ <span Class="emphasis">username</span> ] 
<p class="level1">Changes the password of the specified user (by default, the current user). This command prompts for the new password, encrypts it, and sends it to the server as an <span Class="bold">ALTER ROLE</span> command. This makes sure that the new password does not appear in cleartext in the command history, the server log, or elsewhere. 
<p class="level0">
<p class="level0">eprompt [ <span Class="emphasis">text</span> ] <span Class="emphasis">name</span> 
<p class="level1">Prompts the user to supply text, which is assigned to the variable <span Class="emphasis">name</span>. An optional prompt string, <span Class="emphasis">text</span>, can be specified. (For multiword prompts, surround the text with single quotes.) 
<p class="level1">By default, eprompt uses the terminal for input and output. However, if the <span Class="bold">-f</span> command line switch was used, eprompt uses standard input and standard output. 
<p class="level0">
<p class="level0">epset [ <span Class="emphasis">option</span> [ <span Class="emphasis">value</span> ] ] 
<p class="level1">This command sets options affecting the output of query result tables. <span Class="emphasis">option</span> indicates which option is to be set. The semantics of <span Class="emphasis">value</span> vary depending on the selected option. For some options, omitting <span Class="emphasis">value</span> causes the option to be toggled or unset, as described under the particular option. If no such behavior is mentioned, then omitting <span Class="emphasis">value</span> just results in the current setting being displayed. 
<p class="level1">
<p class="level1"><span Class="bold">epset</span> without any arguments displays the current status of all printing options. 
<p class="level1">Adjustable printing options are: 
<p class="level1">border 
<p class="level2">The <span Class="emphasis">value</span> must be a number. In general, the higher the number the more borders and lines the tables will have, but this depends on the particular format. In HTML format, this will translate directly into the border=... attribute; in the other formats only values 0 (no border), 1 (internal dividing lines), and 2 (table frame) make sense. latex and latex-longtable also support a border value of 3 which adds a dividing line between each row. 
<p class="level1">
<p class="level1">columns 
<p class="level2">Sets the target width for the wrapped format, and also the width limit for determining whether output is wide enough to require the pager or switch to the vertical display in expanded auto mode. Zero (the default) causes the target width to be controlled by the environment variable <span Class="bold">COLUMNS</span>, or the detected screen width if <span Class="bold">COLUMNS</span> is not set. In addition, if columns is zero then the wrapped format only affects screen output. If columns is nonzero then file and pipe output is wrapped to that width as well. 
<p class="level1">
<p class="level1">expanded (or x) 
<p class="level2">If <span Class="emphasis">value</span> is specified it must be either on or off, which will enable or disable expanded mode, or auto. If <span Class="emphasis">value</span> is omitted the command toggles between the on and off settings. When expanded mode is enabled, query results are displayed in two columns, with the column name on the left and the data on the right. This mode is useful if the data wouldn*(Aqt fit on the screen in the normal (lqhorizontal(rq mode. In the auto setting, the expanded mode is used whenever the query output is wider than the screen, otherwise the regular mode is used. The auto setting is only effective in the aligned and wrapped formats. In other formats, it always behaves as if the expanded mode is off. 
<p class="level1">
<p class="level1">fieldsep 
<p class="level2">Specifies the field separator to be used in unaligned output format. That way one can create, for example, tab- or comma-separated output, which other programs might prefer. To set a tab as field separator, type epset fieldsep *(Aqet*(Aq. The default field separator is *(Aq|*(Aq (a vertical bar). 
<p class="level1">
<p class="level1">fieldsep_zero 
<p class="level2">Sets the field separator to use in unaligned output format to a zero byte. 
<p class="level1">
<p class="level1">footer 
<p class="level2">If <span Class="emphasis">value</span> is specified it must be either on or off which will enable or disable display of the table footer (the (<span Class="emphasis">n</span> rows) count). If <span Class="emphasis">value</span> is omitted the command toggles footer display on or off. 
<p class="level1">
<p class="level1">format 
<p class="level2">Sets the output format to one of unaligned, aligned, wrapped, html, latex (uses tabular), latex-longtable, or troff-ms. Unique abbreviations are allowed. (That would mean one letter is enough.) 
<p class="level2">unaligned format writes all columns of a row on one line, separated by the currently active field separator. This is useful for creating output that might be intended to be read in by other programs (for example, tab-separated or comma-separated format). 
<p class="level2">aligned format is the standard, human-readable, nicely formatted text output; this is the default. 
<p class="level2">wrapped format is like aligned but wraps wide data values across lines to make the output fit in the target column width. The target width is determined as described under the columns option. Note that psql will not attempt to wrap column header titles; therefore, wrapped format behaves the same as aligned if the total width needed for column headers exceeds the target. 
<p class="level2">The html, latex, latex-longtable, and troff-ms formats put out tables that are intended to be included in documents using the respective mark-up language. They are not complete documents! This might not be necessary in HTML, but in LaTeX you must have a complete document wrapper. latex-longtable also requires the LaTeX longtable and booktabs packages. 
<p class="level1">
<p class="level1">linestyle 
<p class="level2">Sets the border line drawing style to one of ascii, old-ascii or unicode. Unique abbreviations are allowed. (That would mean one letter is enough.) The default setting is ascii. This option only affects the aligned and wrapped output formats. 
<p class="level2">ascii style uses plain ASCII characters. Newlines in data are shown using a + symbol in the right-hand margin. When the wrapped format wraps data from one line to the next without a newline character, a dot (.) is shown in the right-hand margin of the first line, and again in the left-hand margin of the following line. 
<p class="level2">old-ascii style uses plain ASCII characters, using the formatting style used in PostgreSQL 8.4 and earlier. Newlines in data are shown using a : symbol in place of the left-hand column separator. When the data is wrapped from one line to the next without a newline character, a ; symbol is used in place of the left-hand column separator. 
<p class="level2">unicode style uses Unicode box-drawing characters. Newlines in data are shown using a carriage return symbol in the right-hand margin. When the data is wrapped from one line to the next without a newline character, an ellipsis symbol is shown in the right-hand margin of the first line, and again in the left-hand margin of the following line. 
<p class="level2">When the border setting is greater than zero, this option also determines the characters with which the border lines are drawn. Plain ASCII characters work everywhere, but Unicode characters look nicer on displays that recognize them. 
<p class="level1">
<p class="level1">null 
<p class="level2">Sets the string to be printed in place of a null value. The default is to print nothing, which can easily be mistaken for an empty string. For example, one might prefer epset null *(Aq(null)*(Aq. 
<p class="level1">
<p class="level1">numericlocale 
<p class="level2">If <span Class="emphasis">value</span> is specified it must be either on or off which will enable or disable display of a locale-specific character to separate groups of digits to the left of the decimal marker. If <span Class="emphasis">value</span> is omitted the command toggles between regular and locale-specific numeric output. 
<p class="level1">
<p class="level1">pager 
<p class="level2">Controls use of a pager program for query and psql help output. If the environment variable <span Class="bold">PAGER</span> is set, the output is piped to the specified program. Otherwise a platform-dependent default (such as more) is used. 
<p class="level2">When the pager option is off, the pager program is not used. When the pager option is on, the pager is used when appropriate, i.e., when the output is to a terminal and will not fit on the screen. The pager option can also be set to always, which causes the pager to be used for all terminal output regardless of whether it fits on the screen. epset pager without a <span Class="emphasis">value</span> toggles pager use on and off. 
<p class="level1">
<p class="level1">recordsep 
<p class="level2">Specifies the record (line) separator to use in unaligned output format. The default is a newline character. 
<p class="level1">
<p class="level1">recordsep_zero 
<p class="level2">Sets the record separator to use in unaligned output format to a zero byte. 
<p class="level1">
<p class="level1">tableattr (or T) 
<p class="level2">In HTML format, this specifies attributes to be placed inside the table tag. This could for example be cellpadding or bgcolor. Note that you probably don*(Aqt want to specify border here, as that is already taken care of by epset border. If no <span Class="emphasis">value</span> is given, the table attributes are unset. 
<p class="level2">In latex-longtable format, this controls the proportional width of each column containing a left-aligned data type. It is specified as a whitespace-separated list of values, e.g. *(Aq0.2 0.2 0.6*(Aq. Unspecified output columns use the last specified value. 
<p class="level1">
<p class="level1">title 
<p class="level2">Sets the table title for any subsequently printed tables. This can be used to give your output descriptive tags. If no <span Class="emphasis">value</span> is given, the title is unset. 
<p class="level1">
<p class="level1">tuples_only (or t) 
<p class="level2">If <span Class="emphasis">value</span> is specified it must be either on or off which will enable or disable tuples-only mode. If <span Class="emphasis">value</span> is omitted the command toggles between regular and tuples-only output. Regular output includes extra information such as column headers, titles, and various footers. In tuples-only mode, only actual table data is shown. 
<p class="level1">
<p class="level1">Illustrations of how these different formats look can be seen in the EXAMPLES section. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Tip</span> 
<p class="level2"><br>There are various shortcut commands for <span Class="bold">epset</span>. See <span Class="bold">ea</span>, <span Class="bold">eC</span>, <span Class="bold">eH</span>, <span Class="bold">et</span>, <span Class="bold">eT</span>, and <span Class="bold">ex</span>. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">eq or equit 
<p class="level1">Quits the psql program. In a script file, only execution of that script is terminated. 
<p class="level0">
<p class="level0">eqecho <span Class="emphasis">text</span> [ ... ] 
<p class="level1">This command is identical to <span Class="bold">eecho</span> except that the output will be written to the query output channel, as set by <span Class="bold">eo</span>. 
<p class="level0">
<p class="level0">er or ereset 
<p class="level1">Resets (clears) the query buffer. 
<p class="level0">
<p class="level0">es [ <span Class="emphasis">filename</span> ] 
<p class="level1">Print psql*(Aqs command line history to <span Class="emphasis">filename</span>. If <span Class="emphasis">filename</span> is omitted, the history is written to the standard output (using the pager if appropriate). This command is not available if psql was built without Readline support. 
<p class="level0">
<p class="level0">eset [ <span Class="emphasis">name</span> [ <span Class="emphasis">value</span> [ ... ] ] ] 
<p class="level1">Sets the psql variable <span Class="emphasis">name</span> to <span Class="emphasis">value</span>, or if more than one value is given, to the concatenation of all of them. If only one argument is given, the variable is set with an empty value. To unset a variable, use the <span Class="bold">eunset</span> command. 
<p class="level1"><span Class="bold">eset</span> without any arguments displays the names and values of all currently-set psql variables. 
<p class="level1">Valid variable names can contain letters, digits, and underscores. See the section Variables below for details. Variable names are case-sensitive. 
<p class="level1">Although you are welcome to set any variable to anything you want, psql treats several variables as special. They are documented in the section about variables. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Note</span> 
<p class="level2"><br>This command is unrelated to the SQL command <span Class="bold">SET</span>(7). 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">esetenv <span Class="emphasis">name</span> [ <span Class="emphasis">value</span> ] 
<p class="level1">Sets the environment variable <span Class="emphasis">name</span> to <span Class="emphasis">value</span>, or if the <span Class="emphasis">value</span> is not supplied, unsets the environment variable. Example: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
testdb=&gt; <span class="bold">esetenv PAGER less</span>
testdb=&gt; <span class="bold">esetenv LESS -imx4F</span>
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">esf[+] <span Class="emphasis">function_description</span> 
<p class="level1">This command fetches and shows the definition of the named function, in the form of a <span Class="bold">CREATE OR REPLACE FUNCTION</span> command. The definition is printed to the current query output channel, as set by <span Class="bold">eo</span>. 
<p class="level1">The target function can be specified by name alone, or by name and arguments, for example foo(integer, text). The argument types must be given if there is more than one function of the same name. 
<p class="level1">If + is appended to the command name, then the output lines are numbered, with the first line of the function body being line 1. 
<p class="level0">
<p class="level0">et 
<p class="level1">Toggles the display of output column name headings and row count footer. This command is equivalent to epset tuples_only and is provided for convenience. 
<p class="level0">
<p class="level0">eT <span Class="emphasis">table_options</span> 
<p class="level1">Specifies attributes to be placed within the table tag in HTML output format. This command is equivalent to epset tableattr <span Class="emphasis">table_options</span>. 
<p class="level0">
<p class="level0">etiming [ <span Class="emphasis">on</span> | <span Class="emphasis">off</span> ] 
<p class="level1">Without parameter, toggles a display of how long each SQL statement takes, in milliseconds. With parameter, sets same. 
<p class="level0">
<p class="level0">eunset <span Class="emphasis">name</span> 
<p class="level1">Unsets (deletes) the psql variable <span Class="emphasis">name</span>. 
<p class="level0">
<p class="level0">ew or ewrite <span Class="emphasis">filename</span> <br>ew or ewrite |<span Class="emphasis">command</span> 
<p class="level1">Outputs the current query buffer to the file <span Class="emphasis">filename</span> or pipes it to the shell command <span Class="emphasis">command</span>. 
<p class="level0">
<p class="level0">ewatch [ <span Class="emphasis">seconds</span> ] 
<p class="level1">Repeatedly execute the current query buffer (like eg) until interrupted or the query fails. Wait the specified number of seconds (default 2) between executions. 
<p class="level0">
<p class="level0">ex [ <span Class="emphasis">on</span> | <span Class="emphasis">off</span> | <span Class="emphasis">auto</span> ] 
<p class="level1">Sets or toggles expanded table formatting mode. As such it is equivalent to epset expanded. 
<p class="level0">
<p class="level0">ez [ <span Class="emphasis">pattern</span> ] 
<p class="level1">Lists tables, views and sequences with their associated access privileges. If a <span Class="emphasis">pattern</span> is specified, only tables, views and sequences whose names match the pattern are listed. 
<p class="level1">This is an alias for <span Class="bold">edp</span> ((lqdisplay privileges(rq). 
<p class="level0">
<p class="level0">e! [ <span Class="emphasis">command</span> ] 
<p class="level1">Escapes to a separate shell or executes the shell command <span Class="emphasis">command</span>. The arguments are not further interpreted; the shell will see them as-is. In particular, the variable substitution rules and backslash escapes do not apply. 
<p class="level0">
<p class="level0">e? 
<p class="level1">Shows help information about the backslash commands. 
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0"><br>
<p class="level0"><span Class="bold">Patterns</span> 
<p class="level1">
<p class="level1">The various ed commands accept a <span Class="emphasis">pattern</span> parameter to specify the object name(s) to be displayed. In the simplest case, a pattern is just the exact name of the object. The characters within a pattern are normally folded to lower case, just as in SQL names; for example, edt FOO will display the table named foo. As in SQL names, placing double quotes around a pattern stops folding to lower case. Should you need to include an actual double quote character in a pattern, write it as a pair of double quotes within a double-quote sequence; again this is in accord with the rules for SQL quoted identifiers. For example, edt "FOO""BAR" will display the table named FOO"BAR (not foo"bar). Unlike the normal rules for SQL names, you can put double quotes around just part of a pattern, for instance edt FOO"FOO"BAR will display the table named fooFOObar. 
<p class="level1">Whenever the <span Class="emphasis">pattern</span> parameter is omitted completely, the ed commands display all objects that are visible in the current schema search path (em this is equivalent to using * as the pattern. (An object is said to be visible if its containing schema is in the search path and no object of the same kind and name appears earlier in the search path. This is equivalent to the statement that the object can be referenced by name without explicit schema qualification.) To see all objects in the database regardless of visibility, use *.* as the pattern. 
<p class="level1">Within a pattern, * matches any sequence of characters (including no characters) and ? matches any single character. (This notation is comparable to Unix shell file name patterns.) For example, edt int* displays tables whose names begin with int. But within double quotes, * and ? lose these special meanings and are just matched literally. 
<p class="level1">A pattern that contains a dot (.) is interpreted as a schema name pattern followed by an object name pattern. For example, edt foo*.*bar* displays all tables whose table name includes bar that are in schemas whose schema name starts with foo. When no dot appears, then the pattern matches only objects that are visible in the current schema search path. Again, a dot within double quotes loses its special meaning and is matched literally. 
<p class="level1">Advanced users can use regular-expression notations such as character classes, for example [0-9] to match any digit. All regular expression special characters work as specified in Section 9.7.3, (lqPOSIX Regular Expressions(rq, in the documentation, except for . which is taken as a separator as mentioned above, * which is translated to the regular-expression notation .*, ? which is translated to ., and $ which is matched literally. You can emulate these pattern characters at need by writing ? for ., (<span Class="emphasis">R</span>+|) for <span Class="emphasis">R</span>*, or (<span Class="emphasis">R</span>|) for <span Class="emphasis">R</span>?. $ is not needed as a regular-expression character since the pattern must match the whole name, unlike the usual interpretation of regular expressions (in other words, $ is automatically appended to your pattern). Write * at the beginning and/or end if you don*(Aqt wish the pattern to be anchored. Note that within double quotes, all regular expression special characters lose their special meanings and are matched literally. Also, the regular expression special characters are matched literally in operator name patterns (i.e., the argument of edo). 
<p class="level0"><a name="Advanced"></a><h2 class="nroffsh">Advanced Features</h2>
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0"><br>
<p class="level0"><span Class="bold">Variables</span> 
<p class="level1">
<p class="level1">
<p class="level1">psql provides variable substitution features similar to common Unix command shells. Variables are simply name/value pairs, where the value can be any string of any length. The name must consist of letters (including non-Latin letters), digits, and underscores. 
<p class="level1">To set a variable, use the psql meta-command <span Class="bold">eset</span>. For example, 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
testdb=&gt; <span class="bold">eset foo bar</span>
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">sets the variable foo to the value bar. To retrieve the content of the variable, precede the name with a colon, for example: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
testdb=&gt; <span class="bold">eecho :foo</span>
bar
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">This works in both regular SQL commands and meta-commands; there is more detail in SQL Interpolation, below. 
<p class="level1">If you call <span Class="bold">eset</span> without a second argument, the variable is set, with an empty string as value. To unset (i.e., delete) a variable, use the command <span Class="bold">eunset</span>. To show the values of all variables, call <span Class="bold">eset</span> without any argument. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Note</span> 
<p class="level2"><br>
<p class="level2">The arguments of <span Class="bold">eset</span> are subject to the same substitution rules as with other commands. Thus you can construct interesting references such as eset :foo *(Aqsomething*(Aq and get (lqsoft links(rq or (lqvariable variables(rq of Perl or PHP fame, respectively. Unfortunately (or fortunately?), there is no way to do anything useful with these constructs. On the other hand, eset bar :foo is a perfectly valid way to copy a variable. 
<p class="level2">
<p class="level1">
<p class="level1">A number of these variables are treated specially by psql. They represent certain option settings that can be changed at run time by altering the value of the variable, or in some cases represent changeable state of psql. Although you can use these variables for other purposes, this is not recommended, as the program behavior might grow really strange really quickly. By convention, all specially treated variables*(Aq names consist of all upper-case ASCII letters (and possibly digits and underscores). To ensure maximum compatibility in the future, avoid using such variable names for your own purposes. A list of all specially treated variables follows. 
<p class="level1"><span Class="emphasis">AUTOCOMMIT</span> 
<p class="level2">When on (the default), each SQL command is automatically committed upon successful completion. To postpone commit in this mode, you must enter a <span Class="bold">BEGIN</span> or <span Class="bold">START TRANSACTION</span> SQL command. When off or unset, SQL commands are not committed until you explicitly issue <span Class="bold">COMMIT</span> or <span Class="bold">END</span>. The autocommit-off mode works by issuing an implicit <span Class="bold">BEGIN</span> for you, just before any command that is not already in a transaction block and is not itself a <span Class="bold">BEGIN</span> or other transaction-control command, nor a command that cannot be executed inside a transaction block (such as <span Class="bold">VACUUM</span>). 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level3">
<p class="level3">
<p class="level3">
<p class="level3"><br>
<p class="level3"><span Class="bold">Note</span> 
<p class="level3"><br>In autocommit-off mode, you must explicitly abandon any failed transaction by entering <span Class="bold">ABORT</span> or <span Class="bold">ROLLBACK</span>. Also keep in mind that if you exit the session without committing, your work will be lost. 
<p class="level3">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level3">
<p class="level3">
<p class="level3">
<p class="level3"><br>
<p class="level3"><span Class="bold">Note</span> 
<p class="level3"><br>The autocommit-on mode is PostgreSQL*(Aqs traditional behavior, but autocommit-off is closer to the SQL spec. If you prefer autocommit-off, you might wish to set it in the system-wide psqlrc file or your ~/.psqlrc file. 
<p class="level3">
<p class="level2">
<p class="level1">
<p class="level1"><span Class="emphasis">COMP_KEYWORD_CASE</span> 
<p class="level2">Determines which letter case to use when completing an SQL key word. If set to lower or upper, the completed word will be in lower or upper case, respectively. If set to preserve-lower or preserve-upper (the default), the completed word will be in the case of the word already entered, but words being completed without anything entered will be in lower or upper case, respectively. 
<p class="level1">
<p class="level1"><span Class="emphasis">DBNAME</span> 
<p class="level2">The name of the database you are currently connected to. This is set every time you connect to a database (including program start-up), but can be unset. 
<p class="level1">
<p class="level1"><span Class="emphasis">ECHO</span> 
<p class="level2">If set to all, all nonempty input lines are printed to standard output as they are read. (This does not apply to lines read interactively.) To select this behavior on program start-up, use the switch <span Class="bold">-a</span>. If set to queries, psql prints each query to standard output as it is sent to the server. The switch for this is <span Class="bold">-e</span>. 
<p class="level1">
<p class="level1"><span Class="emphasis">ECHO_HIDDEN</span> 
<p class="level2">When this variable is set to on and a backslash command queries the database, the query is first shown. This feature helps you to study PostgreSQL internals and provide similar functionality in your own programs. (To select this behavior on program start-up, use the switch <span Class="bold">-E</span>.) If you set the variable to the value noexec, the queries are just shown but are not actually sent to the server and executed. 
<p class="level1">
<p class="level1"><span Class="emphasis">ENCODING</span> 
<p class="level2">The current client character set encoding. 
<p class="level1">
<p class="level1"><span Class="emphasis">FETCH_COUNT</span> 
<p class="level2">If this variable is set to an integer value &gt; 0, the results of <span Class="bold">SELECT</span> queries are fetched and displayed in groups of that many rows, rather than the default behavior of collecting the entire result set before display. Therefore only a limited amount of memory is used, regardless of the size of the result set. Settings of 100 to 1000 are commonly used when enabling this feature. Keep in mind that when using this feature, a query might fail after having already displayed some rows. 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level3">
<p class="level3">
<p class="level3">
<p class="level3"><br>
<p class="level3"><span Class="bold">Tip</span> 
<p class="level3"><br>Although you can use any output format with this feature, the default aligned format tends to look bad because each group of <span Class="emphasis">FETCH_COUNT</span> rows will be formatted separately, leading to varying column widths across the row groups. The other output formats work better. 
<p class="level3">
<p class="level2">
<p class="level1">
<p class="level1"><span Class="emphasis">HISTCONTROL</span> 
<p class="level2">If this variable is set to ignorespace, lines which begin with a space are not entered into the history list. If set to a value of ignoredups, lines matching the previous history line are not entered. A value of ignoreboth combines the two options. If unset, or if set to any other value than those above, all lines read in interactive mode are saved on the history list. 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level3">
<p class="level3">
<p class="level3">
<p class="level3"><br>
<p class="level3"><span Class="bold">Note</span> 
<p class="level3"><br>This feature was shamelessly plagiarized from Bash. 
<p class="level3">
<p class="level2">
<p class="level1">
<p class="level1"><span Class="emphasis">HISTFILE</span> 
<p class="level2">The file name that will be used to store the history list. The default value is ~/.psql_history. For example, putting: 
<p class="level2">
<p class="level2">
<p class="level3">
<p class="level3"><pre class="level3">
eset HISTFILE ~/.psql_history- :DBNAME
</pre>

<p class="level3">
<p class="level3">
<p class="level2">
<p class="level2">
<p class="level2">in ~/.psqlrc will cause psql to maintain a separate history for each database. 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level3">
<p class="level3">
<p class="level3">
<p class="level3"><br>
<p class="level3"><span Class="bold">Note</span> 
<p class="level3"><br>This feature was shamelessly plagiarized from Bash. 
<p class="level3">
<p class="level2">
<p class="level1">
<p class="level1"><span Class="emphasis">HISTSIZE</span> 
<p class="level2">The number of commands to store in the command history. The default value is 500. 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level3">
<p class="level3">
<p class="level3">
<p class="level3"><br>
<p class="level3"><span Class="bold">Note</span> 
<p class="level3"><br>This feature was shamelessly plagiarized from Bash. 
<p class="level3">
<p class="level2">
<p class="level1">
<p class="level1"><span Class="emphasis">HOST</span> 
<p class="level2">The database server host you are currently connected to. This is set every time you connect to a database (including program start-up), but can be unset. 
<p class="level1">
<p class="level1"><span Class="emphasis">IGNOREEOF</span> 
<p class="level2">If unset, sending an EOF character (usually Control+D) to an interactive session of psql will terminate the application. If set to a numeric value, that many EOF characters are ignored before the application terminates. If the variable is set but has no numeric value, the default is 10. 
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level3">
<p class="level3">
<p class="level3">
<p class="level3"><br>
<p class="level3"><span Class="bold">Note</span> 
<p class="level3"><br>This feature was shamelessly plagiarized from Bash. 
<p class="level3">
<p class="level2">
<p class="level1">
<p class="level1"><span Class="emphasis">LASTOID</span> 
<p class="level2">The value of the last affected OID, as returned from an <span Class="bold">INSERT</span> or <span Class="bold">elo_import</span> command. This variable is only guaranteed to be valid until after the result of the next SQL command has been displayed. 
<p class="level1">
<p class="level1"><span Class="emphasis">ON_ERROR_ROLLBACK</span> 
<p class="level2">When set to on, if a statement in a transaction block generates an error, the error is ignored and the transaction continues. When set to interactive, such errors are only ignored in interactive sessions, and not when reading script files. When unset or set to off, a statement in a transaction block that generates an error aborts the entire transaction. The error rollback mode works by issuing an implicit <span Class="bold">SAVEPOINT</span> for you, just before each command that is in a transaction block, and then rolling back to the savepoint if the command fails. 
<p class="level1">
<p class="level1"><span Class="emphasis">ON_ERROR_STOP</span> 
<p class="level2">By default, command processing continues after an error. When this variable is set to on, processing will instead stop immediately. In interactive mode, psql will return to the command prompt; otherwise, psql will exit, returning error code 3 to distinguish this case from fatal error conditions, which are reported using error code 1. In either case, any currently running scripts (the top-level script, if any, and any other scripts which it may have in invoked) will be terminated immediately. If the top-level command string contained multiple SQL commands, processing will stop with the current command. 
<p class="level1">
<p class="level1"><span Class="emphasis">PORT</span> 
<p class="level2">The database server port to which you are currently connected. This is set every time you connect to a database (including program start-up), but can be unset. 
<p class="level1">
<p class="level1"><span Class="emphasis">PROMPT1</span> <br><span Class="emphasis">PROMPT2</span> <br><span Class="emphasis">PROMPT3</span> 
<p class="level2">These specify what the prompts psql issues should look like. See Prompting below. 
<p class="level1">
<p class="level1"><span Class="emphasis">QUIET</span> 
<p class="level2">Setting this variable to on is equivalent to the command line option <span Class="bold">-q</span>. It is probably not too useful in interactive mode. 
<p class="level1">
<p class="level1"><span Class="emphasis">SINGLELINE</span> 
<p class="level2">Setting this variable to on is equivalent to the command line option <span Class="bold">-S</span>. 
<p class="level1">
<p class="level1"><span Class="emphasis">SINGLESTEP</span> 
<p class="level2">Setting this variable to on is equivalent to the command line option <span Class="bold">-s</span>. 
<p class="level1">
<p class="level1"><span Class="emphasis">USER</span> 
<p class="level2">The database user you are currently connected as. This is set every time you connect to a database (including program start-up), but can be unset. 
<p class="level1">
<p class="level1"><span Class="emphasis">VERBOSITY</span> 
<p class="level2">This variable can be set to the values default, verbose, or terse to control the verbosity of error reports. 
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0"><br>
<p class="level0"><span Class="bold">SQL Interpolation</span> 
<p class="level1">
<p class="level1">A key feature of psql variables is that you can substitute ((lqinterpolate(rq) them into regular SQL statements, as well as the arguments of meta-commands. Furthermore, psql provides facilities for ensuring that variable values used as SQL literals and identifiers are properly quoted. The syntax for interpolating a value without any quoting is to prepend the variable name with a colon (:). For example, 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
testdb=&gt; <span class="bold">eset foo *(Aqmy_table*(Aq</span>
testdb=&gt; <span class="bold">SELECT * FROM :foo;</span>
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">would query the table my_table. Note that this may be unsafe: the value of the variable is copied literally, so it can contain unbalanced quotes, or even backslash commands. You must make sure that it makes sense where you put it. 
<p class="level1">When a value is to be used as an SQL literal or identifier, it is safest to arrange for it to be quoted. To quote the value of a variable as an SQL literal, write a colon followed by the variable name in single quotes. To quote the value as an SQL identifier, write a colon followed by the variable name in double quotes. These constructs deal correctly with quotes and other special characters embedded within the variable value. The previous example would be more safely written this way: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
testdb=&gt; <span class="bold">eset foo *(Aqmy_table*(Aq</span>
testdb=&gt; <span class="bold">SELECT * FROM :"foo";</span>
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">Variable interpolation will not be performed within quoted SQL literals and identifiers. Therefore, a construction such as *(Aq:foo*(Aq doesn*(Aqt work to produce a quoted literal from a variable*(Aqs value (and it would be unsafe if it did work, since it wouldn*(Aqt correctly handle quotes embedded in the value). 
<p class="level1">One example use of this mechanism is to copy the contents of a file into a table column. First load the file into a variable and then interpolate the variable*(Aqs value as a quoted string: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
testdb=&gt; <span class="bold">eset content `cat my_file.txt`</span>
testdb=&gt; <span class="bold">INSERT INTO my_table VALUES (:*(Aqcontent*(Aq);</span>
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">(Note that this still won*(Aqt work if my_file.txt contains NUL bytes. psql does not support embedded NUL bytes in variable values.) 
<p class="level1">Since colons can legally appear in SQL commands, an apparent attempt at interpolation (that is, :name, :*(Aqname*(Aq, or :"name") is not replaced unless the named variable is currently set. In any case, you can escape a colon with a backslash to protect it from substitution. 
<p class="level1">The colon syntax for variables is standard SQL for embedded query languages, such as ECPG. The colon syntaxes for array slices and type casts are PostgreSQL extensions, which can sometimes conflict with the standard usage. The colon-quote syntax for escaping a variable*(Aqs value as an SQL literal or identifier is a psql extension. 
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0"><br>
<p class="level0"><span Class="bold">Prompting</span> 
<p class="level1">
<p class="level1">The prompts psql issues can be customized to your preference. The three variables <span Class="emphasis">PROMPT1</span>, <span Class="emphasis">PROMPT2</span>, and <span Class="emphasis">PROMPT3</span> contain strings and special escape sequences that describe the appearance of the prompt. Prompt 1 is the normal prompt that is issued when psql requests a new command. Prompt 2 is issued when more input is expected during command input because the command was not terminated with a semicolon or a quote was not closed. Prompt 3 is issued when you run an SQL <span Class="bold">COPY</span> command and you are expected to type in the row values on the terminal. 
<p class="level1">The value of the selected prompt variable is printed literally, except where a percent sign (%) is encountered. Depending on the next character, certain other text is substituted instead. Defined substitutions are: 
<p class="level1">%M 
<p class="level2">The full host name (with domain name) of the database server, or [local] if the connection is over a Unix domain socket, or [local:<span Class="emphasis">/dir/name</span>], if the Unix domain socket is not at the compiled in default location. 
<p class="level1">
<p class="level1">%m 
<p class="level2">The host name of the database server, truncated at the first dot, or [local] if the connection is over a Unix domain socket. 
<p class="level1">
<p class="level1">%&gt; 
<p class="level2">The port number at which the database server is listening. 
<p class="level1">
<p class="level1">%n 
<p class="level2">The database session user name. (The expansion of this value might change during a database session as the result of the command <span Class="bold">SET SESSION AUTHORIZATION</span>.) 
<p class="level1">
<p class="level1">%/ 
<p class="level2">The name of the current database. 
<p class="level1">
<p class="level1">%~ 
<p class="level2">Like %/, but the output is ~ (tilde) if the database is your default database. 
<p class="level1">
<p class="level1">%&#35; 
<p class="level2">If the session user is a database superuser, then a &#35;, otherwise a &gt;. (The expansion of this value might change during a database session as the result of the command <span Class="bold">SET SESSION AUTHORIZATION</span>.) 
<p class="level1">
<p class="level1">%R 
<p class="level2">In prompt 1 normally =, but ^ if in single-line mode, and ! if the session is disconnected from the database (which can happen if <span Class="bold">econnect</span> fails). In prompt 2 the sequence is replaced by -, *, a single quote, a double quote, or a dollar sign, depending on whether psql expects more input because the command wasn*(Aqt terminated yet, because you are inside a /* ... */ comment, or because you are inside a quoted or dollar-escaped string. In prompt 3 the sequence doesn*(Aqt produce anything. 
<p class="level1">
<p class="level1">%x 
<p class="level2">Transaction status: an empty string when not in a transaction block, or * when in a transaction block, or ! when in a failed transaction block, or ? when the transaction state is indeterminate (for example, because there is no connection). 
<p class="level1">
<p class="level1">%<span Class="emphasis">digits</span> 
<p class="level2">The character with the indicated octal code is substituted. 
<p class="level1">
<p class="level1">%:<span Class="emphasis">name</span>: 
<p class="level2">The value of the psql variable <span Class="emphasis">name</span>. See the section Variables for details. 
<p class="level1">
<p class="level1">%`<span Class="emphasis">command</span>` 
<p class="level2">The output of <span Class="emphasis">command</span>, similar to ordinary (lqback-tick(rq substitution. 
<p class="level1">
<p class="level1">%[ ... %] 
<p class="level2">Prompts can contain terminal control characters which, for example, change the color, background, or style of the prompt text, or change the title of the terminal window. In order for the line editing features of Readline to work properly, these non-printing control characters must be designated as invisible by surrounding them with %[ and %]. Multiple pairs of these can occur within the prompt. For example: 
<p class="level2">
<p class="level2">
<p class="level3">
<p class="level3"><pre class="level3">
testdb=&gt; eset PROMPT1 *(Aq%[%033[1;33;40m%]%n@%/%R%[%033[0m%]%&#35; *(Aq
</pre>

<p class="level3">
<p class="level3">
<p class="level2">
<p class="level2">
<p class="level2">results in a boldfaced (1;) yellow-on-black (33;40) prompt on VT100-compatible, color-capable terminals. 
<p class="level1">To insert a percent sign into your prompt, write %%. The default prompts are *(Aq%/%R%&#35; *(Aq for prompts 1 and 2, and *(Aq&gt;&gt; *(Aq for prompt 3. 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2">
<p class="level2">
<p class="level2"><br>
<p class="level2"><span Class="bold">Note</span> 
<p class="level2"><br>
<p class="level2">This feature was shamelessly plagiarized from tcsh. 
<p class="level2">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0">
<p class="level0"><br>
<p class="level0"><span Class="bold">Command-Line Editing</span> 
<p class="level1">
<p class="level1">
<p class="level1">psql supports the Readline library for convenient line editing and retrieval. The command history is automatically saved when psql exits and is reloaded when psql starts up. Tab-completion is also supported, although the completion logic makes no claim to be an SQL parser. The queries generated by tab-completion can also interfere with other SQL commands, e.g. SET TRANSACTION ISOLATION LEVEL. If for some reason you do not like the tab completion, you can turn it off by putting this in a file named .inputrc in your home directory: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
$if psql
set disable-completion on
$endif
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">(This is not a psql but a Readline feature. Read its documentation for further details.) 
<p class="level0"><a name="ENVIRONMENT"></a><h2 class="nroffsh">ENVIRONMENT</h2>
<p class="level0">
<p class="level0"><span Class="bold">COLUMNS</span> 
<p class="level1">If epset columns is zero, controls the width for the wrapped format and width for determining if wide output requires the pager or should be switched to the vertical format in expanded auto mode. 
<p class="level0">
<p class="level0"><span Class="bold">PAGER</span> 
<p class="level1">If the query results do not fit on the screen, they are piped through this command. Typical values are more or less. The default is platform-dependent. The use of the pager can be disabled by using the <span Class="bold">epset</span> command. 
<p class="level0">
<p class="level0"><span Class="bold">PGDATABASE</span> <br><span Class="bold">PGHOST</span> <br><span Class="bold">PGPORT</span> <br><span Class="bold">PGUSER</span> 
<p class="level1">Default connection parameters (see Section 31.14, (lqEnvironment Variables(rq, in the documentation). 
<p class="level0">
<p class="level0"><span Class="bold">PSQL_EDITOR</span> <br><span Class="bold">EDITOR</span> <br><span Class="bold">VISUAL</span> 
<p class="level1">Editor used by the <span Class="bold">ee</span> and <span Class="bold">eef</span> commands. The variables are examined in the order listed; the first that is set is used. 
<p class="level1">The built-in default editors are vi on Unix systems and notepad.exe on Windows systems. 
<p class="level0">
<p class="level0"><span Class="bold">PSQL_EDITOR_LINENUMBER_ARG</span> 
<p class="level1">When <span Class="bold">ee</span> or <span Class="bold">eef</span> is used with a line number argument, this variable specifies the command-line argument used to pass the starting line number to the user*(Aqs editor. For editors such as Emacs or vi, this is a plus sign. Include a trailing space in the value of the variable if there needs to be space between the option name and the line number. Examples: 
<p class="level1">
<p class="level1">
<p class="level2">
<p class="level2"><pre class="level2">
PSQL_EDITOR_LINENUMBER_ARG=*(Aq+*(Aq
PSQL_EDITOR_LINENUMBER_ARG=*(Aq--line *(Aq
</pre>

<p class="level2">
<p class="level2">
<p class="level1">
<p class="level1">
<p class="level1">The default is + on Unix systems (corresponding to the default editor vi, and useful for many other common editors); but there is no default on Windows systems. 
<p class="level0">
<p class="level0"><span Class="bold">PSQL_HISTORY</span> 
<p class="level1">Alternative location for the command history file. Tilde (~) expansion is performed. 
<p class="level0">
<p class="level0"><span Class="bold">PSQLRC</span> 
<p class="level1">Alternative location of the user*(Aqs .psqlrc file. Tilde (~) expansion is performed. 
<p class="level0">
<p class="level0"><span Class="bold">SHELL</span> 
<p class="level1">Command executed by the <span Class="bold">e!</span> command. 
<p class="level0">
<p class="level0"><span Class="bold">TMPDIR</span> 
<p class="level1">Directory for storing temporary files. The default is /tmp. 
<p class="level0">
<p class="level0">This utility, like most other PostgreSQL utilities, also uses the environment variables supported by libpq (see Section 31.14, (lqEnvironment Variables(rq, in the documentation). <a name="FILES"></a><h2 class="nroffsh">FILES</h2>
<p class="level0">
<p class="level0">psqlrc and ~/.psqlrc 
<p class="level1">Unless it is passed an <span Class="bold">-X</span> or <span Class="bold">-c</span> option, psql attempts to read and execute commands from the system-wide startup file (psqlrc) and then the user*(Aqs personal startup file (~/.psqlrc), after connecting to the database but before accepting normal commands. These files can be used to set up the client and/or the server to taste, typically with <span Class="bold">eset</span> and <span Class="bold">SET</span> commands. 
<p class="level1">The system-wide startup file is named psqlrc and is sought in the installation*(Aqs (lqsystem configuration(rq directory, which is most reliably identified by running pg_config --sysconfdir. By default this directory will be ../etc/ relative to the directory containing the PostgreSQL executables. The name of this directory can be set explicitly via the <span Class="bold">PGSYSCONFDIR</span> environment variable. 
<p class="level1">The user*(Aqs personal startup file is named .psqlrc and is sought in the invoking user*(Aqs home directory. On Windows, which lacks such a concept, the personal startup file is named %APPDATA%epostgresqlepsqlrc.conf. The location of the user*(Aqs startup file can be set explicitly via the <span Class="bold">PSQLRC</span> environment variable. 
<p class="level1">Both the system-wide startup file and the user*(Aqs personal startup file can be made psql-version-specific by appending a dash and the PostgreSQL major or minor release number to the file name, for example ~/.psqlrc-9.2 or ~/.psqlrc-9.2.5. The most specific version-matching file will be read in preference to a non-version-specific file. 
<p class="level0">
<p class="level0">.psql_history 
<p class="level1">The command-line history is stored in the file ~/.psql_history, or %APPDATA%epostgresqlepsql_history on Windows. 
<p class="level1">The location of the history file can be set explicitly via the <span Class="bold">PSQL_HISTORY</span> environment variable. 
<p class="level0"><a name="NOTES"></a><h2 class="nroffsh">NOTES</h2>
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04'(buh'+03'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level1">
<p class="level1">In an earlier life psql allowed the first argument of a single-letter backslash command to start directly after the command, without intervening whitespace. As of PostgreSQL 8.4 this is no longer allowed. 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04'(buh'+03'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level1">
<p class="level1">psql works best with servers of the same or an older major version. Backslash commands are particularly likely to fail if the server is of a newer version than psql itself. However, backslash commands of the ed family should work with servers of versions back to 7.4, though not necessarily with servers newer than psql itself. The general functionality of running SQL commands and displaying query results should also work with servers of a newer major version, but this cannot be guaranteed in all cases. 
<p class="level1">If you want to use psql to connect to several servers of different major versions, it is recommended that you use the newest version of psql. Alternatively, you can keep a copy of psql from each major version around and be sure to use the version that matches the respective server. But in practice, this additional complication should not be necessary. 
<p class="level0"><a name="NOTES"></a><h2 class="nroffsh">NOTES FOR WINDOWS USERS</h2>
<p class="level0">
<p class="level0">
<p class="level0">psql is built as a (lqconsole application(rq. Since the Windows console windows use a different encoding than the rest of the system, you must take special care when using 8-bit characters within psql. If psql detects a problematic console code page, it will warn you at startup. To change the console code page, two things are necessary: 
<p class="level0">
<p class="level1">
<p class="level1">h'-04'(buh'+03'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level1">
<p class="level1">Set the code page by entering <span Class="bold">cmd.exe /c chcp 1252</span>. (1252 is a code page that is appropriate for German; replace it with your value.) If you are using Cygwin, you can put this command in /etc/profile. 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1">h'-04'(buh'+03'c 
<p class="level1">
<p class="level1">
<p class="level1">
<p class="level0"><a name="bu"></a><span class="nroffip">\(bu 2.3</span> 
<p class="level1">
<p class="level1">Set the console font to Lucida Console, because the raster font does not work with the ANSI code page. 
<p class="level0"><a name="EXAMPLES"></a><h2 class="nroffsh">EXAMPLES</h2>
<p class="level0">
<p class="level0">The first example shows how to spread a command over several lines of input. Notice the changing prompt: 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1"><pre class="level1">
testdb=&gt; <span class="bold">CREATE TABLE my_table (</span>
testdb(&gt; <span class="bold"> first integer not null default 0,</span>
testdb(&gt; <span class="bold"> second text)</span>
testdb-&gt; <span class="bold">;</span>
CREATE TABLE
</pre>

<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">Now look at the table definition again: 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1"><pre class="level1">
testdb=&gt; <span class="bold">ed my_table</span>
&nbsp;            Table "my_table"
&nbsp;Attribute |  Type   |      Modifier
-----------+---------+--------------------
&nbsp;first     | integer | not null default 0
&nbsp;second    | text    |
</pre>

<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">Now we change the prompt to something more interesting: 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1"><pre class="level1">
testdb=&gt; <span class="bold">eset PROMPT1 *(Aq%n@%m %~%R%&#35; *(Aq</span>
peter@localhost testdb=&gt;
</pre>

<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">Let*(Aqs assume you have filled the table with data and want to take a look at it: 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1"><pre class="level1">
peter@localhost testdb=&gt; SELECT * FROM my_table;
&nbsp;first | second
-------+--------
&nbsp;    1 | one
&nbsp;    2 | two
&nbsp;    3 | three
&nbsp;    4 | four
(4 rows)
</pre>

<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">You can display tables in different ways by using the <span Class="bold">epset</span> command: 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1"><pre class="level1">
peter@localhost testdb=&gt; <span class="bold">epset border 2</span>
Border style is 2.
peter@localhost testdb=&gt; <span class="bold">SELECT * FROM my_table;</span>
+-------+--------+
| first | second |
+-------+--------+
|     1 | one    |
|     2 | two    |
|     3 | three  |
|     4 | four   |
+-------+--------+
(4 rows)
&nbsp;
peter@localhost testdb=&gt; <span class="bold">epset border 0</span>
Border style is 0.
peter@localhost testdb=&gt; <span class="bold">SELECT * FROM my_table;</span>
first second
----- ------
&nbsp;   1 one
&nbsp;   2 two
&nbsp;   3 three
&nbsp;   4 four
(4 rows)
&nbsp;
peter@localhost testdb=&gt; <span class="bold">epset border 1</span>
Border style is 1.
peter@localhost testdb=&gt; <span class="bold">epset format unaligned</span>
Output format is unaligned.
peter@localhost testdb=&gt; <span class="bold">epset fieldsep ","</span>
Field separator is ",".
peter@localhost testdb=&gt; <span class="bold">epset tuples_only</span>
Showing only tuples.
peter@localhost testdb=&gt; <span class="bold">SELECT second, first FROM my_table;</span>
one,1
two,2
three,3
four,4
</pre>

<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">Alternatively, use the short commands: 
<p class="level0">
<p class="level0">
<p class="level1">
<p class="level1"><pre class="level1">
peter@localhost testdb=&gt; <span class="bold">ea et ex</span>
Output format is aligned.
Tuples only is off.
Expanded display is on.
peter@localhost testdb=&gt; <span class="bold">SELECT * FROM my_table;</span>
-[ RECORD 1 ]-
first  | 1
second | one
-[ RECORD 2 ]-
first  | 2
second | two
-[ RECORD 3 ]-
first  | 3
second | three
-[ RECORD 4 ]-
first  | 4
second | four
</pre>

<p class="level1">
<p class="level1">
<p class="level0">
<p class="level0">
<p class="level0">